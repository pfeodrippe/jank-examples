(ns vybe.type-test
  (:require
   [clojure.test :refer [deftest is testing]]
   [vybe.type :as vt]
   [vybe.flecs :as vf]))

;; Tests for vybe.type defcomp implementation.

;; =============================================================================
;; make-comp tests
;; =============================================================================

(deftest make-comp-test
  (testing "make-comp creates correct descriptor structure"
    (let [desc (vt/make-comp "test_ns__Position" [[:x :float] [:y :float]])]
      (is (= "test_ns__Position" (:name desc)))
      (is (= 2 (count (:fields desc))))
      (is (= "x" (:name (first (:fields desc)))))
      (is (= :float (:type (first (:fields desc)))))
      (is (= "y" (:name (second (:fields desc)))))
      (is (= :float (:type (second (:fields desc))))))))

(deftest make-comp-single-field-test
  (testing "make-comp with single field"
    (let [desc (vt/make-comp "test_ns__Health" [[:value :i32]])]
      (is (= "test_ns__Health" (:name desc)))
      (is (= 1 (count (:fields desc))))
      (is (= "value" (:name (first (:fields desc)))))
      (is (= :i32 (:type (first (:fields desc))))))))

(deftest make-comp-multiple-types-test
  (testing "make-comp with different field types"
    (let [desc (vt/make-comp "test_ns__Stats" [[:health :i32]
                                               [:speed :float]
                                               [:name :string]
                                               [:alive :bool]])]
      (is (= "test_ns__Stats" (:name desc)))
      (is (= 4 (count (:fields desc))))
      (is (= :i32 (:type (nth (:fields desc) 0))))
      (is (= :float (:type (nth (:fields desc) 1))))
      (is (= :string (:type (nth (:fields desc) 2))))
      (is (= :bool (:type (nth (:fields desc) 3)))))))

;; =============================================================================
;; defcomp macro tests
;; =============================================================================

(vt/defcomp Position [[:x :float] [:y :float]])
(vt/defcomp Velocity [[:dx :float] [:dy :float]])
(vt/defcomp Health [[:value :i32]])

(deftest defcomp-test
  (testing "defcomp creates var with correct descriptor"
    (let [pos-desc (vt/comp-descriptor Position)
          vel-desc (vt/comp-descriptor Velocity)
          health-desc (vt/comp-descriptor Health)]
      (is (= "vybe_type_test__Position" (:name pos-desc)))
      (is (= 2 (count (:fields pos-desc))))
      (is (= "vybe_type_test__Velocity" (:name vel-desc)))
      (is (= "vybe_type_test__Health" (:name health-desc)))
      (is (= 1 (count (:fields health-desc)))))))

;; =============================================================================
;; register-comp! tests
;; =============================================================================

(deftest register-comp-test
  (testing "register-comp! registers component with Flecs world"
    (let [world (vf/make-world)
          pos-id (vt/register-comp! world Position)]
      ;; Component ID should be non-zero (valid entity)
      (is (> pos-id 0))
      (vf/destroy-world! world))))

(deftest register-multiple-comp-test
  (testing "register-comp! can register multiple components"
    (let [world (vf/make-world)
          pos-id (vt/register-comp! world Position)
          vel-id (vt/register-comp! world Velocity)
          health-id (vt/register-comp! world Health)]
      ;; All component IDs should be different non-zero values
      (is (> pos-id 0))
      (is (> vel-id 0))
      (is (> health-id 0))
      (is (not= pos-id vel-id))
      (is (not= vel-id health-id))
      (vf/destroy-world! world))))

;; =============================================================================
;; Field access tests
;; =============================================================================

(deftest add-comp-test
  (testing "add-comp! adds component to entity"
    (let [world (vf/make-world)
          _ (vt/register-comp! world Position)
          e (vf/new-entity world)]
      (vt/add-comp! world e Position)
      (is (vt/has-comp? world e Position))
      (vf/destroy-world! world))))

(deftest add-comp-with-map-test
  (testing "add-comp! with map initializes fields"
    (let [world (vf/make-world)
          _ (vt/register-comp! world Position)
          e (vf/new-entity world)]
      (vt/add-comp! world e Position {:x 10.5 :y 20.25})
      (let [pos (vt/get-comp world e Position)]
        (is (= 10.5 (:x pos)))
        (is (= 20.25 (:y pos))))
      (vf/destroy-world! world))))

(deftest add-comp-with-positional-args-test
  (testing "add-comp! with positional args initializes fields in order"
    (let [world (vf/make-world)
          _ (vt/register-comp! world Position)
          e (vf/new-entity world)]
      (vt/add-comp! world e Position 40.0 60.0)
      (let [pos (vt/get-comp world e Position)]
        (is (= 40.0 (:x pos)))
        (is (= 60.0 (:y pos))))
      (vf/destroy-world! world))))

(deftest get-comp-returns-map-test
  (testing "get-comp returns component data as a map"
    (let [world (vf/make-world)
          _ (vt/register-comp! world Position)
          e (vf/new-entity world)]
      (vt/add-comp! world e Position {:x 1.0 :y 2.0})
      (let [pos (vt/get-comp world e Position)]
        (is (map? pos))
        (is (= 1.0 (:x pos)))
        (is (= 2.0 (:y pos))))
      (vf/destroy-world! world))))

(deftest set-comp-partial-update-test
  (testing "set-comp! updates only specified fields (like merge)"
    (let [world (vf/make-world)
          _ (vt/register-comp! world Position)
          e (vf/new-entity world)]
      (vt/add-comp! world e Position {:x 1.0 :y 2.0})
      ;; Update only :x
      (vt/set-comp! world e Position {:x 100.0})
      (let [pos (vt/get-comp world e Position)]
        (is (= 100.0 (:x pos)))
        (is (= 2.0 (:y pos))))
      (vf/destroy-world! world))))

(deftest set-and-get-int-field-test
  (testing "int fields work correctly"
    (let [world (vf/make-world)
          _ (vt/register-comp! world Health)
          e (vf/new-entity world)]
      (vt/add-comp! world e Health {:value 100})
      (let [h (vt/get-comp world e Health)]
        (is (= 100 (:value h))))
      (vf/destroy-world! world))))

(deftest multiple-entities-with-components-test
  (testing "multiple entities can have same component with different values"
    (let [world (vf/make-world)
          _ (vt/register-comp! world Position)
          e1 (vf/new-entity world)
          e2 (vf/new-entity world)]
      (vt/add-comp! world e1 Position 1.0 2.0)
      (vt/add-comp! world e2 Position 100.0 200.0)
      ;; Verify values are independent
      (let [pos1 (vt/get-comp world e1 Position)
            pos2 (vt/get-comp world e2 Position)]
        (is (= 1.0 (:x pos1)))
        (is (= 2.0 (:y pos1)))
        (is (= 100.0 (:x pos2)))
        (is (= 200.0 (:y pos2))))
      (vf/destroy-world! world))))

;; =============================================================================
;; ComponentRef and merge! tests
;; =============================================================================

(deftest comp-ref-test
  (testing "get-comp returns a ComponentRef with metadata"
    (let [world (vf/make-world)
          _ (vt/register-comp! world Position)
          e (vf/new-entity world)]
      (vt/add-comp! world e Position {:x 5.0 :y 10.0})
      (let [pos (vt/get-comp world e Position)]
        ;; It should be a comp-ref
        (is (vt/comp-ref? pos))
        ;; It should have the metadata keys
        (is (contains? pos :vt/world-box))
        (is (contains? pos :vt/entity))
        (is (contains? pos :vt/comp))
        ;; Data fields should work
        (is (= 5.0 (:x pos)))
        (is (= 10.0 (:y pos))))
      (vf/destroy-world! world))))

(deftest merge!-test
  (testing "merge! updates component without world reference"
    (let [world (vf/make-world)
          _ (vt/register-comp! world Position)
          e (vf/new-entity world)]
      (vt/add-comp! world e Position {:x 1.0 :y 2.0})
      (let [pos (vt/get-comp world e Position)]
        ;; Update using merge! without world
        (vt/merge! pos {:x 99.0})
        ;; Verify the update took effect
        (let [pos2 (vt/get-comp world e Position)]
          (is (= 99.0 (:x pos2)))
          (is (= 2.0 (:y pos2)))))
      (vf/destroy-world! world))))

;; =============================================================================
;; Direct memory access tests
;; =============================================================================

(deftest field-metadata-test
  (testing "field offsets and sizes are cached after registration"
    (let [world (vf/make-world)
          _ (vt/register-comp! world Position)]
      ;; Should have cached metadata
      (is (some? (vt/get-comp-meta Position)))
      ;; Should have field offsets
      (is (= 0 (vt/field-offset Position :x)))
      (is (= 4 (vt/field-offset Position :y)))
      ;; Should have component size
      (is (= 8 (vt/comp-size Position)))
      (vf/destroy-world! world))))

(deftest init-comp-meta-test
  (testing "init-comp-meta! caches metadata using mini world"
    ;; Define a new component just for this test
    (let [TestComp (vt/make-comp "test__InitMetaComp" [[:a :i32] [:b :i32]])]
      ;; Initialize metadata with mini world
      (vt/init-comp-meta! TestComp)
      ;; Should have cached metadata without a real world
      (is (some? (vt/get-comp-meta TestComp)))
      (is (= 0 (vt/field-offset TestComp "a")))
      (is (= 4 (vt/field-offset TestComp "b")))
      (is (= 8 (vt/comp-size TestComp))))))

(deftest comp-test
  (testing "standalone instances work without @ and support vget for fresh reads"
    (let [pos-1 (Position {:x 42.5 :y 99.25})
          pos-2 (Position [42.5 99.25])]
      ;; Initial values accessible via keyword (snapshot)
      (is (= 42.5 (:x pos-1)))
      (is (= 99.25 (:y pos-1)))
      ;; After merge!, native memory is updated
      (vt/merge! pos-1 {:x 99.0})
      (vt/merge! pos-2 {:x 100.0})
      ;; vget reads fresh values from native memory
      (is (= 99.0 (vt/vget pos-1 :x)))
      (is (= 99.25 (vt/vget pos-1 :y)))
      (is (= 100.0 (vt/vget pos-2 :x)))
      (is (= 99.25 (vt/vget pos-2 :y))))))

(deftest get-field-direct-test
  (testing "get-field-direct reads individual fields with direct memory access"
    (let [world (vf/make-world)
          _ (vt/register-comp! world Position)
          e (vf/new-entity world)]
      (vt/add-comp! world e Position {:x 42.5 :y 99.25})
      ;; Read fields directly
      (is (= 42.5 (vt/get-field-direct world e Position :x)))
      (is (= 99.25 (vt/get-field-direct world e Position :y)))
      (vf/destroy-world! world))))

(defn -main [& args]
  (let [results (clojure.test/run-tests 'vybe.type-test)]
    (when-not (clojure.test/successful? results)
      (throw (ex-info "Tests failed!" results)))))
