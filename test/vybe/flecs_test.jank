(ns vybe.flecs-test
  (:require
   [clojure.test :refer [deftest testing is]]
   [vybe.flecs :as vf]
   [vybe.type :as vt]
   ["flecs.h" :as fl :scope ""]))

;; Define components for query tests
(vt/defcomp Position [[:x :float] [:y :float]])
(vt/defcomp Velocity [[:dx :float] [:dy :float]])

;; =============================================================================
;; Basic World Tests
;; =============================================================================

(deftest world-creation-test
  (testing "create and destroy world"
    (let [w (vf/make-world)]
      (is (some? w))
      (vf/destroy-world! w))))

(deftest world-mini-creation-test
  (testing "create and destroy mini world"
    (let [w (vf/make-world-mini)]
      (is (some? w))
      (vf/destroy-world! w))))

(deftest world-ptr-test
  (testing "world-ptr macro extracts native pointer"
    (let [w (vf/make-world)
          ;; world-ptr is a macro that returns native ecs_world_t*
          ;; We can't directly test the pointer value, but we can use it
          _ (fl/ecs_progress (vf/world-ptr w) (cpp/float. 0.0))]
      (vf/destroy-world! w)
      (is true))))

;; =============================================================================
;; Entity Tests
;; =============================================================================

(deftest new-entity-test
  (testing "create new entity"
    (let [w (vf/make-world)
          e (vf/new-entity w)]
      (is (> e 0))
      (vf/destroy-world! w))))

(deftest eid-test
  (testing "eid with integer returns same value"
    (let [w (vf/make-world)]
      (is (= 42 (vf/eid w 42)))
      (vf/destroy-world! w))))

;; =============================================================================
;; Progress Tests
;; =============================================================================

(deftest progress-test
  (testing "progress advances world"
    (let [w (vf/make-world)]
      ;; Should not throw
      (vf/progress w)
      (vf/progress w 0.016)
      (vf/destroy-world! w)
      (is true))))

;; =============================================================================
;; defn* Macro Tests
;; =============================================================================

(deftest defn*-generates-macro-test
  (testing "defn* with :tag generates working macro"
    ;; world-ptr is defined with defn* and should work as a macro
    (let [w (vf/make-world)]
      ;; This uses world-ptr which is defined with defn*
      ;; If it works, the entity creation succeeds
      (let [e (vf/new-entity w)]
        (is (> e 0)))
      (vf/destroy-world! w))))

;; =============================================================================
;; Query and Iteration Tests
;; =============================================================================

(deftest query-str-test
  (testing "query-str creates a query"
    (let [w (vf/make-world)
          ;; Create a tag
          tag (fl/ecs_new (vf/world-ptr w))
          ;; Create entities with the tag
          e1 (fl/ecs_new (vf/world-ptr w))
          e2 (fl/ecs_new (vf/world-ptr w))]
      ;; Add tag to entities
      (fl/ecs_add_id (vf/world-ptr w) e1 tag)
      (fl/ecs_add_id (vf/world-ptr w) e2 tag)
      ;; Query should work (we can't easily test the returned value,
      ;; but it shouldn't throw)
      (vf/destroy-world! w)
      (is true))))

(deftest with-query-test
  (testing "with-query iterates over entities with Position and Velocity"
    (let [w (vf/make-world)
          ;; Register components
          _ (vt/register-comp! w Position)
          _ (vt/register-comp! w Velocity)
          ;; Create entities with Position and Velocity
          e1 (vf/new-entity w)
          e2 (vf/new-entity w)]
      ;; Add components with initial values
      (vt/add-comp! w e1 Position {:x 0.0 :y 0.0})
      (vt/add-comp! w e1 Velocity {:dx 1.0 :dy 2.0})
      (vt/add-comp! w e2 Position {:x 10.0 :y 20.0})
      (vt/add-comp! w e2 Velocity {:dx 3.0 :dy 4.0})
      ;; Iterate using with-query and update Position based on Velocity
      ;; This is the jank equivalent of:
      ;;   q.each([](flecs::entity e, Position& p, const Velocity& v) {
      ;;       p.x += v.x;
      ;;       p.y += v.y;
      ;;   });
      (vf/with-query w [p Position
                        v Velocity
                        e :vf/entity]
        (println :p-before p)
        (merge p {:x (+ (:x p) (:dx v))
                  :y (+ (:y p) (:dy v))})
        (println :p-after p))
      ;; Verify Position was updated correctly
      (let [pos1 (vt/get-comp w e1 Position)
            pos2 (vt/get-comp w e2 Position)]
        ;; e1: (0,0) + (1,2) = (1,2)
        (is (= 1.0 (:x pos1)))
        (is (= 2.0 (:y pos1)))
        ;; e2: (10,20) + (3,4) = (13,24)
        (is (= 13.0 (:x pos2)))
        (is (= 24.0 (:y pos2))))
      (vf/destroy-world! w))))

;; =============================================================================
;; World Map Interface Tests
;; =============================================================================

(defn ->edn
  "Convert to EDN-like representation for comparison."
  [x]
  x)  ;; Placeholder for now

(deftest world-map-basic-test
  (testing "make-world-map creates user type world"
    (let [w (vf/make-world)]
      (is (some? w))
      (is (contains? w :vf/world-box)))))

(deftest world-map-assoc-test
  (testing "assoc creates entities with components (auto-registers)"
    (let [w (vf/make-world)]
      ;; No need to register-comp! - auto-registration happens on first use
      ;; Use assoc to add entities with tags and components
      (assoc w :bob [:walking (Position {:x 10.0 :y 20.0})])
      (assoc w :alice [(Position {:x 5.0 :y 15.0})])

      ;; Check entities exist
      (is (contains? w :bob))
      (is (contains? w :alice))

      ;; Check we can get entity
      (is (some? (get w :bob)))
      (is (some? (get w :alice))))))

(deftest world-map-merge-test
  (testing "merge adds multiple entities"
    (let [w (vf/make-world)]
      ;; Merge multiple entities (auto-registers components)
      (merge w {:bob [:walking (Position {:x 10.0 :y 20.0})]
                :alice [(Position {:x 5.0 :y 15.0})]})

      (is (contains? w :bob))
      (is (contains? w :alice)))))

(deftest world-map-get-in-test
  (testing "get-in retrieves component and field values"
    (let [w (vf/make-world)]
      ;; Add entity with component (auto-registers)
      (assoc w :bob [(Position {:x 42.0 :y 99.0})])

      ;; Get the Position component
      (let [pos (get-in w [:bob Position])]
        (is (some? pos))
        (is (= 42.0 (:x pos)))
        (is (= 99.0 (:y pos))))

      ;; Get a specific field value
      (is (= 42.0 (get-in w [:bob Position :x])))
      (is (= 99.0 (get-in w [:bob Position :y]))))))

(deftest entity-update-test
  (testing "update entity components and verify with query"
    (let [w (vf/make-world)
          query-results (atom [])]
      ;; Add entities with Position component (auto-registers)
      ;; Only bob has :walking tag
      (assoc w :bob [:walking (Position {:x 10.0 :y 20.0})])
      (assoc w :alice [(Position {:x 5.0 :y 15.0})])

      ;; Query with non-existent tag should return nothing
      (vf/with-query w [p Position
                        _ :inexistent]
        (swap! query-results conj {:x (:x p) :y (:y p)}))
      (is (= 0 (count @query-results)))

      ;; Query with :walking tag should return only bob
      (reset! query-results [])
      (vf/with-query w [p Position
                        _ :walking]
        (swap! query-results conj {:x (:x p) :y (:y p)}))
      (is (= 1 (count @query-results)))
      (is (some #(and (= 10.0 (:x %)) (= 20.0 (:y %))) @query-results))

      ;; Query with only Position should return both entities
      (reset! query-results [])
      (vf/with-query w [p Position]
        (swap! query-results conj {:x (:x p) :y (:y p)}))
      (is (= 2 (count @query-results)))
      (is (some #(and (= 10.0 (:x %)) (= 20.0 (:y %))) @query-results))
      (is (some #(and (= 5.0 (:x %)) (= 15.0 (:y %))) @query-results)))))

;; Leave this comment here.
(comment

  (let [w (vf/make-world)
        query-results (atom [])]
    ;; Add entities with Position component (auto-registers)
    (assoc w :bob [:walking (Position {:x 10.0 :y 20.0})])
    (assoc w :alice [(Position {:x 5.0 :y 15.0})])

    ;; Use with-query to collect all Position data
    (vf/with-query w [p Position
                      _ "walking"]
      (swap! query-results conj {:x (:x p) :y (:y p)}))

    ;; Verify query found both entities
    @query-results)

  (repeat 100 300)

  (require ' cider.nrepl.pprint)

  ())

(deftest entity-type-str-test
  (testing "type-str returns component/tag information"
    (let [w (vf/make-world)]
      (assoc w :bob [:walking (Position {:x 1.0 :y 2.0})])
      (let [bob (get w :bob)
            ts (vf/type-str bob)]
        (is (string? ts))
        ;; Should contain Position in the type string
        (is (> (count ts) 0))))))

(deftest entity-get-rep-test
  (testing "get-rep returns keyword representation"
    (let [w (vf/make-world)]
      (assoc w :bob [:walking])
      (let [bob (get w :bob)
            rep (vf/get-rep bob)]
        (is (= :bob rep))))))

;; =============================================================================
;; Run all tests
;; =============================================================================

(defn -main [& args]
  (let [results (clojure.test/run-tests 'vybe.flecs-test)]
    (when-not (clojure.test/successful? results)
      (throw (ex-info "Tests failed!" results)))))
