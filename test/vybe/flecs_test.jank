(ns vybe.flecs-test
  (:require
   [clojure.test :refer [deftest testing is]]
   [vybe.flecs :as vf]
   [vybe.type :as vt]
   ["flecs.h" :as fl :scope ""]))

;; Define components for query tests
(vt/defcomp Position [[:x :float] [:y :float]])
(vt/defcomp Velocity [[:dx :float] [:dy :float]])

;; =============================================================================
;; Basic World Tests
;; =============================================================================

(deftest world-creation-test
  (testing "create and destroy world"
    (let [w (vf/make-world)]
      (is (some? w))
      (vf/destroy-world! w))))

(deftest world-mini-creation-test
  (testing "create and destroy mini world"
    (let [w (vf/make-world-mini)]
      (is (some? w))
      (vf/destroy-world! w))))

(deftest world-ptr-test
  (testing "world-ptr macro extracts native pointer"
    (let [w (vf/make-world)
          ;; world-ptr is a macro that returns native ecs_world_t*
          ;; We can't directly test the pointer value, but we can use it
          _ (fl/ecs_progress (vf/world-ptr w) (cpp/float. 0.0))]
      (vf/destroy-world! w)
      (is true))))

;; =============================================================================
;; Entity Tests
;; =============================================================================

(deftest new-entity-test
  (testing "create new entity"
    (let [w (vf/make-world)
          e (vf/new-entity w)]
      (is (> e 0))
      (vf/destroy-world! w))))

(deftest eid-test
  (testing "eid with integer returns same value"
    (let [w (vf/make-world)]
      (is (= 42 (vf/eid w 42)))
      (vf/destroy-world! w))))

;; =============================================================================
;; Progress Tests
;; =============================================================================

(deftest progress-test
  (testing "progress advances world"
    (let [w (vf/make-world)]
      ;; Should not throw
      (vf/progress w)
      (vf/progress w 0.016)
      (vf/destroy-world! w)
      (is true))))

;; =============================================================================
;; defn* Macro Tests
;; =============================================================================

(deftest defn*-generates-macro-test
  (testing "defn* with :tag generates working macro"
    ;; world-ptr is defined with defn* and should work as a macro
    (let [w (vf/make-world)]
      ;; This uses world-ptr which is defined with defn*
      ;; If it works, the entity creation succeeds
      (let [e (vf/new-entity w)]
        (is (> e 0)))
      (vf/destroy-world! w))))

;; =============================================================================
;; Query and Iteration Tests
;; =============================================================================

(deftest query-str-test
  (testing "query-str creates a query"
    (let [w (vf/make-world)
          ;; Create a tag
          tag (fl/ecs_new (vf/world-ptr w))
          ;; Create entities with the tag
          e1 (fl/ecs_new (vf/world-ptr w))
          e2 (fl/ecs_new (vf/world-ptr w))]
      ;; Add tag to entities
      (fl/ecs_add_id (vf/world-ptr w) e1 tag)
      (fl/ecs_add_id (vf/world-ptr w) e2 tag)
      ;; Query should work (we can't easily test the returned value,
      ;; but it shouldn't throw)
      (vf/destroy-world! w)
      (is true))))

(deftest with-query-test
  (testing "with-query iterates over entities with Position and Velocity"
    (let [w (vf/make-world)
          ;; Register components
          _ (vt/register-comp! w Position)
          _ (vt/register-comp! w Velocity)
          ;; Create entities with Position and Velocity
          e1 (vf/new-entity w)
          e2 (vf/new-entity w)]
      ;; Add components with initial values
      (vt/add-comp! w e1 Position {:x 0.0 :y 0.0})
      (vt/add-comp! w e1 Velocity {:dx 1.0 :dy 2.0})
      (vt/add-comp! w e2 Position {:x 10.0 :y 20.0})
      (vt/add-comp! w e2 Velocity {:dx 3.0 :dy 4.0})
      ;; Iterate using with-query and update Position based on Velocity
      ;; This is the jank equivalent of:
      ;;   q.each([](flecs::entity e, Position& p, const Velocity& v) {
      ;;       p.x += v.x;
      ;;       p.y += v.y;
      ;;   });
      (vf/with-query w [p Position
                        v Velocity
                        e :vf/entity]
        (println :p-before p)
        (vt/merge! p {:x (+ (:x p) (:dx v))
                      :y (+ (:y p) (:dy v))})
        (println :p-after p))
      ;; Verify Position was updated correctly
      (let [pos1 (vt/get-comp w e1 Position)
            pos2 (vt/get-comp w e2 Position)]
        ;; e1: (0,0) + (1,2) = (1,2)
        (is (= 1.0 (:x pos1)))
        (is (= 2.0 (:y pos1)))
        ;; e2: (10,20) + (3,4) = (13,24)
        (is (= 13.0 (:x pos2)))
        (is (= 24.0 (:y pos2))))
      (vf/destroy-world! w))))

;; =============================================================================
;; Run all tests
;; =============================================================================

(defn -main [& args]
  (let [results (clojure.test/run-tests 'vybe.flecs-test)]
    (when-not (clojure.test/successful? results)
      (throw (ex-info "Tests failed!" results)))))
