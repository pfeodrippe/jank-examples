// Drawing Mobile iOS - jank-powered drawing app
// Uses SDL3 + Metal via drawing_canvas.hpp singleton

// Define METAL_TEST_MODE to bypass jank and test Metal directly
#define METAL_TEST_MODE 1

#import <Foundation/Foundation.h>
#import <UIKit/UIKit.h>
#import <Photos/Photos.h>
#import <PhotosUI/PhotosUI.h>
#import <CoreText/CoreText.h>
#include <iostream>
#include <sstream>
#include <string>
#include <mutex>
#include <condition_variable>
#include <pthread.h>
#include <algorithm>  // For std::max, std::min

#include <SDL3/SDL.h>
#include "../src/vybe/app/drawing/native/metal_renderer.h"
#import "brush_importer.h"

// jank runtime headers
// iOS defines 'nil' as a macro which conflicts with jank's object_type::nil
#pragma push_macro("nil")
#undef nil
#include <gc.h>
#include <jank/runtime/context.hpp>
#include <jank/runtime/core.hpp>
#include <jank/runtime/core/make_box.hpp>
#include <jank/runtime/behavior/callable.hpp>
#include <jank/runtime/module/loader.hpp>
#include <jank/error.hpp>

// iOS JIT support
#if defined(JANK_IOS_JIT)
#include <jank/ios/eval_server.hpp>
#include <jank/compile_server/remote_compile.hpp>
extern "C" void jank_debug_print_sizeof();
#endif

#pragma pop_macro("nil")

// =============================================================================
// jank Integration (following SdfViewerMobile pattern)
// =============================================================================

// External AOT init function generated by ios-bundle
extern "C" void jank_aot_init();

static bool jank_initialized = false;

#if defined(JANK_IOS_JIT)
// Hybrid JIT mode: AOT core libs + JIT user code
static bool load_jank_modules_jit() {
    std::cout << "[drawing_mobile] Loading AOT core modules..." << std::endl;

    // jank_aot_init() loads:
    // 1. clojure.core-native, clojure.core, other core libs
    // 2. nREPL native module (jank.nrepl-server.asio) - inserted by ios-bundle when JANK_IOS_JIT
    // 3. application modules
    jank_aot_init();

    std::cout << "[drawing_mobile] All modules loaded! Ready for REPL." << std::endl;
    return true;
}
#endif

// Forward declaration for large-stack wrapper
static bool init_jank_runtime_impl();

// Large stack wrapper for running jank on iOS
// iOS main thread has only ~1MB stack, but jank's recursive codegen needs more.
struct jank_init_result {
    std::mutex mtx;
    std::condition_variable cv;
    bool done = false;
    bool success = false;
};

static void* jank_init_thread_func(void* arg) {
    auto* result = static_cast<jank_init_result*>(arg);

    bool success = init_jank_runtime_impl();

    {
        std::lock_guard<std::mutex> lock(result->mtx);
        result->success = success;
        result->done = true;
    }
    result->cv.notify_one();
    return nullptr;
}

static bool init_jank_runtime_on_large_stack() {
    constexpr size_t STACK_SIZE = 8 * 1024 * 1024; // 8MB stack

    // Initialize GC on main thread FIRST - before creating worker thread
    std::cout << "[drawing_mobile] Initializing Boehm GC on main thread..." << std::endl;
    GC_init();

    // CRITICAL: Disable GC during worker thread execution to avoid
    // "Collecting from unknown thread" errors.
    std::cout << "[drawing_mobile] Disabling GC during initialization..." << std::endl;
    GC_disable();

    pthread_attr_t attr;
    pthread_attr_init(&attr);
    pthread_attr_setstacksize(&attr, STACK_SIZE);

    jank_init_result result;
    pthread_t thread;

    std::cout << "[drawing_mobile] Starting initialization on thread with " << (STACK_SIZE / 1024 / 1024) << "MB stack..." << std::endl;

    int err = pthread_create(&thread, &attr, jank_init_thread_func, &result);
    pthread_attr_destroy(&attr);

    if (err != 0) {
        std::cerr << "[drawing_mobile] Failed to create large-stack thread: " << err << std::endl;
        // Fall back to running on current thread (re-enable GC first)
        GC_enable();
        return init_jank_runtime_impl();
    }

    // Wait for the thread to complete
    {
        std::unique_lock<std::mutex> lock(result.mtx);
        result.cv.wait(lock, [&result] { return result.done; });
    }

    pthread_join(thread, nullptr);

    // Re-enable GC now that initialization is complete
    std::cout << "[drawing_mobile] Re-enabling GC after initialization..." << std::endl;
    GC_enable();

    return result.success;
}

// Initialize jank runtime for iOS (actual implementation)
// NOTE: GC_init() is called by init_jank_runtime_on_large_stack() before this
static bool init_jank_runtime_impl() {
    try {
        std::cout << "[drawing_mobile] Creating runtime context..." << std::endl;
        jank::runtime::__rt_ctx = new (GC_malloc(sizeof(jank::runtime::context)))
            jank::runtime::context{};

#if defined(JANK_IOS_JIT)
        // Print sizeof for key types to help diagnose ABI mismatches
        jank_debug_print_sizeof();

        // Configure and connect to remote compile server on macOS
#if TARGET_OS_SIMULATOR
        std::string const remote_host = "127.0.0.1";
        uint16_t const remote_port = 5572;  // DrawingMobile simulator uses port 5572
#else
        // Device needs Mac's actual IP - update for your network!
        std::string const remote_host = "192.168.2.25";
        uint16_t const remote_port = 5573;  // DrawingMobile device uses port 5573
#endif

        std::cout << "[drawing_mobile] Configuring remote compile server at " << remote_host << ":" << remote_port << "..." << std::endl;
        jank::compile_server::configure_remote_compile(remote_host, remote_port);

        if (jank::compile_server::connect_remote_compile()) {
            std::cout << "[drawing_mobile] Connected to remote compile server!" << std::endl;
        } else {
            std::cout << "[drawing_mobile] Warning: Could not connect to remote compile server." << std::endl;
        }

        // JIT mode: Load modules from bundled source files
        std::cout << "[drawing_mobile] JIT mode - loading modules from source..." << std::endl;
        if (!load_jank_modules_jit()) {
            std::cerr << "[drawing_mobile] JIT module loading failed" << std::endl;
            return false;
        }
#else
        // AOT mode: Load all modules via auto-generated init function
        jank_aot_init();
#endif

        jank_initialized = true;
        std::cout << "[drawing_mobile] Runtime initialized successfully!" << std::endl;
        return true;
    } catch (jtl::ref<jank::error::base> const& e) {
        std::cerr << "[drawing_mobile] Error initializing runtime: " << e->message << std::endl;
        if (e->cause) {
            std::cerr << "[drawing_mobile]   caused by: " << e->cause->message << std::endl;
        }
        return false;
    } catch (const std::exception& e) {
        std::cerr << "[drawing_mobile] Error initializing runtime (std): " << e.what() << std::endl;
        return false;
    }
}

// Call the jank-exported -main function
static void call_jank_main_impl() {
    try {
        // Set up thread bindings (required for dynamic vars like *ns*)
        jank::runtime::context::binding_scope bindings;

        // Find clojure.core/require
        auto require_var = jank::runtime::__rt_ctx->find_var(
            jank::runtime::make_box<jank::runtime::obj::symbol>("clojure.core/require")
        );
        if (require_var.is_nil()) {
            std::cerr << "[drawing_mobile] Could not find clojure.core/require" << std::endl;
            return;
        }

        // Call (require 'vybe.app.drawing)
        std::cout << "[drawing_mobile] Loading vybe.app.drawing..." << std::endl;
        jank::runtime::dynamic_call(
            require_var->deref(),
            jank::runtime::make_box<jank::runtime::obj::symbol>("vybe.app.drawing")
        );
        std::cout << "[drawing_mobile] vybe.app.drawing loaded!" << std::endl;

        // Find and call -main
        auto main_var = jank::runtime::__rt_ctx->intern_var("vybe.app.drawing", "-main");
        if (!main_var.is_ok()) {
            std::cerr << "[drawing_mobile] Could not find vybe.app.drawing/-main" << std::endl;
            return;
        }

        std::cout << "[drawing_mobile] Calling vybe.app.drawing/-main with nREPL port 5581..." << std::endl;
        jank::runtime::dynamic_call(
            main_var.expect_ok()->deref(),
            jank::runtime::make_box<jank::runtime::obj::integer>(5581)
        );

    } catch (jtl::ref<jank::error::base> const& e) {
        std::cerr << "\n";
        std::cerr << "=== jank Runtime Error ===" << std::endl;
        std::cerr << e->message << std::endl;
        if (e->source.file != jank::read::no_source_path) {
            std::cerr << "at " << e->source.to_string() << std::endl;
        }
        if (e->cause) {
            std::cerr << "caused by: " << e->cause->message << std::endl;
        }
    } catch (std::exception& e) {
        std::cerr << "[drawing_mobile] Failed to run app: " << e.what() << std::endl;
    }
}

// =============================================================================
// Metal Test Mode - Pure C++ SDL + Metal rendering (no jank)
// =============================================================================

#if METAL_TEST_MODE

// =============================================================================
// Texture Picker Helper
// =============================================================================

typedef enum {
    TextureTypeShape = 0,
    TextureTypeGrain = 1
} TextureType;

// Callback function pointer for when texture is loaded
typedef void (*TextureLoadedCallback)(int32_t textureId, TextureType type);

// Global pending request state
static TextureType g_pendingTextureType = TextureTypeShape;
static SDL_Window* g_sdlWindow = nullptr;

// Global texture button state (set in main, updated by callback)
static bool g_shapeTextureHasTexture = false;
static int32_t g_shapeTextureId = -1;
static bool g_grainTextureHasTexture = false;
static int32_t g_grainTextureId = -1;

// Global brush picker state
static NSMutableArray<NSNumber*>* g_brushIds = nil;
static int32_t g_selectedBrushId = -1;
static int g_selectedBrushIndex = 0;
static bool g_brushPickerVisible = false;
static bool g_brushesLoaded = false;

// Brush picker scroll state
static float g_brushPickerScrollOffset = 0.0f;  // Current scroll offset (pixels)
static bool g_brushPickerIsDragging = false;    // Currently dragging to scroll
static float g_brushPickerDragStartY = 0.0f;    // Y position where drag started
static float g_brushPickerDragStartOffset = 0.0f; // Scroll offset when drag started
static SDL_FingerID g_brushPickerDragFingerId = 0; // Finger used for scrolling

// Eraser mode state
static bool g_eraserMode = false;  // When true, paint with background color

// Objective-C delegate for PHPicker
@interface TexturePickerDelegate : NSObject <PHPickerViewControllerDelegate>
@property (nonatomic, assign) TextureType textureType;
@end

@implementation TexturePickerDelegate

- (void)picker:(PHPickerViewController *)picker didFinishPicking:(NSArray<PHPickerResult *> *)results {
    [picker dismissViewControllerAnimated:YES completion:nil];

    if (results.count == 0) {
        std::cout << "[TexturePicker] User cancelled" << std::endl;
        return;
    }

    PHPickerResult* result = results[0];

    // Check if the result can provide an image
    if (![result.itemProvider canLoadObjectOfClass:[UIImage class]]) {
        std::cout << "[TexturePicker] Cannot load image from selection" << std::endl;
        return;
    }

    TextureType capturedType = self.textureType;

    [result.itemProvider loadObjectOfClass:[UIImage class] completionHandler:^(id<NSItemProviderReading> _Nullable object, NSError * _Nullable error) {
        if (error) {
            std::cout << "[TexturePicker] Error loading image: " << [[error localizedDescription] UTF8String] << std::endl;
            return;
        }

        UIImage* image = (UIImage*)object;
        if (!image) {
            std::cout << "[TexturePicker] Image is nil" << std::endl;
            return;
        }

        std::cout << "[TexturePicker] Got image: " << image.size.width << "x" << image.size.height << std::endl;

        // Process image on main thread
        dispatch_async(dispatch_get_main_queue(), ^{
            // Convert to grayscale and load as texture
            CGImageRef cgImage = image.CGImage;
            if (!cgImage) {
                std::cout << "[TexturePicker] No CGImage" << std::endl;
                return;
            }

            // Determine target size (power of 2, max 1024 for efficiency)
            size_t srcWidth = CGImageGetWidth(cgImage);
            size_t srcHeight = CGImageGetHeight(cgImage);
            size_t maxDim = MAX(srcWidth, srcHeight);
            size_t targetSize = 512;
            if (maxDim > 512) targetSize = 1024;
            if (maxDim > 1024) targetSize = 2048;

            std::cout << "[TexturePicker] Converting to " << targetSize << "x" << targetSize << " grayscale" << std::endl;

            // Create grayscale context
            CGColorSpaceRef graySpace = CGColorSpaceCreateDeviceGray();
            uint8_t* pixels = (uint8_t*)calloc(targetSize * targetSize, 1);

            CGContextRef ctx = CGBitmapContextCreate(
                pixels,
                targetSize, targetSize,
                8,  // bits per component
                targetSize,  // bytes per row
                graySpace,
                kCGImageAlphaNone
            );

            // Calculate aspect-fit rectangle
            float srcAspect = (float)srcWidth / (float)srcHeight;
            float dstAspect = 1.0f;  // Square
            CGRect drawRect;

            if (srcAspect > dstAspect) {
                // Source is wider - fit to width
                float h = targetSize / srcAspect;
                drawRect = CGRectMake(0, (targetSize - h) / 2.0f, targetSize, h);
            } else {
                // Source is taller - fit to height
                float w = targetSize * srcAspect;
                drawRect = CGRectMake((targetSize - w) / 2.0f, 0, w, targetSize);
            }

            // Fill with black (transparent in brush terms)
            CGContextSetFillColorWithColor(ctx, [UIColor blackColor].CGColor);
            CGContextFillRect(ctx, CGRectMake(0, 0, targetSize, targetSize));

            // Draw image
            CGContextDrawImage(ctx, drawRect, cgImage);

            // Load into Metal texture
            int32_t textureId = metal_stamp_load_texture_data(pixels, (int)targetSize, (int)targetSize);

            // Cleanup
            CGContextRelease(ctx);
            CGColorSpaceRelease(graySpace);
            free(pixels);

            if (textureId > 0) {
                std::cout << "[TexturePicker] Loaded texture ID: " << textureId << std::endl;

                // Apply texture based on type
                if (capturedType == TextureTypeShape) {
                    metal_stamp_set_brush_shape_texture(textureId);
                    std::cout << "[TexturePicker] Set as SHAPE texture" << std::endl;
                } else {
                    metal_stamp_set_brush_grain_texture(textureId);
                    std::cout << "[TexturePicker] Set as GRAIN texture" << std::endl;
                }

                // Update global state for UI
                if (capturedType == TextureTypeShape) {
                    g_shapeTextureHasTexture = true;
                    g_shapeTextureId = textureId;
                    std::cout << "[TexturePicker] Updated global shape texture state" << std::endl;
                } else {
                    g_grainTextureHasTexture = true;
                    g_grainTextureId = textureId;
                    std::cout << "[TexturePicker] Updated global grain texture state" << std::endl;
                }
            } else {
                std::cout << "[TexturePicker] Failed to load texture" << std::endl;
            }
        });
    }];
}

@end

// Global delegate instance (must persist while picker is shown)
static TexturePickerDelegate* g_pickerDelegate = nil;

// Function to show texture picker
static void showTexturePicker(SDL_Window* window, TextureType type) {
    if (!window) {
        std::cout << "[TexturePicker] No window provided" << std::endl;
        return;
    }

    // Get UIWindow from SDL
    SDL_PropertiesID props = SDL_GetWindowProperties(window);
    UIWindow* uiWindow = (__bridge UIWindow*)SDL_GetPointerProperty(props, SDL_PROP_WINDOW_UIKIT_WINDOW_POINTER, NULL);

    if (!uiWindow) {
        std::cout << "[TexturePicker] Cannot get UIWindow from SDL" << std::endl;
        return;
    }

    UIViewController* rootVC = uiWindow.rootViewController;
    if (!rootVC) {
        std::cout << "[TexturePicker] No root view controller" << std::endl;
        return;
    }

    std::cout << "[TexturePicker] Opening picker for " << (type == TextureTypeShape ? "SHAPE" : "GRAIN") << std::endl;

    // Create delegate
    if (!g_pickerDelegate) {
        g_pickerDelegate = [[TexturePickerDelegate alloc] init];
    }
    g_pickerDelegate.textureType = type;

    // Configure picker
    PHPickerConfiguration* config = [[PHPickerConfiguration alloc] init];
    config.selectionLimit = 1;
    config.filter = [PHPickerFilter imagesFilter];

    PHPickerViewController* picker = [[PHPickerViewController alloc] initWithConfiguration:config];
    picker.delegate = g_pickerDelegate;

    // Present picker with delay to avoid SDL touch event interference
    dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(0.1 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^{
        [rootVC presentViewController:picker animated:YES completion:^{
            std::cout << "[TexturePicker] Picker presented" << std::endl;
        }];
    });
}

// =============================================================================
// Brush Picker Functions
// =============================================================================

// Load brushes from the bundled brushset files
static void loadBrushesFromBundledFile() {
    if (g_brushesLoaded) return;

    NSLog(@"[BrushPicker] Loading bundled brushsets...");

    g_brushIds = [[NSMutableArray alloc] init];

    // Brushsets to load from app bundle (in order)
    NSArray<NSString*>* bundleNames = @[@"brushes", @"BetterThanBasics"];

    for (NSString* bundleName in bundleNames) {
        NSArray<NSNumber*>* brushIds = [BrushImporter loadBundledBrushSet:bundleName];
        if (brushIds.count > 0) {
            [g_brushIds addObjectsFromArray:brushIds];
            NSLog(@"[BrushPicker] Loaded %lu brushes from bundle: %@",
                  (unsigned long)brushIds.count, bundleName);
        }
    }

    if (g_brushIds.count > 0) {
        g_brushesLoaded = true;
        g_selectedBrushIndex = 0;
        g_selectedBrushId = [g_brushIds[0] intValue];
        [BrushImporter applyBrush:g_selectedBrushId];
        NSLog(@"[BrushPicker] Total: %lu brushes loaded", (unsigned long)g_brushIds.count);
    } else {
        NSLog(@"[BrushPicker] No brushes loaded");
    }
}

// Select next brush in the list
static void selectNextBrush() {
    if (!g_brushIds || g_brushIds.count == 0) return;

    g_selectedBrushIndex = (g_selectedBrushIndex + 1) % (int)g_brushIds.count;
    g_selectedBrushId = [g_brushIds[g_selectedBrushIndex] intValue];
    [BrushImporter applyBrush:g_selectedBrushId];

    ImportedBrush* brush = [BrushImporter getBrushById:g_selectedBrushId];
    if (brush) {
        NSLog(@"[BrushPicker] Selected brush %d: %s", g_selectedBrushIndex, brush->name);
    }
}

// Select previous brush in the list
static void selectPrevBrush() {
    if (!g_brushIds || g_brushIds.count == 0) return;

    g_selectedBrushIndex = (g_selectedBrushIndex - 1 + (int)g_brushIds.count) % (int)g_brushIds.count;
    g_selectedBrushId = [g_brushIds[g_selectedBrushIndex] intValue];
    [BrushImporter applyBrush:g_selectedBrushId];

    ImportedBrush* brush = [BrushImporter getBrushById:g_selectedBrushId];
    if (brush) {
        NSLog(@"[BrushPicker] Selected brush %d: %s", g_selectedBrushIndex, brush->name);
    }
}

// Get currently selected brush name
static const char* getSelectedBrushName() {
    if (g_selectedBrushId < 0) return "No Brush";

    ImportedBrush* brush = [BrushImporter getBrushById:g_selectedBrushId];
    if (brush) return brush->name;
    return "Unknown";
}

// =============================================================================
// Brush Picker Button Configuration
// =============================================================================

static const float BRUSH_BUTTON_WIDTH = 200.0f;
static const float BRUSH_BUTTON_HEIGHT = 60.0f;

struct BrushButtonConfig {
    float x, y;
    float width, height;
};

static bool isPointInBrushButton(const BrushButtonConfig& btn, float px, float py) {
    return px >= btn.x && px <= btn.x + btn.width &&
           py >= btn.y && py <= btn.y + btn.height;
}

static void drawBrushButton(const BrushButtonConfig& btn) {
    // Outer glow/border - orange/amber to stand out
    metal_stamp_queue_ui_rect(btn.x - 4, btn.y - 4, btn.width + 8, btn.height + 8,
                              0.95f, 0.6f, 0.2f, 0.9f, 14.0f);

    // Background - dark gray
    metal_stamp_queue_ui_rect(btn.x, btn.y, btn.width, btn.height,
                              0.15f, 0.15f, 0.18f, 0.95f, 10.0f);

    // Simple pencil icon using rectangles
    float iconX = btn.x + 15.0f;
    float iconY = btn.y + 10.0f;
    float iconW = 12.0f;
    float iconH = 40.0f;

    // Pencil body (yellow)
    metal_stamp_queue_ui_rect(iconX, iconY, iconW, iconH,
                              0.95f, 0.85f, 0.3f, 1.0f, 3.0f);

    // Pencil tip (pink/eraser top)
    metal_stamp_queue_ui_rect(iconX, iconY - 8.0f, iconW, 8.0f,
                              0.9f, 0.5f, 0.6f, 1.0f, 2.0f);

    // Pencil point (dark)
    metal_stamp_queue_ui_rect(iconX + 2.0f, iconY + iconH, iconW - 4.0f, 8.0f,
                              0.3f, 0.25f, 0.2f, 1.0f, 1.0f);

    // "Brush" text indicator area - show if brushes loaded
    if (g_brushesLoaded) {
        // Green indicator dot to show brushes are loaded
        metal_stamp_queue_ui_rect(btn.x + btn.width - 20.0f, btn.y + 5.0f, 12.0f, 12.0f,
                                  0.3f, 0.9f, 0.4f, 1.0f, 6.0f);
    }
}

// =============================================================================
// Eraser Button Configuration
// =============================================================================

static const float ERASER_BUTTON_SIZE = 60.0f;

struct EraserButtonConfig {
    float x, y;
    float size;
};

static bool isPointInEraserButton(const EraserButtonConfig& btn, float px, float py) {
    return px >= btn.x && px <= btn.x + btn.size &&
           py >= btn.y && py <= btn.y + btn.size;
}

static void drawEraserButton(const EraserButtonConfig& btn, bool isActive) {
    // Background - changes color when active
    if (isActive) {
        // Active: pink/red background
        metal_stamp_queue_ui_rect(btn.x - 3, btn.y - 3, btn.size + 6, btn.size + 6,
                                  0.9f, 0.3f, 0.4f, 0.95f, 12.0f);
        metal_stamp_queue_ui_rect(btn.x, btn.y, btn.size, btn.size,
                                  0.8f, 0.2f, 0.3f, 0.95f, 10.0f);
    } else {
        // Inactive: dark gray
        metal_stamp_queue_ui_rect(btn.x - 3, btn.y - 3, btn.size + 6, btn.size + 6,
                                  0.4f, 0.4f, 0.45f, 0.8f, 12.0f);
        metal_stamp_queue_ui_rect(btn.x, btn.y, btn.size, btn.size,
                                  0.2f, 0.2f, 0.25f, 0.95f, 10.0f);
    }

    // Eraser icon - simple rectangle shape
    float iconX = btn.x + btn.size * 0.2f;
    float iconY = btn.y + btn.size * 0.15f;
    float iconW = btn.size * 0.6f;
    float iconH = btn.size * 0.7f;

    // Eraser body (pink top half)
    metal_stamp_queue_ui_rect(iconX, iconY, iconW, iconH * 0.4f,
                              0.95f, 0.6f, 0.7f, 1.0f, 4.0f);

    // Eraser bottom (darker band)
    metal_stamp_queue_ui_rect(iconX, iconY + iconH * 0.4f, iconW, iconH * 0.2f,
                              0.5f, 0.5f, 0.55f, 1.0f, 0.0f);

    // Eraser holder (blue/gray)
    metal_stamp_queue_ui_rect(iconX, iconY + iconH * 0.6f, iconW, iconH * 0.4f,
                              0.3f, 0.4f, 0.6f, 1.0f, 2.0f);
}

// =============================================================================
// Brush Picker Panel Configuration (constants needed by text rendering)
// =============================================================================

static const float BRUSH_PICKER_ITEM_SIZE = 180.0f;
static const float BRUSH_PICKER_ITEM_GAP = 12.0f;
static const float BRUSH_PICKER_PADDING = 20.0f;
static const int BRUSH_PICKER_COLS = 4;

// =============================================================================
// Text Rendering for Brush Names
// =============================================================================

// Cache for rendered text textures: key = brushId, value = textureId
static std::map<int32_t, int32_t> g_brushNameTextures;
static std::map<int32_t, std::pair<int32_t, int32_t>> g_brushNameSizes;  // width, height

// Render text to a Metal texture and return the texture ID
static int32_t renderTextToTexture(const char* text, float fontSize, int maxWidth) {
    if (!text || strlen(text) == 0) return -1;

    NSString* nsText = [NSString stringWithUTF8String:text];

    // Create attributed string with white text
    UIFont* font = [UIFont systemFontOfSize:fontSize weight:UIFontWeightMedium];
    NSDictionary* attributes = @{
        NSFontAttributeName: font,
        NSForegroundColorAttributeName: [UIColor whiteColor]
    };

    // Calculate text size
    CGSize textSize = [nsText boundingRectWithSize:CGSizeMake(maxWidth, CGFLOAT_MAX)
                                           options:NSStringDrawingUsesLineFragmentOrigin
                                        attributes:attributes
                                           context:nil].size;

    int width = (int)ceilf(textSize.width);
    int height = (int)ceilf(textSize.height);

    if (width <= 0 || height <= 0) return -1;

    // Create bitmap context for rendering
    NSUInteger bytesPerPixel = 4;
    NSUInteger bytesPerRow = width * bytesPerPixel;
    uint8_t* rawData = (uint8_t*)calloc(height * bytesPerRow, sizeof(uint8_t));

    CGColorSpaceRef colorSpace = CGColorSpaceCreateDeviceRGB();
    CGContextRef context = CGBitmapContextCreate(rawData, width, height,
                                                  8, bytesPerRow, colorSpace,
                                                  kCGImageAlphaPremultipliedLast);
    CGColorSpaceRelease(colorSpace);

    if (!context) {
        free(rawData);
        return -1;
    }

    // Flip context for UIKit coordinate system
    CGContextTranslateCTM(context, 0, height);
    CGContextScaleCTM(context, 1.0, -1.0);

    // Draw text using UIKit
    UIGraphicsPushContext(context);
    [nsText drawInRect:CGRectMake(0, 0, width, height) withAttributes:attributes];
    UIGraphicsPopContext();

    CGContextRelease(context);

    // Load into Metal
    int32_t textureId = metal_stamp_load_rgba_texture_data(rawData, width, height);

    free(rawData);

    // Store the size
    if (textureId > 0) {
        // Size will be stored by caller using brushId
    }

    return textureId;
}

// Get or create text texture for a brush name
static int32_t getBrushNameTexture(int32_t brushId, const char* name, int* outWidth, int* outHeight) {
    // Check cache
    auto it = g_brushNameTextures.find(brushId);
    if (it != g_brushNameTextures.end()) {
        auto sizeIt = g_brushNameSizes.find(brushId);
        if (sizeIt != g_brushNameSizes.end()) {
            *outWidth = sizeIt->second.first;
            *outHeight = sizeIt->second.second;
        }
        return it->second;
    }

    // Render new texture
    float fontSize = 14.0f;
    int maxWidth = (int)BRUSH_PICKER_ITEM_SIZE - 10;

    NSString* nsText = [NSString stringWithUTF8String:name];
    UIFont* font = [UIFont systemFontOfSize:fontSize weight:UIFontWeightMedium];
    NSDictionary* attributes = @{
        NSFontAttributeName: font,
        NSForegroundColorAttributeName: [UIColor whiteColor]
    };

    CGSize textSize = [nsText boundingRectWithSize:CGSizeMake(maxWidth, CGFLOAT_MAX)
                                           options:NSStringDrawingUsesLineFragmentOrigin
                                        attributes:attributes
                                           context:nil].size;

    int width = (int)ceilf(textSize.width);
    int height = (int)ceilf(textSize.height);

    int32_t textureId = renderTextToTexture(name, fontSize, maxWidth);

    if (textureId > 0) {
        g_brushNameTextures[brushId] = textureId;
        g_brushNameSizes[brushId] = {width, height};
        *outWidth = width;
        *outHeight = height;
    }

    return textureId;
}

// =============================================================================
// Brush Picker Panel Structs and Functions
// =============================================================================

struct BrushPickerConfig {
    float x, y;          // Position (top-left of panel)
    float width, height; // Panel dimensions
    bool isOpen;
    float scrollOffset;  // Vertical scroll offset in pixels (positive = scrolled down)
};

static bool isPointInBrushPicker(const BrushPickerConfig& picker, float px, float py) {
    if (!picker.isOpen) return false;
    return px >= picker.x && px <= picker.x + picker.width &&
           py >= picker.y && py <= picker.y + picker.height;
}

// Returns brush index at point, or -1 if none
// Uses global g_brushPickerScrollOffset for scroll position
static int getBrushAtPoint(const BrushPickerConfig& picker, float px, float py) {
    if (!picker.isOpen || !g_brushIds || [g_brushIds count] == 0) return -1;

    // Check if point is within the brush grid area
    float gridX = picker.x + BRUSH_PICKER_PADDING;
    float gridY = picker.y + BRUSH_PICKER_PADDING;

    float relX = px - gridX;
    // Add scroll offset to get the "virtual" position in the full content
    float relY = py - gridY + g_brushPickerScrollOffset;

    float cellSize = BRUSH_PICKER_ITEM_SIZE + BRUSH_PICKER_ITEM_GAP;  // 192
    int col = (int)(relX / cellSize);
    int row = (int)(relY / cellSize);

    // Debug: show exact position within cell
    float cellRelX = relX - col * cellSize;
    float cellRelY = relY - row * cellSize;
    NSLog(@"[BrushPicker] HIT TEST: rel(%.1f,%.1f) scroll=%.1f -> row=%d col=%d, cellRel(%.1f,%.1f)",
          relX, relY - g_brushPickerScrollOffset, g_brushPickerScrollOffset, row, col, cellRelX, cellRelY);

    if (relX < 0 || relY < 0) return -1;
    if (col >= BRUSH_PICKER_COLS) return -1;

    int brushIndex = row * BRUSH_PICKER_COLS + col;
    if (brushIndex >= (int)[g_brushIds count]) return -1;

    // Verify point is actually within the item bounds (not in gap)
    // Item positions are in virtual (scrolled) coordinates
    float virtualItemX = col * cellSize;
    float virtualItemY = row * cellSize;

    float localRelX = relX - virtualItemX;
    float localRelY = relY - virtualItemY;

    bool inBounds = (localRelX >= 0 && localRelX <= BRUSH_PICKER_ITEM_SIZE &&
                     localRelY >= 0 && localRelY <= BRUSH_PICKER_ITEM_SIZE);

    NSLog(@"[BrushPicker] BOUNDS CHECK: localRel(%.1f,%.1f) inBounds=%d -> brushIdx=%d",
          localRelX, localRelY, inBounds, inBounds ? brushIndex : -1);

    if (inBounds) {
        return brushIndex;
    }

    return -1;
}

static void drawBrushPicker(const BrushPickerConfig& picker, int windowHeight) {
    if (!picker.isOpen) return;

    // Semi-transparent background
    metal_stamp_queue_ui_rect(picker.x, picker.y, picker.width, picker.height,
                              0.15f, 0.15f, 0.2f, 0.95f, 15.0f);

    // Border
    metal_stamp_queue_ui_rect(picker.x - 3, picker.y - 3, picker.width + 6, picker.height + 6,
                              0.3f, 0.3f, 0.4f, 0.8f, 18.0f);

    if (!g_brushIds || [g_brushIds count] == 0) return;

    // Draw brush items in a grid with scroll support
    float gridX = picker.x + BRUSH_PICKER_PADDING;
    float gridY = picker.y + BRUSH_PICKER_PADDING;
    float cellSize = BRUSH_PICKER_ITEM_SIZE + BRUSH_PICKER_ITEM_GAP;

    // Calculate content dimensions
    int brushCount = (int)[g_brushIds count];
    int rowCount = (brushCount + BRUSH_PICKER_COLS - 1) / BRUSH_PICKER_COLS;
    float contentHeight = rowCount * cellSize - BRUSH_PICKER_ITEM_GAP;
    float visibleHeight = picker.height - BRUSH_PICKER_PADDING * 2;

    // Clamp scroll offset to valid range
    float maxScroll = std::max(0.0f, contentHeight - visibleHeight);
    g_brushPickerScrollOffset = std::max(0.0f, std::min(g_brushPickerScrollOffset, maxScroll));

    for (int i = 0; i < brushCount; i++) {
        int col = i % BRUSH_PICKER_COLS;
        int row = i / BRUSH_PICKER_COLS;

        float itemX = gridX + col * cellSize;
        // Apply scroll offset (negative offset moves items up)
        float itemY = gridY + row * cellSize - g_brushPickerScrollOffset;

        // Check if item is within visible area (accounting for scroll)
        float visibleTop = picker.y + BRUSH_PICKER_PADDING;
        float visibleBottom = picker.y + picker.height - BRUSH_PICKER_PADDING;

        // Skip items completely above visible area
        if (itemY + BRUSH_PICKER_ITEM_SIZE < visibleTop) {
            continue;
        }
        // Skip items completely below visible area
        if (itemY > visibleBottom) {
            continue;
        }

        int32_t brushId = [[g_brushIds objectAtIndex:i] intValue];
        bool isSelected = (brushId == g_selectedBrushId);

        // Draw selection highlight
        if (isSelected) {
            metal_stamp_queue_ui_rect(itemX - 4, itemY - 4,
                                      BRUSH_PICKER_ITEM_SIZE + 8, BRUSH_PICKER_ITEM_SIZE + 8,
                                      0.3f, 0.7f, 0.9f, 0.9f, 8.0f);
        }

        // Draw brush item background
        metal_stamp_queue_ui_rect(itemX, itemY, BRUSH_PICKER_ITEM_SIZE, BRUSH_PICKER_ITEM_SIZE,
                                  0.25f, 0.25f, 0.3f, 0.9f, 6.0f);

        // Draw brush thumbnail preview (stroke preview)
        ImportedBrush* brush = [BrushImporter getBrushById:brushId];

        // FIRST: Check if brush is unsupported (no shape texture = uses bundled Procreate resources)
        if (brush && brush->shapeTextureId < 0) {
            // UNSUPPORTED BRUSH: Draw a red X to indicate brush cannot be used
            float centerX = itemX + BRUSH_PICKER_ITEM_SIZE / 2;
            float centerY = itemY + BRUSH_PICKER_ITEM_SIZE / 2;
            float xSize = 30.0f;
            float xThickness = 6.0f;

            // Draw red background circle
            metal_stamp_queue_ui_rect(centerX - xSize - 5, centerY - xSize - 5,
                                      (xSize + 5) * 2, (xSize + 5) * 2,
                                      0.3f, 0.1f, 0.1f, 0.8f, xSize + 5);

            // Draw X using two thick lines
            metal_stamp_queue_ui_rect(centerX - xSize, centerY - xThickness/2,
                                      xSize * 2, xThickness,
                                      0.9f, 0.2f, 0.2f, 1.0f, 2.0f);
            metal_stamp_queue_ui_rect(centerX - xThickness/2, centerY - xSize,
                                      xThickness, xSize * 2,
                                      0.9f, 0.2f, 0.2f, 1.0f, 2.0f);
        } else if (brush && brush->thumbnailTextureId > 0) {
            // Draw the actual brush thumbnail (Procreate QuickLook preview)
            float thumbPadding = 5.0f;
            float thumbX = itemX + thumbPadding;
            float thumbY = itemY + thumbPadding;
            float thumbW = BRUSH_PICKER_ITEM_SIZE - thumbPadding * 2;
            float thumbH = BRUSH_PICKER_ITEM_SIZE - thumbPadding * 2;

            // Calculate aspect ratio to fit 327x100 thumbnail
            float thumbAspect = (float)brush->thumbnailWidth / (float)brush->thumbnailHeight;
            float boxAspect = thumbW / thumbH;

            float drawW, drawH, drawX, drawY;
            if (thumbAspect > boxAspect) {
                drawW = thumbW;
                drawH = thumbW / thumbAspect;
                drawX = thumbX;
                drawY = thumbY + (thumbH - drawH) / 2;
            } else {
                drawH = thumbH;
                drawW = thumbH * thumbAspect;
                drawX = thumbX + (thumbW - drawW) / 2;
                drawY = thumbY;
            }

            // Draw the thumbnail texture with white tint
            metal_stamp_queue_ui_textured_rect(drawX, drawY, drawW, drawH,
                                               brush->thumbnailTextureId,
                                               1.0f, 1.0f, 1.0f, 1.0f);
        } else if (brush && brush->shapeTextureId >= 0) {
            // Fallback: Draw shape texture indicator
            metal_stamp_queue_ui_rect(itemX + 10, itemY + 10,
                                      BRUSH_PICKER_ITEM_SIZE - 20, BRUSH_PICKER_ITEM_SIZE - 20,
                                      0.4f, 0.4f, 0.5f, 0.8f, 4.0f);
        } else {
            // No brush data - draw placeholder
            metal_stamp_queue_ui_rect(itemX + 10, itemY + 10,
                                      BRUSH_PICKER_ITEM_SIZE - 20, BRUSH_PICKER_ITEM_SIZE - 20,
                                      0.3f, 0.3f, 0.3f, 0.5f, 4.0f);
        }

        // Draw brush name below thumbnail (like Procreate)
        if (brush && brush->name[0] != '\0') {
            int textWidth = 0, textHeight = 0;
            int32_t nameTextureId = getBrushNameTexture(brushId, brush->name, &textWidth, &textHeight);

            if (nameTextureId > 0 && textWidth > 0 && textHeight > 0) {
                // Position text centered at bottom of item
                float textX = itemX + (BRUSH_PICKER_ITEM_SIZE - textWidth) / 2;
                float textY = itemY + BRUSH_PICKER_ITEM_SIZE - textHeight - 8;

                // Draw semi-transparent background for readability
                float bgPadding = 4;
                metal_stamp_queue_ui_rect(textX - bgPadding, textY - bgPadding,
                                          textWidth + bgPadding * 2, textHeight + bgPadding * 2,
                                          0.0f, 0.0f, 0.0f, 0.6f, 4.0f);

                // Draw the text
                metal_stamp_queue_ui_textured_rect(textX, textY, textWidth, textHeight,
                                                   nameTextureId,
                                                   1.0f, 1.0f, 1.0f, 1.0f);
            }
        }
    }

    // Draw scroll indicator on right edge if content is scrollable
    if (contentHeight > visibleHeight) {
        float scrollBarWidth = 6.0f;
        float scrollBarPadding = 4.0f;
        float scrollBarX = picker.x + picker.width - scrollBarWidth - scrollBarPadding;

        // Calculate scroll bar dimensions
        float scrollRatio = visibleHeight / contentHeight;
        float scrollBarHeight = std::max(40.0f, visibleHeight * scrollRatio);
        float scrollRange = visibleHeight - scrollBarHeight;
        float scrollProgress = (maxScroll > 0) ? (g_brushPickerScrollOffset / maxScroll) : 0.0f;
        float scrollBarY = picker.y + BRUSH_PICKER_PADDING + scrollProgress * scrollRange;

        // Draw scroll track (darker)
        metal_stamp_queue_ui_rect(scrollBarX, picker.y + BRUSH_PICKER_PADDING,
                                  scrollBarWidth, visibleHeight,
                                  0.1f, 0.1f, 0.15f, 0.5f, scrollBarWidth / 2);

        // Draw scroll thumb (brighter)
        metal_stamp_queue_ui_rect(scrollBarX, scrollBarY,
                                  scrollBarWidth, scrollBarHeight,
                                  0.5f, 0.5f, 0.6f, 0.8f, scrollBarWidth / 2);
    }
}

// =============================================================================
// Texture Button Configuration
// =============================================================================

struct TextureButtonConfig {
    float x, y;
    float width, height;
    TextureType type;
    bool hasTexture;
    int32_t textureId;
};

static bool isPointInTextureButton(const TextureButtonConfig& btn, float px, float py) {
    return px >= btn.x && px <= btn.x + btn.width &&
           py >= btn.y && py <= btn.y + btn.height;
}

static void drawTextureButton(const TextureButtonConfig& btn, const char* label) {
    // Background - darker purple/blue color for visibility
    float bgAlpha = 0.9f;
    metal_stamp_queue_ui_rect(btn.x, btn.y, btn.width, btn.height,
                              0.4f, 0.3f, 0.6f, bgAlpha, 8.0f);

    // Border - always show for visibility
    metal_stamp_queue_ui_rect(btn.x - 2, btn.y - 2, btn.width + 4, btn.height + 4,
                              0.2f, 0.2f, 0.3f, 0.9f, 10.0f);

    // Show highlight if has texture
    if (btn.hasTexture) {
        metal_stamp_queue_ui_rect(btn.x - 4, btn.y - 4, btn.width + 8, btn.height + 8,
                                  0.4f, 0.7f, 1.0f, 0.8f, 12.0f);
    }
}

// =============================================================================
// UI Slider Configuration
// =============================================================================

struct SliderConfig {
    float x, y;           // Position (top-left)
    float width, height;  // Size
    float value;          // Current value (0.0 - 1.0)
    float minVal, maxVal; // Value range
    bool isDragging;
};

// =============================================================================
// Color Picker Configuration
// =============================================================================

struct ColorPreset {
    float r, g, b;
    const char* name;
};

// =============================================================================
// Canvas Transform - Pan/Zoom/Rotate state
// =============================================================================

struct CanvasTransform {
    float panX, panY;      // Pan offset in screen pixels
    float scale;           // Zoom level (1.0 = 100%)
    float rotation;        // Rotation in radians
    float pivotX, pivotY;  // Transform pivot (usually screen center)
};

// =============================================================================
// Canvas Reset Animation (Procreate-style smooth snap)
// =============================================================================

struct CanvasResetAnimation {
    bool isAnimating;
    Uint64 startTimeMs;
    float durationMs;

    // Start values (what we're animating FROM)
    float startPanX, startPanY;
    float startScale;
    float startRotation;

    // Target values (what we're animating TO)
    float targetPanX, targetPanY;
    float targetScale;
    float targetRotation;
};

// Ease-out cubic for smooth deceleration
static float easeOutCubic(float t) {
    return 1.0f - powf(1.0f - t, 3.0f);
}

// Linear interpolation
static float lerp(float a, float b, float t) {
    return a + (b - a) * t;
}

// Shortest path angle interpolation (handles wrap-around)
static float lerpAngle(float a, float b, float t) {
    // Normalize angles to -PI to PI
    while (a > M_PI) a -= 2.0f * M_PI;
    while (a < -M_PI) a += 2.0f * M_PI;
    while (b > M_PI) b -= 2.0f * M_PI;
    while (b < -M_PI) b += 2.0f * M_PI;

    // Find shortest path
    float diff = b - a;
    if (diff > M_PI) diff -= 2.0f * M_PI;
    if (diff < -M_PI) diff += 2.0f * M_PI;

    return a + diff * t;
}

// =============================================================================
// Two-Finger Gesture Tracking
// =============================================================================

struct TwoFingerGesture {
    bool isActive;
    SDL_FingerID finger0_id, finger1_id;

    // Starting positions (normalized 0-1)
    float finger0_startX, finger0_startY;
    float finger1_startX, finger1_startY;

    // Current positions (normalized 0-1)
    float finger0_currX, finger0_currY;
    float finger1_currX, finger1_currY;

    // Canvas transform at gesture start (baseline)
    float basePanX, basePanY;
    float baseScale;
    float baseRotation;

    // For quick-pinch detection (Procreate-style reset)
    Uint64 startTimeMs;
    float startDistance;  // Initial distance between fingers
};

// =============================================================================
// Three-Finger Gesture Tracking (for redo)
// =============================================================================

struct ThreeFingerGesture {
    bool isActive;
    SDL_FingerID finger0_id, finger1_id, finger2_id;

    // Starting positions (normalized 0-1)
    float finger0_startX, finger0_startY;
    float finger1_startX, finger1_startY;
    float finger2_startX, finger2_startY;

    // Current positions (normalized 0-1)
    float finger0_currX, finger0_currY;
    float finger1_currX, finger1_currY;
    float finger2_currX, finger2_currY;

    // Timing for tap detection
    Uint64 startTimeMs;
};

// Helper: Calculate distance between two points
static float pointDistance(float x1, float y1, float x2, float y2) {
    float dx = x2 - x1;
    float dy = y2 - y1;
    return sqrtf(dx * dx + dy * dy);
}

// Helper: Calculate angle between two points (radians)
static float pointAngle(float x1, float y1, float x2, float y2) {
    return atan2f(y2 - y1, x2 - x1);
}

// Convert screen coordinates to canvas coordinates (for drawing on transformed canvas)
// This MUST match the shader's inverse transform exactly!
static void screenToCanvas(float screenX, float screenY, const CanvasTransform& transform,
                           int screenWidth, int screenHeight,
                           float& canvasX, float& canvasY) {
    // Apply inverse transform to get canvas position
    // This matches the shader's canvas_blit_vertex exactly

    // 1. Translate to pivot
    float x = screenX - transform.pivotX;
    float y = screenY - transform.pivotY;

    // 2. Undo pan
    x -= transform.panX;
    y -= transform.panY;

    // 3. Undo scale
    x /= transform.scale;
    y /= transform.scale;

    // 4. Undo rotation
    float c = cosf(-transform.rotation);
    float s = sinf(-transform.rotation);
    float rx = x * c - y * s;
    float ry = x * s + y * c;

    // 5. Translate back from pivot
    canvasX = rx + transform.pivotX;
    canvasY = ry + transform.pivotY;
}

// Update canvas transform from gesture
static void updateTransformFromGesture(CanvasTransform& transform, const TwoFingerGesture& gesture,
                                       int screenWidth, int screenHeight) {
    if (!gesture.isActive) return;

    // Calculate start and current vectors (in screen pixels)
    float startDist = pointDistance(
        gesture.finger0_startX * screenWidth, gesture.finger0_startY * screenHeight,
        gesture.finger1_startX * screenWidth, gesture.finger1_startY * screenHeight
    );
    float currDist = pointDistance(
        gesture.finger0_currX * screenWidth, gesture.finger0_currY * screenHeight,
        gesture.finger1_currX * screenWidth, gesture.finger1_currY * screenHeight
    );

    // Scale: ratio of distances
    float deltaScale = (startDist > 1.0f) ? (currDist / startDist) : 1.0f;
    transform.scale = gesture.baseScale * deltaScale;

    // Clamp scale
    if (transform.scale < 0.1f) transform.scale = 0.1f;
    if (transform.scale > 10.0f) transform.scale = 10.0f;

    // Rotation: difference in angles
    float startAngle = pointAngle(
        gesture.finger0_startX, gesture.finger0_startY,
        gesture.finger1_startX, gesture.finger1_startY
    );
    float currAngle = pointAngle(
        gesture.finger0_currX, gesture.finger0_currY,
        gesture.finger1_currX, gesture.finger1_currY
    );
    float deltaRotation = currAngle - startAngle;
    transform.rotation = gesture.baseRotation + deltaRotation;

    // Pan: center point displacement (in screen pixels)
    float startCenterX = (gesture.finger0_startX + gesture.finger1_startX) / 2.0f * screenWidth;
    float startCenterY = (gesture.finger0_startY + gesture.finger1_startY) / 2.0f * screenHeight;
    float currCenterX = (gesture.finger0_currX + gesture.finger1_currX) / 2.0f * screenWidth;
    float currCenterY = (gesture.finger0_currY + gesture.finger1_currY) / 2.0f * screenHeight;

    transform.panX = gesture.basePanX + (currCenterX - startCenterX);
    transform.panY = gesture.basePanY + (currCenterY - startCenterY);

    // Update pivot to gesture center
    transform.pivotX = currCenterX;
    transform.pivotY = currCenterY;
}

// =============================================================================
// Color Picker - Grid-based color selection panel
// =============================================================================

// HSV to RGB conversion helper
static void hsvToRgb(float h, float s, float v, float& r, float& g, float& b) {
    if (s <= 0.0f) { r = g = b = v; return; }
    float hh = h;
    if (hh >= 360.0f) hh = 0.0f;
    hh /= 60.0f;
    int i = (int)hh;
    float ff = hh - i;
    float p = v * (1.0f - s);
    float q = v * (1.0f - (s * ff));
    float t = v * (1.0f - (s * (1.0f - ff)));
    switch(i) {
        case 0: r = v; g = t; b = p; break;
        case 1: r = q; g = v; b = p; break;
        case 2: r = p; g = v; b = t; break;
        case 3: r = p; g = q; b = v; break;
        case 4: r = t; g = p; b = v; break;
        default: r = v; g = p; b = q; break;
    }
}

// Color picker configuration
static const int COLOR_GRID_COLS = 6;
static const int COLOR_GRID_ROWS = 5;
static const float COLOR_SWATCH_SIZE = 50.0f;
static const float COLOR_SWATCH_GAP = 6.0f;
static const float COLOR_PICKER_PADDING = 12.0f;

struct ColorPickerState {
    bool isOpen;
    float x, y;              // Panel position (top-left)
    float width, height;     // Panel size
    float currentR, currentG, currentB;  // Current selected color
};

// Generate color grid (hue varies by column, brightness by row)
static void getGridColor(int col, int row, float& r, float& g, float& b) {
    if (row == COLOR_GRID_ROWS - 1) {
        // Bottom row: grayscale
        float gray = (float)col / (COLOR_GRID_COLS - 1);
        r = g = b = gray;
    } else {
        // Color rows: vary hue by column, saturation/brightness by row
        float hue = (float)col / COLOR_GRID_COLS * 360.0f;
        float sat = 0.85f;
        float val = 1.0f - (float)row / (COLOR_GRID_ROWS - 1) * 0.6f;  // 1.0 to 0.4
        hsvToRgb(hue, sat, val, r, g, b);
    }
}

struct ColorButtonConfig {
    float x, y;           // Position (top-left)
    float size;           // Diameter
};

// Check if point is inside color button
static bool isPointInColorButton(const ColorButtonConfig& btn, float px, float py) {
    float cx = btn.x + btn.size / 2.0f;
    float cy = btn.y + btn.size / 2.0f;
    float dx = px - cx;
    float dy = py - cy;
    return (dx*dx + dy*dy) <= (btn.size/2.0f * btn.size/2.0f);
}

// Check if point is inside color picker panel
static bool isPointInColorPicker(const ColorPickerState& picker, float px, float py) {
    return picker.isOpen &&
           px >= picker.x && px <= picker.x + picker.width &&
           py >= picker.y && py <= picker.y + picker.height;
}

// Get which color swatch was tapped (-1 if none)
static int getSwatchAtPoint(const ColorPickerState& picker, float px, float py) {
    if (!picker.isOpen) return -1;

    float gridX = picker.x + COLOR_PICKER_PADDING;
    float gridY = picker.y + COLOR_PICKER_PADDING;

    float relX = px - gridX;
    float relY = py - gridY;

    if (relX < 0 || relY < 0) return -1;

    int col = (int)(relX / (COLOR_SWATCH_SIZE + COLOR_SWATCH_GAP));
    int row = (int)(relY / (COLOR_SWATCH_SIZE + COLOR_SWATCH_GAP));

    if (col >= COLOR_GRID_COLS || row >= COLOR_GRID_ROWS) return -1;

    // Check if actually inside the swatch (not in gap)
    float swatchLocalX = relX - col * (COLOR_SWATCH_SIZE + COLOR_SWATCH_GAP);
    float swatchLocalY = relY - row * (COLOR_SWATCH_SIZE + COLOR_SWATCH_GAP);
    if (swatchLocalX > COLOR_SWATCH_SIZE || swatchLocalY > COLOR_SWATCH_SIZE) return -1;

    return row * COLOR_GRID_COLS + col;
}

// Draw color picker button (shows current color)
static void drawColorButton(const ColorButtonConfig& btn, const ColorPickerState& picker) {
    // Outer ring (white)
    metal_stamp_queue_ui_rect(btn.x, btn.y, btn.size, btn.size,
                              1.0f, 1.0f, 1.0f, 1.0f, btn.size / 2.0f);

    // Inner color circle
    float innerMargin = 4.0f;
    float innerSize = btn.size - innerMargin * 2;
    metal_stamp_queue_ui_rect(btn.x + innerMargin, btn.y + innerMargin, innerSize, innerSize,
                              picker.currentR, picker.currentG, picker.currentB, 1.0f, innerSize / 2.0f);
}

// Draw color picker panel
static void drawColorPicker(const ColorPickerState& picker) {
    if (!picker.isOpen) return;

    // Panel background (dark semi-transparent)
    metal_stamp_queue_ui_rect(picker.x, picker.y, picker.width, picker.height,
                              0.15f, 0.15f, 0.15f, 0.95f, 12.0f);

    // Draw color grid
    float gridX = picker.x + COLOR_PICKER_PADDING;
    float gridY = picker.y + COLOR_PICKER_PADDING;

    for (int row = 0; row < COLOR_GRID_ROWS; row++) {
        for (int col = 0; col < COLOR_GRID_COLS; col++) {
            float r, g, b;
            getGridColor(col, row, r, g, b);

            float swatchX = gridX + col * (COLOR_SWATCH_SIZE + COLOR_SWATCH_GAP);
            float swatchY = gridY + row * (COLOR_SWATCH_SIZE + COLOR_SWATCH_GAP);

            metal_stamp_queue_ui_rect(swatchX, swatchY, COLOR_SWATCH_SIZE, COLOR_SWATCH_SIZE,
                                      r, g, b, 1.0f, 6.0f);
        }
    }
}

// Check if point is inside slider track area
static bool isPointInSlider(const SliderConfig& slider, float px, float py) {
    return px >= slider.x && px <= slider.x + slider.width &&
           py >= slider.y && py <= slider.y + slider.height;
}

// Draw a vertical slider (Procreate-style)
static void drawVerticalSlider(const SliderConfig& slider, int screenHeight,
                               float r, float g, float b, const char* label) {
    // Slider track background (dark semi-transparent)
    metal_stamp_queue_ui_rect(slider.x, slider.y, slider.width, slider.height,
                              0.2f, 0.2f, 0.2f, 0.7f, 10.0f);

    // Filled portion (shows current value)
    float fillHeight = slider.height * slider.value;
    float fillY = slider.y + slider.height - fillHeight;
    if (fillHeight > 0) {
        metal_stamp_queue_ui_rect(slider.x, fillY, slider.width, fillHeight,
                                  r, g, b, 0.9f, 10.0f);
    }

    // Slider knob/handle
    float knobSize = slider.width * 1.3f;
    float knobX = slider.x + slider.width / 2.0f - knobSize / 2.0f;
    float knobY = fillY - knobSize / 2.0f;
    metal_stamp_queue_ui_rect(knobX, knobY, knobSize, knobSize,
                              1.0f, 1.0f, 1.0f, 1.0f, knobSize / 2.0f);

    // Inner knob circle (colored)
    float innerSize = knobSize * 0.7f;
    float innerX = knobX + (knobSize - innerSize) / 2.0f;
    float innerY = knobY + (knobSize - innerSize) / 2.0f;
    metal_stamp_queue_ui_rect(innerX, innerY, innerSize, innerSize,
                              r, g, b, 1.0f, innerSize / 2.0f);
}

static int metal_test_main() {
    std::cout << "========================================" << std::endl;
    std::cout << "   METAL TEST MODE - Pure C++ Rendering" << std::endl;
    std::cout << "========================================" << std::endl;

    // Create SDL window
    SDL_Window* window = SDL_CreateWindow(
        "Metal Test",
        1024, 768,
        SDL_WINDOW_METAL | SDL_WINDOW_HIGH_PIXEL_DENSITY
    );

    if (!window) {
        std::cerr << "Failed to create window: " << SDL_GetError() << std::endl;
        return 1;
    }

    // Store window globally for texture picker
    g_sdlWindow = window;

    int width, height;
    SDL_GetWindowSizeInPixels(window, &width, &height);
    std::cout << "Window size: " << width << "x" << height << std::endl;

    // Get pixel density for converting pen coordinates (in points) to pixels
    // Pen events use window coordinates (points), not physical pixels
    float pixelDensity = SDL_GetWindowPixelDensity(window);
    std::cout << "Pixel density: " << pixelDensity << std::endl;

    // Initialize Metal renderer
    std::cout << "Initializing Metal stamp renderer..." << std::endl;
    if (!metal_stamp_init(window, width, height)) {
        std::cerr << "Failed to initialize Metal renderer!" << std::endl;
        SDL_DestroyWindow(window);
        return 1;
    }
    std::cout << "Metal renderer initialized!" << std::endl;

    // Initialize undo tree for branching undo history
    metal_stamp_undo_init();
    std::cout << "Undo tree initialized!" << std::endl;

    // =============================================================================
    // Initialize UI Sliders (Procreate-style vertical sliders on left edge)
    // =============================================================================

    const float SLIDER_WIDTH = 60.0f;
    const float SLIDER_HEIGHT = 300.0f;
    const float SLIDER_MARGIN = 40.0f;
    const float SLIDER_SPACING = 30.0f;

    SliderConfig sizeSlider = {
        .x = SLIDER_MARGIN,
        .y = height / 2.0f - SLIDER_HEIGHT - SLIDER_SPACING / 2.0f,
        .width = SLIDER_WIDTH,
        .height = SLIDER_HEIGHT,
        .value = 0.25f,  // 25% = 50px brush (range 10-200)
        .minVal = 10.0f,
        .maxVal = 200.0f,
        .isDragging = false
    };

    SliderConfig opacitySlider = {
        .x = SLIDER_MARGIN,
        .y = height / 2.0f + SLIDER_SPACING / 2.0f,
        .width = SLIDER_WIDTH,
        .height = SLIDER_HEIGHT,
        .value = 0.9f,  // 90% opacity
        .minVal = 0.0f,
        .maxVal = 1.0f,
        .isDragging = false
    };

    // =============================================================================
    // Initialize Color Button and Picker
    // =============================================================================

    const float COLOR_BUTTON_SIZE = 70.0f;
    ColorButtonConfig colorButton = {
        .x = SLIDER_MARGIN - (COLOR_BUTTON_SIZE - SLIDER_WIDTH) / 2.0f,  // Center under sliders
        .y = opacitySlider.y + opacitySlider.height + SLIDER_SPACING,
        .size = COLOR_BUTTON_SIZE
    };

    // Calculate color picker panel size
    float pickerWidth = COLOR_GRID_COLS * (COLOR_SWATCH_SIZE + COLOR_SWATCH_GAP) - COLOR_SWATCH_GAP + COLOR_PICKER_PADDING * 2;
    float pickerHeight = COLOR_GRID_ROWS * (COLOR_SWATCH_SIZE + COLOR_SWATCH_GAP) - COLOR_SWATCH_GAP + COLOR_PICKER_PADDING * 2;

    ColorPickerState colorPicker = {
        .isOpen = false,
        .x = colorButton.x + colorButton.size + 20.0f,  // Position to right of button
        .y = colorButton.y - pickerHeight / 2.0f + colorButton.size / 2.0f,  // Center vertically with button
        .width = pickerWidth,
        .height = pickerHeight,
        .currentR = 0.15f,  // Start with blue
        .currentG = 0.45f,
        .currentB = 0.75f
    };

    // Ensure picker stays on screen
    if (colorPicker.y < 10.0f) colorPicker.y = 10.0f;
    if (colorPicker.y + pickerHeight > height - 10.0f) colorPicker.y = height - pickerHeight - 10.0f;

    // =============================================================================
    // Initialize Texture Buttons (Shape and Grain)
    // =============================================================================
    const float TEXTURE_BUTTON_SIZE = 60.0f;
    const float TEXTURE_BUTTON_GAP = 10.0f;

    // Position texture buttons at top-right corner of the canvas (portrait coords)
    // Due to 90 rotation, this appears at top-right in landscape view
    // Note: coordinate system is rotated - portrait (width x height) maps to landscape display
    float textureButtonsX = width - TEXTURE_BUTTON_SIZE * 2 - TEXTURE_BUTTON_GAP - 40.0f;
    float textureButtonsY = height - TEXTURE_BUTTON_SIZE * 2 - TEXTURE_BUTTON_GAP - 40.0f;

    TextureButtonConfig shapeTextureButton = {
        .x = textureButtonsX,
        .y = textureButtonsY,
        .width = TEXTURE_BUTTON_SIZE,
        .height = TEXTURE_BUTTON_SIZE,
        .type = TextureTypeShape,
        .hasTexture = false,
        .textureId = -1
    };

    TextureButtonConfig grainTextureButton = {
        .x = textureButtonsX + TEXTURE_BUTTON_SIZE + TEXTURE_BUTTON_GAP,
        .y = textureButtonsY,
        .width = TEXTURE_BUTTON_SIZE,
        .height = TEXTURE_BUTTON_SIZE,
        .type = TextureTypeGrain,
        .hasTexture = false,
        .textureId = -1
    };

    // =============================================================================
    // Initialize Brush Picker Button
    // =============================================================================

    // Position brush button above the sliders
    BrushButtonConfig brushButton = {
        .x = SLIDER_MARGIN,
        .y = sizeSlider.y - BRUSH_BUTTON_HEIGHT - 30.0f,
        .width = BRUSH_BUTTON_WIDTH,
        .height = BRUSH_BUTTON_HEIGHT
    };

    // Position eraser button to the right of brush button
    EraserButtonConfig eraserButton = {
        .x = brushButton.x + brushButton.width + 20.0f,
        .y = brushButton.y + (brushButton.height - ERASER_BUTTON_SIZE) / 2,
        .size = ERASER_BUTTON_SIZE
    };

    // Initialize brush picker panel - position in center of screen
    float brushPickerWidth = BRUSH_PICKER_COLS * (BRUSH_PICKER_ITEM_SIZE + BRUSH_PICKER_ITEM_GAP) + BRUSH_PICKER_PADDING * 2 - BRUSH_PICKER_ITEM_GAP;
    float brushPickerHeight = 800.0f;  // Show more brushes
    BrushPickerConfig brushPicker = {
        .x = (width - brushPickerWidth) / 2,
        .y = (height - brushPickerHeight) / 2,
        .width = brushPickerWidth,
        .height = brushPickerHeight,
        .isOpen = true,  // Start open for testing thumbnails
        .scrollOffset = 0
    };

    // Calculate initial brush values from slider positions
    float brushSize = sizeSlider.minVal + sizeSlider.value * (sizeSlider.maxVal - sizeSlider.minVal);
    float brushOpacity = opacitySlider.minVal + opacitySlider.value * (opacitySlider.maxVal - opacitySlider.minVal);

    // Set DEFAULT brush settings (will be overridden by loaded brush)
    metal_stamp_set_brush_type(1);  // Textured brush
    metal_stamp_set_brush_hardness(0.35f);
    metal_stamp_set_brush_spacing(0.06f);
    metal_stamp_set_brush_grain_scale(1.8f);
    metal_stamp_set_brush_size_pressure(0.8f);
    metal_stamp_set_brush_opacity_pressure(0.3f);
    metal_stamp_set_brush_scatter(3.0f);
    metal_stamp_set_brush_size_jitter(0.15f);
    metal_stamp_set_brush_opacity_jitter(0.1f);

    // Load brushes from bundled brushset - this overrides defaults with actual brush settings
    loadBrushesFromBundledFile();

    // Set user-controlled values (these don't come from brush, only from UI)
    metal_stamp_set_brush_size(brushSize);
    metal_stamp_set_brush_opacity(brushOpacity);
    metal_stamp_set_brush_color(colorPicker.currentR, colorPicker.currentG, colorPicker.currentB, 1.0f);

    // Clear canvas to white
    metal_stamp_clear_canvas(1.0f, 1.0f, 1.0f, 1.0f);

    // =============================================================================
    // Initialize Canvas Transform and Gesture State
    // =============================================================================

    CanvasTransform canvasTransform = {
        .panX = 0.0f,
        .panY = 0.0f,
        .scale = 1.0f,
        .rotation = 0.0f,
        .pivotX = width / 2.0f,
        .pivotY = height / 2.0f
    };

    TwoFingerGesture gesture = {
        .isActive = false,
        .finger0_id = 0,
        .finger1_id = 0,
        .finger0_startX = 0, .finger0_startY = 0,
        .finger1_startX = 0, .finger1_startY = 0,
        .finger0_currX = 0, .finger0_currY = 0,
        .finger1_currX = 0, .finger1_currY = 0,
        .basePanX = 0, .basePanY = 0,
        .baseScale = 1.0f,
        .baseRotation = 0.0f,
        .startTimeMs = 0,
        .startDistance = 0.0f
    };

    ThreeFingerGesture threeFingerGesture = {
        .isActive = false,
        .finger0_id = 0, .finger1_id = 0, .finger2_id = 0,
        .finger0_startX = 0, .finger0_startY = 0,
        .finger1_startX = 0, .finger1_startY = 0,
        .finger2_startX = 0, .finger2_startY = 0,
        .finger0_currX = 0, .finger0_currY = 0,
        .finger1_currX = 0, .finger1_currY = 0,
        .finger2_currX = 0, .finger2_currY = 0,
        .startTimeMs = 0
    };

    // Canvas reset animation state
    CanvasResetAnimation resetAnim = {
        .isAnimating = false,
        .startTimeMs = 0,
        .durationMs = 250.0f,  // 250ms for smooth but snappy feel
        .startPanX = 0, .startPanY = 0,
        .startScale = 1.0f,
        .startRotation = 0.0f,
        .targetPanX = 0, .targetPanY = 0,
        .targetScale = 1.0f,
        .targetRotation = 0.0f
    };

    // Track single finger for potential gesture start
    bool hasFinger0 = false;
    SDL_FingerID pendingFinger0_id = 0;
    float pendingFinger0_x = 0, pendingFinger0_y = 0;

    // Track drawing state
    bool is_drawing = false;
    float last_x = 0, last_y = 0;
    float pen_pressure = 1.0f;  // Track Apple Pencil pressure from axis events

    // Main loop
    bool running = true;
    while (running) {
        // Sync texture button state from globals (updated by picker callback)
        shapeTextureButton.hasTexture = g_shapeTextureHasTexture;
        shapeTextureButton.textureId = g_shapeTextureId;
        grainTextureButton.hasTexture = g_grainTextureHasTexture;
        grainTextureButton.textureId = g_grainTextureId;

        SDL_Event event;
        while (SDL_PollEvent(&event)) {
            switch (event.type) {
                case SDL_EVENT_QUIT:
                    running = false;
                    break;

                case SDL_EVENT_FINGER_DOWN: {
                    // Finger events: Used for UI interaction and two-finger gestures
                    // Drawing is done via Apple Pencil (pen events) only

                    // Log raw normalized finger coordinates
                    NSLog(@"[DEBUG] Raw finger: (%.4f, %.4f) * (%d, %d)",
                          event.tfinger.x, event.tfinger.y, width, height);

                    float x = event.tfinger.x * width;
                    float y = event.tfinger.y * height;
                    SDL_FingerID fingerId = event.tfinger.fingerID;

                    // Check UI elements FIRST (before gesture tracking)
                    bool handledByUI = false;
                    if (!gesture.isActive) {
                        float sliderHitPadding = 30.0f;
                        SliderConfig expandedSize = sizeSlider;
                        expandedSize.x -= sliderHitPadding;
                        expandedSize.width += sliderHitPadding * 2;
                        expandedSize.y -= sliderHitPadding;
                        expandedSize.height += sliderHitPadding * 2;

                        SliderConfig expandedOpacity = opacitySlider;
                        expandedOpacity.x -= sliderHitPadding;
                        expandedOpacity.width += sliderHitPadding * 2;
                        expandedOpacity.y -= sliderHitPadding;
                        expandedOpacity.height += sliderHitPadding * 2;

                        if (isPointInSlider(expandedSize, x, y)) {
                            sizeSlider.isDragging = true;
                            float relY = (y - sizeSlider.y) / sizeSlider.height;
                            sizeSlider.value = 1.0f - std::max(0.0f, std::min(1.0f, relY));
                            brushSize = sizeSlider.minVal + sizeSlider.value * (sizeSlider.maxVal - sizeSlider.minVal);
                            metal_stamp_set_brush_size(brushSize);
                            std::cout << "Size slider: " << (int)brushSize << "px" << std::endl;
                            handledByUI = true;
                        } else if (isPointInSlider(expandedOpacity, x, y)) {
                            opacitySlider.isDragging = true;
                            float relY = (y - opacitySlider.y) / opacitySlider.height;
                            opacitySlider.value = 1.0f - std::max(0.0f, std::min(1.0f, relY));
                            brushOpacity = opacitySlider.minVal + opacitySlider.value * (opacitySlider.maxVal - opacitySlider.minVal);
                            metal_stamp_set_brush_opacity(brushOpacity);
                            std::cout << "Opacity slider: " << (int)(brushOpacity * 100) << "%" << std::endl;
                            handledByUI = true;
                        } else if (isPointInColorPicker(colorPicker, x, y)) {
                            int swatchIdx = getSwatchAtPoint(colorPicker, x, y);
                            if (swatchIdx >= 0) {
                                int col = swatchIdx % COLOR_GRID_COLS;
                                int row = swatchIdx / COLOR_GRID_COLS;
                                getGridColor(col, row, colorPicker.currentR, colorPicker.currentG, colorPicker.currentB);
                                metal_stamp_set_brush_color(colorPicker.currentR, colorPicker.currentG, colorPicker.currentB, 1.0f);
                                colorPicker.isOpen = false;
                                std::cout << "Color selected from picker" << std::endl;
                            }
                            handledByUI = true;
                        } else if (isPointInColorButton(colorButton, x, y)) {
                            colorPicker.isOpen = !colorPicker.isOpen;
                            std::cout << "Color picker " << (colorPicker.isOpen ? "opened" : "closed") << std::endl;
                            handledByUI = true;
                        } else if (colorPicker.isOpen) {
                            colorPicker.isOpen = false;
                            std::cout << "Color picker closed (tap outside)" << std::endl;
                            handledByUI = true;
                        }

                        if (isPointInTextureButton(shapeTextureButton, x, y)) {
                            // Show shape texture picker
                            std::cout << "Shape texture button tapped - showing picker" << std::endl;
                            showTexturePicker(window, TextureTypeShape);
                            handledByUI = true;
                        } else if (isPointInTextureButton(grainTextureButton, x, y)) {
                            // Show grain texture picker
                            std::cout << "Grain texture button tapped - showing picker" << std::endl;
                            showTexturePicker(window, TextureTypeGrain);
                            handledByUI = true;
                        } else if (isPointInBrushPicker(brushPicker, x, y)) {
                            // Start tracking touch for scroll/tap detection
                            g_brushPickerIsDragging = true;
                            g_brushPickerDragFingerId = fingerId;
                            g_brushPickerDragStartY = y;
                            g_brushPickerDragStartOffset = g_brushPickerScrollOffset;
                            NSLog(@"[BrushPicker] Touch down at y=%.1f, scroll=%.1f", y, g_brushPickerScrollOffset);
                            handledByUI = true;
                        } else if (isPointInBrushButton(brushButton, x, y)) {
                            // Toggle brush picker open/closed
                            brushPicker.isOpen = !brushPicker.isOpen;
                            NSLog(@"[BrushPicker] %s", brushPicker.isOpen ? "Opened" : "Closed");
                            handledByUI = true;
                        } else if (isPointInEraserButton(eraserButton, x, y)) {
                            // Toggle eraser mode
                            g_eraserMode = !g_eraserMode;
                            if (g_eraserMode) {
                                // Set brush color to white (background color)
                                metal_stamp_set_brush_color(1.0f, 1.0f, 1.0f, 1.0f);
                                NSLog(@"[Eraser] Eraser mode ON");
                            } else {
                                // Restore to current color picker color
                                metal_stamp_set_brush_color(colorPicker.currentR, colorPicker.currentG, colorPicker.currentB, 1.0f);
                                NSLog(@"[Eraser] Eraser mode OFF");
                            }
                            handledByUI = true;
                        } else if (brushPicker.isOpen) {
                            // Tap outside picker closes it
                            brushPicker.isOpen = false;
                            NSLog(@"[BrushPicker] Closed (tap outside)");
                            handledByUI = true;
                        }

                        // Debug: Log tap position vs all UI element bounds
                        NSLog(@"[DEBUG] Tap at (%.1f, %.1f) - width=%d height=%d", x, y, width, height);
                        NSLog(@"[DEBUG]   Brush button at (%.1f, %.1f) size (%.1fx%.1f)",
                              brushButton.x, brushButton.y, brushButton.width, brushButton.height);
                        NSLog(@"[DEBUG]   Size slider at (%.1f, %.1f) size (%.1fx%.1f)",
                              sizeSlider.x, sizeSlider.y, sizeSlider.width, sizeSlider.height);
                        NSLog(@"[DEBUG]   Opacity slider at (%.1f, %.1f) size (%.1fx%.1f)",
                              opacitySlider.x, opacitySlider.y, opacitySlider.width, opacitySlider.height);
                    }

                    // If not handled by UI, track for gestures OR single-finger drawing
                    if (!handledByUI) {
                        // Check for third finger during two-finger gesture
                        if (gesture.isActive && !threeFingerGesture.isActive &&
                            fingerId != gesture.finger0_id && fingerId != gesture.finger1_id) {
                            // Third finger down - start three-finger gesture (for redo)
                            threeFingerGesture.isActive = true;
                            threeFingerGesture.finger0_id = gesture.finger0_id;
                            threeFingerGesture.finger1_id = gesture.finger1_id;
                            threeFingerGesture.finger2_id = fingerId;
                            threeFingerGesture.finger0_startX = gesture.finger0_currX;
                            threeFingerGesture.finger0_startY = gesture.finger0_currY;
                            threeFingerGesture.finger1_startX = gesture.finger1_currX;
                            threeFingerGesture.finger1_startY = gesture.finger1_currY;
                            threeFingerGesture.finger2_startX = event.tfinger.x;
                            threeFingerGesture.finger2_startY = event.tfinger.y;
                            threeFingerGesture.finger0_currX = threeFingerGesture.finger0_startX;
                            threeFingerGesture.finger0_currY = threeFingerGesture.finger0_startY;
                            threeFingerGesture.finger1_currX = threeFingerGesture.finger1_startX;
                            threeFingerGesture.finger1_currY = threeFingerGesture.finger1_startY;
                            threeFingerGesture.finger2_currX = threeFingerGesture.finger2_startX;
                            threeFingerGesture.finger2_currY = threeFingerGesture.finger2_startY;
                            threeFingerGesture.startTimeMs = SDL_GetTicks();
                            std::cout << "Three-finger gesture started (for redo)" << std::endl;
                        }
                        else if (!gesture.isActive) {
                            if (!hasFinger0) {
                                // First finger down - start drawing OR wait for second finger
                                hasFinger0 = true;
                                pendingFinger0_id = fingerId;
                                pendingFinger0_x = event.tfinger.x;
                                pendingFinger0_y = event.tfinger.y;

                                // Start drawing with single finger (for simulator testing)
                                // On real device, Apple Pencil uses PEN events instead
                                float canvasX, canvasY;
                                screenToCanvas(x, y, canvasTransform, width, height, canvasX, canvasY);
                                metal_stamp_undo_begin_stroke(canvasX, canvasY, 1.0f);
                                last_x = canvasX;
                                last_y = canvasY;
                                is_drawing = true;
                                std::cout << "Finger drawing started at " << canvasX << ", " << canvasY << std::endl;
                            } else if (pendingFinger0_id != fingerId) {
                                // Second finger down - STOP drawing and start two-finger gesture!
                                if (is_drawing) {
                                    metal_stamp_undo_cancel_stroke();  // Cancel incomplete stroke
                                    is_drawing = false;
                                    std::cout << "Drawing cancelled - switching to gesture" << std::endl;
                                }
                                gesture.isActive = true;
                                gesture.finger0_id = pendingFinger0_id;
                                gesture.finger1_id = fingerId;
                                gesture.finger0_startX = pendingFinger0_x;
                                gesture.finger0_startY = pendingFinger0_y;
                                gesture.finger1_startX = event.tfinger.x;
                                gesture.finger1_startY = event.tfinger.y;
                                gesture.finger0_currX = gesture.finger0_startX;
                                gesture.finger0_currY = gesture.finger0_startY;
                                gesture.finger1_currX = gesture.finger1_startX;
                                gesture.finger1_currY = gesture.finger1_startY;
                                // Store current transform as baseline
                                gesture.basePanX = canvasTransform.panX;
                                gesture.basePanY = canvasTransform.panY;
                                gesture.baseScale = canvasTransform.scale;
                                gesture.baseRotation = canvasTransform.rotation;
                                // For quick-pinch and tap detection
                                gesture.startTimeMs = SDL_GetTicks();
                                gesture.startDistance = pointDistance(
                                    gesture.finger0_startX * width, gesture.finger0_startY * height,
                                    gesture.finger1_startX * width, gesture.finger1_startY * height
                                );
                                std::cout << "Two-finger gesture started (scale: " << canvasTransform.scale
                                          << ", rotation: " << canvasTransform.rotation << ")" << std::endl;
                            }
                        }
                    }
                    break;
                }

                case SDL_EVENT_FINGER_MOTION: {
                    float x = event.tfinger.x * width;
                    float y = event.tfinger.y * height;
                    SDL_FingerID fingerId = event.tfinger.fingerID;

                    // Handle three-finger gesture motion
                    if (threeFingerGesture.isActive) {
                        if (fingerId == threeFingerGesture.finger0_id) {
                            threeFingerGesture.finger0_currX = event.tfinger.x;
                            threeFingerGesture.finger0_currY = event.tfinger.y;
                        } else if (fingerId == threeFingerGesture.finger1_id) {
                            threeFingerGesture.finger1_currX = event.tfinger.x;
                            threeFingerGesture.finger1_currY = event.tfinger.y;
                        } else if (fingerId == threeFingerGesture.finger2_id) {
                            threeFingerGesture.finger2_currX = event.tfinger.x;
                            threeFingerGesture.finger2_currY = event.tfinger.y;
                        }
                    }
                    // Handle two-finger gesture motion
                    else if (gesture.isActive) {
                        // Update the moving finger's current position
                        if (fingerId == gesture.finger0_id) {
                            gesture.finger0_currX = event.tfinger.x;
                            gesture.finger0_currY = event.tfinger.y;
                        } else if (fingerId == gesture.finger1_id) {
                            gesture.finger1_currX = event.tfinger.x;
                            gesture.finger1_currY = event.tfinger.y;
                        }
                        // Update canvas transform from gesture
                        updateTransformFromGesture(canvasTransform, gesture, width, height);
                    }
                    // Handle single-finger drawing (for simulator testing)
                    else if (is_drawing && hasFinger0 && fingerId == pendingFinger0_id) {
                        // Update pending finger position
                        pendingFinger0_x = event.tfinger.x;
                        pendingFinger0_y = event.tfinger.y;
                        // Add stroke point with screen-to-canvas conversion
                        float canvasX, canvasY;
                        screenToCanvas(x, y, canvasTransform, width, height, canvasX, canvasY);
                        float dx = canvasX - last_x;
                        float dy = canvasY - last_y;
                        if (dx*dx + dy*dy > 1.0f) {
                            metal_stamp_undo_add_stroke_point(canvasX, canvasY, 1.0f);
                            last_x = canvasX;
                            last_y = canvasY;
                        }
                    }
                    // Update pending finger position (in case it becomes part of gesture)
                    else if (hasFinger0 && fingerId == pendingFinger0_id) {
                        pendingFinger0_x = event.tfinger.x;
                        pendingFinger0_y = event.tfinger.y;
                    }
                    // Handle UI slider dragging
                    // Handle brush picker scrolling
                    else if (g_brushPickerIsDragging && fingerId == g_brushPickerDragFingerId) {
                        // Update scroll offset based on drag distance
                        float deltaY = g_brushPickerDragStartY - y;  // Drag down = positive delta = scroll down
                        g_brushPickerScrollOffset = g_brushPickerDragStartOffset + deltaY;
                        // Note: clamping happens in drawBrushPicker
                    }
                    else if (sizeSlider.isDragging) {
                        float relY = (y - sizeSlider.y) / sizeSlider.height;
                        sizeSlider.value = 1.0f - std::max(0.0f, std::min(1.0f, relY));
                        brushSize = sizeSlider.minVal + sizeSlider.value * (sizeSlider.maxVal - sizeSlider.minVal);
                        metal_stamp_set_brush_size(brushSize);
                    } else if (opacitySlider.isDragging) {
                        float relY = (y - opacitySlider.y) / opacitySlider.height;
                        opacitySlider.value = 1.0f - std::max(0.0f, std::min(1.0f, relY));
                        brushOpacity = opacitySlider.minVal + opacitySlider.value * (opacitySlider.maxVal - opacitySlider.minVal);
                        metal_stamp_set_brush_opacity(brushOpacity);
                    }
                    break;
                }

                case SDL_EVENT_FINGER_UP: {
                    SDL_FingerID fingerId = event.tfinger.fingerID;

                    // Constants for tap detection
                    const Uint64 TAP_MAX_DURATION_MS = 200;    // Max duration for a tap
                    const float TAP_MAX_MOVEMENT = 20.0f;     // Max movement in pixels for a tap

                    // Handle three-finger gesture release (for redo)
                    if (threeFingerGesture.isActive) {
                        if (fingerId == threeFingerGesture.finger0_id ||
                            fingerId == threeFingerGesture.finger1_id ||
                            fingerId == threeFingerGesture.finger2_id) {

                            Uint64 gestureDuration = SDL_GetTicks() - threeFingerGesture.startTimeMs;

                            // Check if it was a tap (short duration, minimal movement)
                            float move0 = pointDistance(
                                threeFingerGesture.finger0_startX * width, threeFingerGesture.finger0_startY * height,
                                threeFingerGesture.finger0_currX * width, threeFingerGesture.finger0_currY * height);
                            float move1 = pointDistance(
                                threeFingerGesture.finger1_startX * width, threeFingerGesture.finger1_startY * height,
                                threeFingerGesture.finger1_currX * width, threeFingerGesture.finger1_currY * height);
                            float move2 = pointDistance(
                                threeFingerGesture.finger2_startX * width, threeFingerGesture.finger2_startY * height,
                                threeFingerGesture.finger2_currX * width, threeFingerGesture.finger2_currY * height);

                            float maxMove = std::max({move0, move1, move2});

                            if (gestureDuration < TAP_MAX_DURATION_MS && maxMove < TAP_MAX_MOVEMENT) {
                                // Three-finger tap detected - REDO!
                                if (metal_stamp_can_redo()) {
                                    metal_stamp_redo();
                                    std::cout << " Three-finger tap: REDO!" << std::endl;
                                } else {
                                    std::cout << " Three-finger tap: No redo available" << std::endl;
                                }
                            }

                            threeFingerGesture.isActive = false;
                            gesture.isActive = false;  // Also end two-finger gesture
                            hasFinger0 = false;
                            std::cout << "Three-finger gesture ended" << std::endl;
                        }
                    }
                    // Handle two-finger gesture release
                    else if (gesture.isActive) {
                        if (fingerId == gesture.finger0_id || fingerId == gesture.finger1_id) {
                            // One of the gesture fingers lifted - end gesture

                            Uint64 gestureDuration = SDL_GetTicks() - gesture.startTimeMs;
                            float endDistance = pointDistance(
                                gesture.finger0_currX * width, gesture.finger0_currY * height,
                                gesture.finger1_currX * width, gesture.finger1_currY * height
                            );
                            float distanceRatio = gesture.startDistance > 0 ? endDistance / gesture.startDistance : 1.0f;

                            // Check for two-finger tap (undo) - short duration, minimal movement
                            float move0 = pointDistance(
                                gesture.finger0_startX * width, gesture.finger0_startY * height,
                                gesture.finger0_currX * width, gesture.finger0_currY * height);
                            float move1 = pointDistance(
                                gesture.finger1_startX * width, gesture.finger1_startY * height,
                                gesture.finger1_currX * width, gesture.finger1_currY * height);
                            float maxMove = std::max(move0, move1);

                            if (gestureDuration < TAP_MAX_DURATION_MS && maxMove < TAP_MAX_MOVEMENT) {
                                // Two-finger tap detected - UNDO!
                                if (metal_stamp_can_undo()) {
                                    metal_stamp_undo();
                                    std::cout << " Two-finger tap: UNDO!" << std::endl;
                                } else {
                                    std::cout << " Two-finger tap: No undo available" << std::endl;
                                }
                            }
                            // Quick pinch/spread: short duration (<300ms) and significant distance change
                            else if (gestureDuration < 300) {
                                const float PINCH_THRESHOLD = 0.7f;
                                const float SPREAD_THRESHOLD = 1.4f;

                                if (distanceRatio < PINCH_THRESHOLD || distanceRatio > SPREAD_THRESHOLD) {
                                    // Start animated reset to default view
                                    resetAnim.isAnimating = true;
                                    resetAnim.startTimeMs = SDL_GetTicks();

                                    // Store current values as start
                                    resetAnim.startPanX = canvasTransform.panX;
                                    resetAnim.startPanY = canvasTransform.panY;
                                    resetAnim.startScale = canvasTransform.scale;
                                    resetAnim.startRotation = canvasTransform.rotation;

                                    // Target: default view
                                    resetAnim.targetPanX = 0.0f;
                                    resetAnim.targetPanY = 0.0f;
                                    resetAnim.targetScale = 1.0f;
                                    resetAnim.targetRotation = 0.0f;

                                    std::cout << " Quick-pinch: Animating to default view..." << std::endl;
                                }
                            }

                            gesture.isActive = false;
                            hasFinger0 = false;
                            std::cout << "Two-finger gesture ended (scale: " << canvasTransform.scale
                                      << ", rotation: " << (canvasTransform.rotation * 180.0f / M_PI) << ""
                                      << ", pan: " << canvasTransform.panX << ", " << canvasTransform.panY << ")" << std::endl;
                        }
                    }
                    // Handle single-finger drawing end (for simulator testing)
                    else if (is_drawing && hasFinger0 && fingerId == pendingFinger0_id) {
                        std::cout << "Finger drawing ended" << std::endl;
                        metal_stamp_undo_end_stroke();
                        is_drawing = false;
                        hasFinger0 = false;
                    }
                    // Handle pending single finger release (non-drawing)
                    else if (hasFinger0 && fingerId == pendingFinger0_id) {
                        hasFinger0 = false;
                    }
                    // Handle UI slider release
                    else if (sizeSlider.isDragging) {
                        sizeSlider.isDragging = false;
                        std::cout << "Size set to: " << (int)brushSize << "px" << std::endl;
                    } else if (opacitySlider.isDragging) {
                        opacitySlider.isDragging = false;
                        std::cout << "Opacity set to: " << (int)(brushOpacity * 100) << "%" << std::endl;
                    }
                    // Handle brush picker finger up - detect tap vs scroll
                    else if (g_brushPickerIsDragging && fingerId == g_brushPickerDragFingerId) {
                        float y = event.tfinger.y * height;
                        float x = event.tfinger.x * width;
                        float totalMovement = std::abs(y - g_brushPickerDragStartY);

                        // If minimal movement, treat as tap (select brush)
                        const float TAP_THRESHOLD = 15.0f;  // pixels
                        if (totalMovement < TAP_THRESHOLD) {
                            int brushIdx = getBrushAtPoint(brushPicker, x, y);
                            NSLog(@"[BrushPicker] Tap detected (moved %.1fpx), checking brush at (%.1f,%.1f) -> idx=%d",
                                  totalMovement, x, y, brushIdx);
                            if (brushIdx >= 0) {
                                g_selectedBrushIndex = brushIdx;
                                g_selectedBrushId = [[g_brushIds objectAtIndex:brushIdx] intValue];
                                [BrushImporter applyBrush:g_selectedBrushId];
                                NSLog(@"[BrushPicker] Selected brush %d from picker", brushIdx);
                                brushPicker.isOpen = false;  // Close picker after selection
                            }
                        } else {
                            NSLog(@"[BrushPicker] Scroll ended (moved %.1fpx), scroll=%.1f",
                                  totalMovement, g_brushPickerScrollOffset);
                        }

                        g_brushPickerIsDragging = false;
                    }
                    break;
                }

                // =============================================================
                // Apple Pencil / Stylus Events (SDL3 Pen API)
                // =============================================================

                case SDL_EVENT_PEN_AXIS: {
                    // Track pressure from axis events
                    if (event.paxis.axis == SDL_PEN_AXIS_PRESSURE) {
                        pen_pressure = event.paxis.value;
                        // Update pressure during active drawing
                        if (is_drawing) {
                            // Pressure is applied on next motion event
                        }
                    }
                    break;
                }

                case SDL_EVENT_PEN_DOWN: {
                    // Pen coordinates are in window points, need to convert to pixels
                    float screenX = event.ptouch.x * pixelDensity;
                    float screenY = event.ptouch.y * pixelDensity;
                    // pen_pressure is set via SDL_EVENT_PEN_AXIS events
                    if (pen_pressure <= 0.0f) pen_pressure = 1.0f;

                    NSLog(@"[PEN] DOWN: raw(%.1f,%.1f) * %.1f = screen(%.1f,%.1f) pressure=%.2f",
                          event.ptouch.x, event.ptouch.y, pixelDensity, screenX, screenY, pen_pressure);

                    // Check if touch is on a slider (UI is in screen space, not canvas space)
                    float sliderHitPadding = 30.0f;
                    SliderConfig expandedSize = sizeSlider;
                    expandedSize.x -= sliderHitPadding;
                    expandedSize.width += sliderHitPadding * 2;
                    expandedSize.y -= sliderHitPadding;
                    expandedSize.height += sliderHitPadding * 2;

                    SliderConfig expandedOpacity = opacitySlider;
                    expandedOpacity.x -= sliderHitPadding;
                    expandedOpacity.width += sliderHitPadding * 2;
                    expandedOpacity.y -= sliderHitPadding;
                    expandedOpacity.height += sliderHitPadding * 2;

                    if (isPointInSlider(expandedSize, screenX, screenY)) {
                        sizeSlider.isDragging = true;
                        float relY = (screenY - sizeSlider.y) / sizeSlider.height;
                        sizeSlider.value = 1.0f - std::max(0.0f, std::min(1.0f, relY));
                        brushSize = sizeSlider.minVal + sizeSlider.value * (sizeSlider.maxVal - sizeSlider.minVal);
                        metal_stamp_set_brush_size(brushSize);
                        std::cout << "Size slider (pen): " << (int)brushSize << "px" << std::endl;
                    } else if (isPointInSlider(expandedOpacity, screenX, screenY)) {
                        opacitySlider.isDragging = true;
                        float relY = (screenY - opacitySlider.y) / opacitySlider.height;
                        opacitySlider.value = 1.0f - std::max(0.0f, std::min(1.0f, relY));
                        brushOpacity = opacitySlider.minVal + opacitySlider.value * (opacitySlider.maxVal - opacitySlider.minVal);
                        metal_stamp_set_brush_opacity(brushOpacity);
                        std::cout << "Opacity slider (pen): " << (int)(brushOpacity * 100) << "%" << std::endl;
                    } else if (isPointInColorPicker(colorPicker, screenX, screenY)) {
                        // Check if tapped a color swatch (pen)
                        int swatchIdx = getSwatchAtPoint(colorPicker, screenX, screenY);
                        if (swatchIdx >= 0) {
                            int col = swatchIdx % COLOR_GRID_COLS;
                            int row = swatchIdx / COLOR_GRID_COLS;
                            getGridColor(col, row, colorPicker.currentR, colorPicker.currentG, colorPicker.currentB);
                            metal_stamp_set_brush_color(colorPicker.currentR, colorPicker.currentG, colorPicker.currentB, 1.0f);
                            colorPicker.isOpen = false;
                            std::cout << "Color selected from picker (pen)" << std::endl;
                        }
                    } else if (isPointInColorButton(colorButton, screenX, screenY)) {
                        // Toggle color picker panel (pen)
                        colorPicker.isOpen = !colorPicker.isOpen;
                        std::cout << "Color picker " << (colorPicker.isOpen ? "opened" : "closed") << " (pen)" << std::endl;
                    } else if (colorPicker.isOpen) {
                        // Tap outside picker closes it (pen)
                        colorPicker.isOpen = false;
                        std::cout << "Color picker closed (tap outside, pen)" << std::endl;
                    } else if (isPointInTextureButton(shapeTextureButton, screenX, screenY)) {
                        // Show shape texture picker (pen)
                        std::cout << "Shape texture button tapped (pen) - showing picker" << std::endl;
                        showTexturePicker(window, TextureTypeShape);
                    } else if (isPointInTextureButton(grainTextureButton, screenX, screenY)) {
                        // Show grain texture picker (pen)
                        std::cout << "Grain texture button tapped (pen) - showing picker" << std::endl;
                        showTexturePicker(window, TextureTypeGrain);
                    } else if (isPointInBrushPicker(brushPicker, screenX, screenY)) {
                        // Handle tap on brush picker (pen)
                        int brushIdx = getBrushAtPoint(brushPicker, screenX, screenY);
                        NSLog(@"[BrushPicker] DEBUG (pen): tap(%.1f,%.1f) brushIdx=%d", screenX, screenY, brushIdx);
                        if (brushIdx >= 0) {
                            g_selectedBrushIndex = brushIdx;
                            g_selectedBrushId = [[g_brushIds objectAtIndex:brushIdx] intValue];
                            [BrushImporter applyBrush:g_selectedBrushId];
                            NSLog(@"[BrushPicker] Selected brush %d from picker (pen)", brushIdx);
                            brushPicker.isOpen = false;
                        }
                    } else if (isPointInBrushButton(brushButton, screenX, screenY)) {
                        // Toggle brush picker open/closed (pen)
                        brushPicker.isOpen = !brushPicker.isOpen;
                        NSLog(@"[BrushPicker] %s (pen)", brushPicker.isOpen ? "Opened" : "Closed");
                    } else if (isPointInEraserButton(eraserButton, screenX, screenY)) {
                        // Toggle eraser mode (pen)
                        g_eraserMode = !g_eraserMode;
                        if (g_eraserMode) {
                            metal_stamp_set_brush_color(1.0f, 1.0f, 1.0f, 1.0f);
                            NSLog(@"[Eraser] Eraser mode ON (pen)");
                        } else {
                            metal_stamp_set_brush_color(colorPicker.currentR, colorPicker.currentG, colorPicker.currentB, 1.0f);
                            NSLog(@"[Eraser] Eraser mode OFF (pen)");
                        }
                    } else if (brushPicker.isOpen) {
                        // Tap outside picker closes it (pen)
                        brushPicker.isOpen = false;
                        NSLog(@"[BrushPicker] Closed (tap outside, pen)");
                    } else {
                        // Drawing with Apple Pencil - convert screen coords to canvas coords
                        float canvasX, canvasY;
                        screenToCanvas(screenX, screenY, canvasTransform, width, height, canvasX, canvasY);

                        metal_stamp_undo_begin_stroke(canvasX, canvasY, pen_pressure);
                        last_x = canvasX;
                        last_y = canvasY;
                        is_drawing = true;
                    }
                    break;
                }

                case SDL_EVENT_PEN_MOTION: {
                    // Pen coordinates are in window points, need to convert to pixels
                    float screenX = event.pmotion.x * pixelDensity;
                    float screenY = event.pmotion.y * pixelDensity;
                    // pen_pressure is updated via SDL_EVENT_PEN_AXIS events
                    if (pen_pressure <= 0.0f) pen_pressure = 1.0f;

                    if (sizeSlider.isDragging) {
                        float relY = (screenY - sizeSlider.y) / sizeSlider.height;
                        sizeSlider.value = 1.0f - std::max(0.0f, std::min(1.0f, relY));
                        brushSize = sizeSlider.minVal + sizeSlider.value * (sizeSlider.maxVal - sizeSlider.minVal);
                        metal_stamp_set_brush_size(brushSize);
                    } else if (opacitySlider.isDragging) {
                        float relY = (screenY - opacitySlider.y) / opacitySlider.height;
                        opacitySlider.value = 1.0f - std::max(0.0f, std::min(1.0f, relY));
                        brushOpacity = opacitySlider.minVal + opacitySlider.value * (opacitySlider.maxVal - opacitySlider.minVal);
                        metal_stamp_set_brush_opacity(brushOpacity);
                    } else if (is_drawing) {
                        // Convert screen coords to canvas coords for drawing
                        float canvasX, canvasY;
                        screenToCanvas(screenX, screenY, canvasTransform, width, height, canvasX, canvasY);

                        float dx = canvasX - last_x;
                        float dy = canvasY - last_y;
                        if (dx*dx + dy*dy > 1.0f) {
                            metal_stamp_undo_add_stroke_point(canvasX, canvasY, pen_pressure);
                            last_x = canvasX;
                            last_y = canvasY;
                        }
                    }
                    break;
                }

                case SDL_EVENT_PEN_UP: {
                    if (sizeSlider.isDragging) {
                        sizeSlider.isDragging = false;
                        std::cout << "Size set to (pen): " << (int)brushSize << "px" << std::endl;
                    } else if (opacitySlider.isDragging) {
                        opacitySlider.isDragging = false;
                        std::cout << "Opacity set to (pen): " << (int)(brushOpacity * 100) << "%" << std::endl;
                    } else if (is_drawing) {
                        std::cout << "Pen up - ending stroke" << std::endl;
                        metal_stamp_undo_end_stroke();
                        is_drawing = false;
                    }
                    pen_pressure = 1.0f;  // Reset pressure
                    break;
                }

                // NOTE: On iOS simulator, mouse events also fire alongside finger events
                // but with different coordinates (pixels vs normalized). We only handle
                // finger events to avoid duplicate strokes.
                // Mouse events are commented out for iOS:
                /*
                case SDL_EVENT_MOUSE_BUTTON_DOWN: {
                    float x = event.button.x;
                    float y = event.button.y;
                    std::cout << "Mouse down: " << x << ", " << y << std::endl;
                    metal_stamp_undo_begin_stroke(x, y, 1.0f);
                    is_drawing = true;
                    break;
                }

                case SDL_EVENT_MOUSE_MOTION: {
                    if (is_drawing) {
                        float x = event.motion.x;
                        float y = event.motion.y;
                        metal_stamp_undo_add_stroke_point(x, y, 1.0f);
                    }
                    break;
                }

                case SDL_EVENT_MOUSE_BUTTON_UP: {
                    if (is_drawing) {
                        std::cout << "Mouse up - ending stroke" << std::endl;
                        metal_stamp_undo_end_stroke();
                        is_drawing = false;
                    }
                    break;
                }
                */
            }
        }

        // Render the current stroke (for real-time preview)
        metal_stamp_render_stroke();

        // Update canvas reset animation (Procreate-style smooth snap)
        if (resetAnim.isAnimating) {
            Uint64 elapsed = SDL_GetTicks() - resetAnim.startTimeMs;
            float t = (float)elapsed / resetAnim.durationMs;

            if (t >= 1.0f) {
                // Animation complete
                t = 1.0f;
                resetAnim.isAnimating = false;
                std::cout << " Canvas reset animation complete" << std::endl;
            }

            // Apply easing
            float easedT = easeOutCubic(t);

            // Interpolate all transform values
            canvasTransform.panX = lerp(resetAnim.startPanX, resetAnim.targetPanX, easedT);
            canvasTransform.panY = lerp(resetAnim.startPanY, resetAnim.targetPanY, easedT);
            canvasTransform.scale = lerp(resetAnim.startScale, resetAnim.targetScale, easedT);
            canvasTransform.rotation = lerpAngle(resetAnim.startRotation, resetAnim.targetRotation, easedT);
        }

        // Apply canvas transform before presenting
        metal_stamp_set_canvas_transform(
            canvasTransform.panX, canvasTransform.panY,
            canvasTransform.scale, canvasTransform.rotation,
            canvasTransform.pivotX, canvasTransform.pivotY
        );

        // Draw UI sliders (queued before present)
        // Size slider - blue tint
        drawVerticalSlider(sizeSlider, height, 0.3f, 0.5f, 0.9f, "Size");
        // Opacity slider - gray/white tint
        drawVerticalSlider(opacitySlider, height, 0.6f, 0.6f, 0.6f, "Opacity");
        // Color picker button
        drawColorButton(colorButton, colorPicker);
        // Color picker panel (if open)
        drawColorPicker(colorPicker);

        // Texture buttons (bottom center)
        drawTextureButton(shapeTextureButton, "Shape");
        drawTextureButton(grainTextureButton, "Grain");

        // Brush picker button
        drawBrushButton(brushButton);

        // Eraser toggle button
        drawEraserButton(eraserButton, g_eraserMode);

        // Brush picker panel (if open)
        drawBrushPicker(brushPicker, height);

        // Present with UI overlay
        metal_stamp_present();

        // Small delay to avoid busy-waiting
        SDL_Delay(1);
    }

    // Cleanup
    metal_stamp_cleanup();
    SDL_DestroyWindow(window);

    return 0;
}

#endif  // METAL_TEST_MODE

// =============================================================================
// Main Entry Point
// =============================================================================

extern "C" int drawing_mobile_main(int argc, char* argv[]) {
    std::cout << "========================================" << std::endl;
    std::cout << "   Drawing Canvas - iOS" << std::endl;
    std::cout << "========================================" << std::endl;

#if METAL_TEST_MODE
    // Pure C++ Metal test mode
    return metal_test_main();
#else
    // Initialize jank runtime on a large stack thread
    if (!init_jank_runtime_on_large_stack()) {
        std::cerr << "[drawing_mobile] Failed to initialize jank" << std::endl;
        return 1;
    }

    // Call the jank main function
    call_jank_main_impl();

    std::cout << "[drawing_mobile] App finished" << std::endl;
    return 0;
#endif
}
