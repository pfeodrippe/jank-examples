// Drawing Mobile iOS - jank-powered drawing app
// Uses SDL3 + Metal via drawing_canvas.hpp singleton

// Define METAL_TEST_MODE to bypass jank and test Metal directly
#define METAL_TEST_MODE 1

#import <Foundation/Foundation.h>
#import <UIKit/UIKit.h>
#include <iostream>
#include <sstream>
#include <string>
#include <mutex>
#include <condition_variable>
#include <pthread.h>
#include <algorithm>  // For std::max, std::min

#include <SDL3/SDL.h>
#include "../src/vybe/app/drawing/native/metal_renderer.h"

// jank runtime headers
// iOS defines 'nil' as a macro which conflicts with jank's object_type::nil
#pragma push_macro("nil")
#undef nil
#include <gc.h>
#include <jank/runtime/context.hpp>
#include <jank/runtime/core.hpp>
#include <jank/runtime/core/make_box.hpp>
#include <jank/runtime/behavior/callable.hpp>
#include <jank/runtime/module/loader.hpp>
#include <jank/error.hpp>

// iOS JIT support
#if defined(JANK_IOS_JIT)
#include <jank/ios/eval_server.hpp>
#include <jank/compile_server/remote_compile.hpp>
extern "C" void jank_debug_print_sizeof();
#endif

#pragma pop_macro("nil")

// =============================================================================
// jank Integration (following SdfViewerMobile pattern)
// =============================================================================

// External AOT init function generated by ios-bundle
extern "C" void jank_aot_init();

static bool jank_initialized = false;

#if defined(JANK_IOS_JIT)
// Hybrid JIT mode: AOT core libs + JIT user code
static bool load_jank_modules_jit() {
    std::cout << "[drawing_mobile] Loading AOT core modules..." << std::endl;

    // jank_aot_init() loads:
    // 1. clojure.core-native, clojure.core, other core libs
    // 2. nREPL native module (jank.nrepl-server.asio) - inserted by ios-bundle when JANK_IOS_JIT
    // 3. application modules
    jank_aot_init();

    std::cout << "[drawing_mobile] All modules loaded! Ready for REPL." << std::endl;
    return true;
}
#endif

// Forward declaration for large-stack wrapper
static bool init_jank_runtime_impl();

// Large stack wrapper for running jank on iOS
// iOS main thread has only ~1MB stack, but jank's recursive codegen needs more.
struct jank_init_result {
    std::mutex mtx;
    std::condition_variable cv;
    bool done = false;
    bool success = false;
};

static void* jank_init_thread_func(void* arg) {
    auto* result = static_cast<jank_init_result*>(arg);

    bool success = init_jank_runtime_impl();

    {
        std::lock_guard<std::mutex> lock(result->mtx);
        result->success = success;
        result->done = true;
    }
    result->cv.notify_one();
    return nullptr;
}

static bool init_jank_runtime_on_large_stack() {
    constexpr size_t STACK_SIZE = 8 * 1024 * 1024; // 8MB stack

    // Initialize GC on main thread FIRST - before creating worker thread
    std::cout << "[drawing_mobile] Initializing Boehm GC on main thread..." << std::endl;
    GC_init();

    // CRITICAL: Disable GC during worker thread execution to avoid
    // "Collecting from unknown thread" errors.
    std::cout << "[drawing_mobile] Disabling GC during initialization..." << std::endl;
    GC_disable();

    pthread_attr_t attr;
    pthread_attr_init(&attr);
    pthread_attr_setstacksize(&attr, STACK_SIZE);

    jank_init_result result;
    pthread_t thread;

    std::cout << "[drawing_mobile] Starting initialization on thread with " << (STACK_SIZE / 1024 / 1024) << "MB stack..." << std::endl;

    int err = pthread_create(&thread, &attr, jank_init_thread_func, &result);
    pthread_attr_destroy(&attr);

    if (err != 0) {
        std::cerr << "[drawing_mobile] Failed to create large-stack thread: " << err << std::endl;
        // Fall back to running on current thread (re-enable GC first)
        GC_enable();
        return init_jank_runtime_impl();
    }

    // Wait for the thread to complete
    {
        std::unique_lock<std::mutex> lock(result.mtx);
        result.cv.wait(lock, [&result] { return result.done; });
    }

    pthread_join(thread, nullptr);

    // Re-enable GC now that initialization is complete
    std::cout << "[drawing_mobile] Re-enabling GC after initialization..." << std::endl;
    GC_enable();

    return result.success;
}

// Initialize jank runtime for iOS (actual implementation)
// NOTE: GC_init() is called by init_jank_runtime_on_large_stack() before this
static bool init_jank_runtime_impl() {
    try {
        std::cout << "[drawing_mobile] Creating runtime context..." << std::endl;
        jank::runtime::__rt_ctx = new (GC_malloc(sizeof(jank::runtime::context)))
            jank::runtime::context{};

#if defined(JANK_IOS_JIT)
        // Print sizeof for key types to help diagnose ABI mismatches
        jank_debug_print_sizeof();

        // Configure and connect to remote compile server on macOS
#if TARGET_OS_SIMULATOR
        std::string const remote_host = "127.0.0.1";
        uint16_t const remote_port = 5572;  // DrawingMobile simulator uses port 5572
#else
        // Device needs Mac's actual IP - update for your network!
        std::string const remote_host = "192.168.2.25";
        uint16_t const remote_port = 5573;  // DrawingMobile device uses port 5573
#endif

        std::cout << "[drawing_mobile] Configuring remote compile server at " << remote_host << ":" << remote_port << "..." << std::endl;
        jank::compile_server::configure_remote_compile(remote_host, remote_port);

        if (jank::compile_server::connect_remote_compile()) {
            std::cout << "[drawing_mobile] Connected to remote compile server!" << std::endl;
        } else {
            std::cout << "[drawing_mobile] Warning: Could not connect to remote compile server." << std::endl;
        }

        // JIT mode: Load modules from bundled source files
        std::cout << "[drawing_mobile] JIT mode - loading modules from source..." << std::endl;
        if (!load_jank_modules_jit()) {
            std::cerr << "[drawing_mobile] JIT module loading failed" << std::endl;
            return false;
        }
#else
        // AOT mode: Load all modules via auto-generated init function
        jank_aot_init();
#endif

        jank_initialized = true;
        std::cout << "[drawing_mobile] Runtime initialized successfully!" << std::endl;
        return true;
    } catch (jtl::ref<jank::error::base> const& e) {
        std::cerr << "[drawing_mobile] Error initializing runtime: " << e->message << std::endl;
        if (e->cause) {
            std::cerr << "[drawing_mobile]   caused by: " << e->cause->message << std::endl;
        }
        return false;
    } catch (const std::exception& e) {
        std::cerr << "[drawing_mobile] Error initializing runtime (std): " << e.what() << std::endl;
        return false;
    }
}

// Call the jank-exported -main function
static void call_jank_main_impl() {
    try {
        // Set up thread bindings (required for dynamic vars like *ns*)
        jank::runtime::context::binding_scope bindings;

        // Find clojure.core/require
        auto require_var = jank::runtime::__rt_ctx->find_var(
            jank::runtime::make_box<jank::runtime::obj::symbol>("clojure.core/require")
        );
        if (require_var.is_nil()) {
            std::cerr << "[drawing_mobile] Could not find clojure.core/require" << std::endl;
            return;
        }

        // Call (require 'vybe.app.drawing)
        std::cout << "[drawing_mobile] Loading vybe.app.drawing..." << std::endl;
        jank::runtime::dynamic_call(
            require_var->deref(),
            jank::runtime::make_box<jank::runtime::obj::symbol>("vybe.app.drawing")
        );
        std::cout << "[drawing_mobile] vybe.app.drawing loaded!" << std::endl;

        // Find and call -main
        auto main_var = jank::runtime::__rt_ctx->intern_var("vybe.app.drawing", "-main");
        if (!main_var.is_ok()) {
            std::cerr << "[drawing_mobile] Could not find vybe.app.drawing/-main" << std::endl;
            return;
        }

        std::cout << "[drawing_mobile] Calling vybe.app.drawing/-main with nREPL port 5581..." << std::endl;
        jank::runtime::dynamic_call(
            main_var.expect_ok()->deref(),
            jank::runtime::make_box<jank::runtime::obj::integer>(5581)
        );

    } catch (jtl::ref<jank::error::base> const& e) {
        std::cerr << "\n";
        std::cerr << "=== jank Runtime Error ===" << std::endl;
        std::cerr << e->message << std::endl;
        if (e->source.file != jank::read::no_source_path) {
            std::cerr << "at " << e->source.to_string() << std::endl;
        }
        if (e->cause) {
            std::cerr << "caused by: " << e->cause->message << std::endl;
        }
    } catch (std::exception& e) {
        std::cerr << "[drawing_mobile] Failed to run app: " << e.what() << std::endl;
    }
}

// =============================================================================
// Metal Test Mode - Pure C++ SDL + Metal rendering (no jank)
// =============================================================================

#if METAL_TEST_MODE

// =============================================================================
// UI Slider Configuration
// =============================================================================

struct SliderConfig {
    float x, y;           // Position (top-left)
    float width, height;  // Size
    float value;          // Current value (0.0 - 1.0)
    float minVal, maxVal; // Value range
    bool isDragging;
};

// =============================================================================
// Color Picker Configuration
// =============================================================================

struct ColorPreset {
    float r, g, b;
    const char* name;
};

// Procreate-style color presets
static const ColorPreset COLOR_PRESETS[] = {
    {0.15f, 0.45f, 0.75f, "Blue"},       // Nice blue crayon (default)
    {0.85f, 0.25f, 0.25f, "Red"},        // Red
    {0.25f, 0.75f, 0.35f, "Green"},      // Green
    {0.95f, 0.75f, 0.15f, "Yellow"},     // Yellow/Gold
    {0.65f, 0.25f, 0.85f, "Purple"},     // Purple
    {0.95f, 0.55f, 0.15f, "Orange"},     // Orange
    {0.15f, 0.15f, 0.15f, "Black"},      // Near-black
    {0.55f, 0.35f, 0.25f, "Brown"},      // Brown
    {0.95f, 0.55f, 0.65f, "Pink"},       // Pink
    {0.25f, 0.75f, 0.85f, "Cyan"},       // Cyan/Teal
};
static const int NUM_COLOR_PRESETS = sizeof(COLOR_PRESETS) / sizeof(COLOR_PRESETS[0]);

struct ColorButtonConfig {
    float x, y;           // Position (center)
    float size;           // Diameter
    int currentColorIndex;
};

// Check if point is inside color button
static bool isPointInColorButton(const ColorButtonConfig& btn, float px, float py) {
    float dx = px - (btn.x + btn.size / 2.0f);
    float dy = py - (btn.y + btn.size / 2.0f);
    return (dx*dx + dy*dy) <= (btn.size/2.0f * btn.size/2.0f);
}

// Draw color picker button (shows current color)
static void drawColorButton(const ColorButtonConfig& btn) {
    const ColorPreset& color = COLOR_PRESETS[btn.currentColorIndex];

    // Outer ring (white)
    metal_stamp_queue_ui_rect(btn.x, btn.y, btn.size, btn.size,
                              1.0f, 1.0f, 1.0f, 1.0f, btn.size / 2.0f);

    // Inner color circle
    float innerMargin = 4.0f;
    float innerSize = btn.size - innerMargin * 2;
    metal_stamp_queue_ui_rect(btn.x + innerMargin, btn.y + innerMargin, innerSize, innerSize,
                              color.r, color.g, color.b, 1.0f, innerSize / 2.0f);
}

// Check if point is inside slider track area
static bool isPointInSlider(const SliderConfig& slider, float px, float py) {
    return px >= slider.x && px <= slider.x + slider.width &&
           py >= slider.y && py <= slider.y + slider.height;
}

// Draw a vertical slider (Procreate-style)
static void drawVerticalSlider(const SliderConfig& slider, int screenHeight,
                               float r, float g, float b, const char* label) {
    // Slider track background (dark semi-transparent)
    metal_stamp_queue_ui_rect(slider.x, slider.y, slider.width, slider.height,
                              0.2f, 0.2f, 0.2f, 0.7f, 10.0f);

    // Filled portion (shows current value)
    float fillHeight = slider.height * slider.value;
    float fillY = slider.y + slider.height - fillHeight;
    if (fillHeight > 0) {
        metal_stamp_queue_ui_rect(slider.x, fillY, slider.width, fillHeight,
                                  r, g, b, 0.9f, 10.0f);
    }

    // Slider knob/handle
    float knobSize = slider.width * 1.3f;
    float knobX = slider.x + slider.width / 2.0f - knobSize / 2.0f;
    float knobY = fillY - knobSize / 2.0f;
    metal_stamp_queue_ui_rect(knobX, knobY, knobSize, knobSize,
                              1.0f, 1.0f, 1.0f, 1.0f, knobSize / 2.0f);

    // Inner knob circle (colored)
    float innerSize = knobSize * 0.7f;
    float innerX = knobX + (knobSize - innerSize) / 2.0f;
    float innerY = knobY + (knobSize - innerSize) / 2.0f;
    metal_stamp_queue_ui_rect(innerX, innerY, innerSize, innerSize,
                              r, g, b, 1.0f, innerSize / 2.0f);
}

static int metal_test_main() {
    std::cout << "========================================" << std::endl;
    std::cout << "   METAL TEST MODE - Pure C++ Rendering" << std::endl;
    std::cout << "========================================" << std::endl;

    // Create SDL window
    SDL_Window* window = SDL_CreateWindow(
        "Metal Test",
        1024, 768,
        SDL_WINDOW_METAL | SDL_WINDOW_HIGH_PIXEL_DENSITY
    );

    if (!window) {
        std::cerr << "Failed to create window: " << SDL_GetError() << std::endl;
        return 1;
    }

    int width, height;
    SDL_GetWindowSizeInPixels(window, &width, &height);
    std::cout << "Window size: " << width << "x" << height << std::endl;

    // Initialize Metal renderer
    std::cout << "Initializing Metal stamp renderer..." << std::endl;
    if (!metal_stamp_init(window, width, height)) {
        std::cerr << "Failed to initialize Metal renderer!" << std::endl;
        SDL_DestroyWindow(window);
        return 1;
    }
    std::cout << "Metal renderer initialized!" << std::endl;

    // =============================================================================
    // Initialize UI Sliders (Procreate-style vertical sliders on left edge)
    // =============================================================================

    const float SLIDER_WIDTH = 60.0f;
    const float SLIDER_HEIGHT = 300.0f;
    const float SLIDER_MARGIN = 40.0f;
    const float SLIDER_SPACING = 30.0f;

    SliderConfig sizeSlider = {
        .x = SLIDER_MARGIN,
        .y = height / 2.0f - SLIDER_HEIGHT - SLIDER_SPACING / 2.0f,
        .width = SLIDER_WIDTH,
        .height = SLIDER_HEIGHT,
        .value = 0.25f,  // 25% = 50px brush (range 10-200)
        .minVal = 10.0f,
        .maxVal = 200.0f,
        .isDragging = false
    };

    SliderConfig opacitySlider = {
        .x = SLIDER_MARGIN,
        .y = height / 2.0f + SLIDER_SPACING / 2.0f,
        .width = SLIDER_WIDTH,
        .height = SLIDER_HEIGHT,
        .value = 0.9f,  // 90% opacity
        .minVal = 0.0f,
        .maxVal = 1.0f,
        .isDragging = false
    };

    // =============================================================================
    // Initialize Color Button (positioned below sliders)
    // =============================================================================

    const float COLOR_BUTTON_SIZE = 70.0f;
    ColorButtonConfig colorButton = {
        .x = SLIDER_MARGIN - (COLOR_BUTTON_SIZE - SLIDER_WIDTH) / 2.0f,  // Center under sliders
        .y = opacitySlider.y + opacitySlider.height + SLIDER_SPACING,
        .size = COLOR_BUTTON_SIZE,
        .currentColorIndex = 0  // Start with blue
    };

    // Calculate initial brush values from slider positions
    float brushSize = sizeSlider.minVal + sizeSlider.value * (sizeSlider.maxVal - sizeSlider.minVal);
    float brushOpacity = opacitySlider.minVal + opacitySlider.value * (opacitySlider.maxVal - opacitySlider.minVal);

    // Get current color from presets
    const ColorPreset& initialColor = COLOR_PRESETS[colorButton.currentColorIndex];

    // Set brush settings - Huntsman Crayon with pressure dynamics
    metal_stamp_set_brush_type(1);  // Crayon brush!
    metal_stamp_set_brush_size(brushSize);
    metal_stamp_set_brush_hardness(0.35f);  // Crayon hardness
    metal_stamp_set_brush_opacity(brushOpacity);
    metal_stamp_set_brush_spacing(0.06f);  // Tight spacing for smooth strokes
    metal_stamp_set_brush_grain_scale(1.8f);  // Visible paper grain
    metal_stamp_set_brush_color(initialColor.r, initialColor.g, initialColor.b, 1.0f);

    // Pressure dynamics - Apple Pencil / touch pressure affects stroke
    metal_stamp_set_brush_size_pressure(0.8f);    // Pressure strongly affects size
    metal_stamp_set_brush_opacity_pressure(0.3f); // Pressure slightly affects opacity

    // Scatter and jitter for organic crayon feel
    metal_stamp_set_brush_scatter(3.0f);          // Subtle scatter perpendicular to stroke
    metal_stamp_set_brush_size_jitter(0.15f);     // Subtle size variation (15%)
    metal_stamp_set_brush_opacity_jitter(0.1f);   // Subtle opacity variation (10%)

    // Clear canvas to white
    metal_stamp_clear_canvas(1.0f, 1.0f, 1.0f, 1.0f);

    // Track drawing state
    bool is_drawing = false;
    float last_x = 0, last_y = 0;
    float pen_pressure = 1.0f;  // Track Apple Pencil pressure from axis events

    // Main loop
    bool running = true;
    while (running) {
        SDL_Event event;
        while (SDL_PollEvent(&event)) {
            switch (event.type) {
                case SDL_EVENT_QUIT:
                    running = false;
                    break;

                case SDL_EVENT_FINGER_DOWN: {
                    // Convert normalized coords to screen pixels
                    float x = event.tfinger.x * width;
                    float y = event.tfinger.y * height;
                    float pressure = event.tfinger.pressure;
                    if (pressure <= 0.0f) pressure = 1.0f;  // Default pressure

                    // Check if touch is on a slider (with expanded hit area)
                    float sliderHitPadding = 30.0f;
                    SliderConfig expandedSize = sizeSlider;
                    expandedSize.x -= sliderHitPadding;
                    expandedSize.width += sliderHitPadding * 2;
                    expandedSize.y -= sliderHitPadding;
                    expandedSize.height += sliderHitPadding * 2;

                    SliderConfig expandedOpacity = opacitySlider;
                    expandedOpacity.x -= sliderHitPadding;
                    expandedOpacity.width += sliderHitPadding * 2;
                    expandedOpacity.y -= sliderHitPadding;
                    expandedOpacity.height += sliderHitPadding * 2;

                    if (isPointInSlider(expandedSize, x, y)) {
                        sizeSlider.isDragging = true;
                        // Update value based on Y position
                        float relY = (y - sizeSlider.y) / sizeSlider.height;
                        sizeSlider.value = 1.0f - std::max(0.0f, std::min(1.0f, relY));
                        brushSize = sizeSlider.minVal + sizeSlider.value * (sizeSlider.maxVal - sizeSlider.minVal);
                        metal_stamp_set_brush_size(brushSize);
                        std::cout << "Size slider: " << (int)brushSize << "px" << std::endl;
                    } else if (isPointInSlider(expandedOpacity, x, y)) {
                        opacitySlider.isDragging = true;
                        float relY = (y - opacitySlider.y) / opacitySlider.height;
                        opacitySlider.value = 1.0f - std::max(0.0f, std::min(1.0f, relY));
                        brushOpacity = opacitySlider.minVal + opacitySlider.value * (opacitySlider.maxVal - opacitySlider.minVal);
                        metal_stamp_set_brush_opacity(brushOpacity);
                        std::cout << "Opacity slider: " << (int)(brushOpacity * 100) << "%" << std::endl;
                    } else if (isPointInColorButton(colorButton, x, y)) {
                        // Cycle to next color preset
                        colorButton.currentColorIndex = (colorButton.currentColorIndex + 1) % NUM_COLOR_PRESETS;
                        const ColorPreset& newColor = COLOR_PRESETS[colorButton.currentColorIndex];
                        metal_stamp_set_brush_color(newColor.r, newColor.g, newColor.b, 1.0f);
                        std::cout << "Color changed to: " << newColor.name << std::endl;
                    } else {
                        // Regular drawing
                        std::cout << "Touch down: " << x << ", " << y << " (pressure: " << pressure << ")" << std::endl;
                        metal_stamp_begin_stroke(x, y, pressure);
                        last_x = x;
                        last_y = y;
                        is_drawing = true;
                    }
                    break;
                }

                case SDL_EVENT_FINGER_MOTION: {
                    float x = event.tfinger.x * width;
                    float y = event.tfinger.y * height;
                    float pressure = event.tfinger.pressure;
                    if (pressure <= 0.0f) pressure = 1.0f;

                    if (sizeSlider.isDragging) {
                        float relY = (y - sizeSlider.y) / sizeSlider.height;
                        sizeSlider.value = 1.0f - std::max(0.0f, std::min(1.0f, relY));
                        brushSize = sizeSlider.minVal + sizeSlider.value * (sizeSlider.maxVal - sizeSlider.minVal);
                        metal_stamp_set_brush_size(brushSize);
                    } else if (opacitySlider.isDragging) {
                        float relY = (y - opacitySlider.y) / opacitySlider.height;
                        opacitySlider.value = 1.0f - std::max(0.0f, std::min(1.0f, relY));
                        brushOpacity = opacitySlider.minVal + opacitySlider.value * (opacitySlider.maxVal - opacitySlider.minVal);
                        metal_stamp_set_brush_opacity(brushOpacity);
                    } else if (is_drawing) {
                        // Only add point if moved more than 1 pixel (avoid spurious motion events)
                        float dx = x - last_x;
                        float dy = y - last_y;
                        if (dx*dx + dy*dy > 1.0f) {
                            metal_stamp_add_stroke_point(x, y, pressure);
                            last_x = x;
                            last_y = y;
                        }
                    }
                    break;
                }

                case SDL_EVENT_FINGER_UP: {
                    if (sizeSlider.isDragging) {
                        sizeSlider.isDragging = false;
                        std::cout << "Size set to: " << (int)brushSize << "px" << std::endl;
                    } else if (opacitySlider.isDragging) {
                        opacitySlider.isDragging = false;
                        std::cout << "Opacity set to: " << (int)(brushOpacity * 100) << "%" << std::endl;
                    } else if (is_drawing) {
                        std::cout << "Touch up - ending stroke" << std::endl;
                        metal_stamp_end_stroke();
                        is_drawing = false;
                    }
                    break;
                }

                // =============================================================
                // Apple Pencil / Stylus Events (SDL3 Pen API)
                // =============================================================

                case SDL_EVENT_PEN_AXIS: {
                    // Track pressure from axis events
                    if (event.paxis.axis == SDL_PEN_AXIS_PRESSURE) {
                        pen_pressure = event.paxis.value;
                        // Update pressure during active drawing
                        if (is_drawing) {
                            // Pressure is applied on next motion event
                        }
                    }
                    break;
                }

                case SDL_EVENT_PEN_DOWN: {
                    float x = event.ptouch.x;
                    float y = event.ptouch.y;
                    // pen_pressure should have been set by preceding axis events
                    if (pen_pressure <= 0.0f) pen_pressure = 1.0f;

                    std::cout << "Pen down: " << x << ", " << y << " (pressure: " << pen_pressure << ")" << std::endl;

                    // Check if touch is on a slider
                    float sliderHitPadding = 30.0f;
                    SliderConfig expandedSize = sizeSlider;
                    expandedSize.x -= sliderHitPadding;
                    expandedSize.width += sliderHitPadding * 2;
                    expandedSize.y -= sliderHitPadding;
                    expandedSize.height += sliderHitPadding * 2;

                    SliderConfig expandedOpacity = opacitySlider;
                    expandedOpacity.x -= sliderHitPadding;
                    expandedOpacity.width += sliderHitPadding * 2;
                    expandedOpacity.y -= sliderHitPadding;
                    expandedOpacity.height += sliderHitPadding * 2;

                    if (isPointInSlider(expandedSize, x, y)) {
                        sizeSlider.isDragging = true;
                        float relY = (y - sizeSlider.y) / sizeSlider.height;
                        sizeSlider.value = 1.0f - std::max(0.0f, std::min(1.0f, relY));
                        brushSize = sizeSlider.minVal + sizeSlider.value * (sizeSlider.maxVal - sizeSlider.minVal);
                        metal_stamp_set_brush_size(brushSize);
                        std::cout << "Size slider (pen): " << (int)brushSize << "px" << std::endl;
                    } else if (isPointInSlider(expandedOpacity, x, y)) {
                        opacitySlider.isDragging = true;
                        float relY = (y - opacitySlider.y) / opacitySlider.height;
                        opacitySlider.value = 1.0f - std::max(0.0f, std::min(1.0f, relY));
                        brushOpacity = opacitySlider.minVal + opacitySlider.value * (opacitySlider.maxVal - opacitySlider.minVal);
                        metal_stamp_set_brush_opacity(brushOpacity);
                        std::cout << "Opacity slider (pen): " << (int)(brushOpacity * 100) << "%" << std::endl;
                    } else if (isPointInColorButton(colorButton, x, y)) {
                        // Cycle to next color preset (pen)
                        colorButton.currentColorIndex = (colorButton.currentColorIndex + 1) % NUM_COLOR_PRESETS;
                        const ColorPreset& newColor = COLOR_PRESETS[colorButton.currentColorIndex];
                        metal_stamp_set_brush_color(newColor.r, newColor.g, newColor.b, 1.0f);
                        std::cout << "Color changed to (pen): " << newColor.name << std::endl;
                    } else {
                        // Drawing with Apple Pencil
                        metal_stamp_begin_stroke(x, y, pen_pressure);
                        last_x = x;
                        last_y = y;
                        is_drawing = true;
                    }
                    break;
                }

                case SDL_EVENT_PEN_MOTION: {
                    float x = event.pmotion.x;
                    float y = event.pmotion.y;
                    // pen_pressure updated via SDL_EVENT_PEN_AXIS events
                    if (pen_pressure <= 0.0f) pen_pressure = 1.0f;

                    if (sizeSlider.isDragging) {
                        float relY = (y - sizeSlider.y) / sizeSlider.height;
                        sizeSlider.value = 1.0f - std::max(0.0f, std::min(1.0f, relY));
                        brushSize = sizeSlider.minVal + sizeSlider.value * (sizeSlider.maxVal - sizeSlider.minVal);
                        metal_stamp_set_brush_size(brushSize);
                    } else if (opacitySlider.isDragging) {
                        float relY = (y - opacitySlider.y) / opacitySlider.height;
                        opacitySlider.value = 1.0f - std::max(0.0f, std::min(1.0f, relY));
                        brushOpacity = opacitySlider.minVal + opacitySlider.value * (opacitySlider.maxVal - opacitySlider.minVal);
                        metal_stamp_set_brush_opacity(brushOpacity);
                    } else if (is_drawing) {
                        float dx = x - last_x;
                        float dy = y - last_y;
                        if (dx*dx + dy*dy > 1.0f) {
                            metal_stamp_add_stroke_point(x, y, pen_pressure);
                            last_x = x;
                            last_y = y;
                        }
                    }
                    break;
                }

                case SDL_EVENT_PEN_UP: {
                    if (sizeSlider.isDragging) {
                        sizeSlider.isDragging = false;
                        std::cout << "Size set to (pen): " << (int)brushSize << "px" << std::endl;
                    } else if (opacitySlider.isDragging) {
                        opacitySlider.isDragging = false;
                        std::cout << "Opacity set to (pen): " << (int)(brushOpacity * 100) << "%" << std::endl;
                    } else if (is_drawing) {
                        std::cout << "Pen up - ending stroke" << std::endl;
                        metal_stamp_end_stroke();
                        is_drawing = false;
                    }
                    pen_pressure = 1.0f;  // Reset pressure
                    break;
                }

                // NOTE: On iOS simulator, mouse events also fire alongside finger events
                // but with different coordinates (pixels vs normalized). We only handle
                // finger events to avoid duplicate strokes.
                // Mouse events are commented out for iOS:
                /*
                case SDL_EVENT_MOUSE_BUTTON_DOWN: {
                    float x = event.button.x;
                    float y = event.button.y;
                    std::cout << "Mouse down: " << x << ", " << y << std::endl;
                    metal_stamp_begin_stroke(x, y, 1.0f);
                    is_drawing = true;
                    break;
                }

                case SDL_EVENT_MOUSE_MOTION: {
                    if (is_drawing) {
                        float x = event.motion.x;
                        float y = event.motion.y;
                        metal_stamp_add_stroke_point(x, y, 1.0f);
                    }
                    break;
                }

                case SDL_EVENT_MOUSE_BUTTON_UP: {
                    if (is_drawing) {
                        std::cout << "Mouse up - ending stroke" << std::endl;
                        metal_stamp_end_stroke();
                        is_drawing = false;
                    }
                    break;
                }
                */
            }
        }

        // Render the current stroke (for real-time preview)
        metal_stamp_render_stroke();

        // Draw UI sliders (queued before present)
        // Size slider - blue tint
        drawVerticalSlider(sizeSlider, height, 0.3f, 0.5f, 0.9f, "Size");
        // Opacity slider - gray/white tint
        drawVerticalSlider(opacitySlider, height, 0.6f, 0.6f, 0.6f, "Opacity");
        // Color picker button
        drawColorButton(colorButton);

        // Present with UI overlay
        metal_stamp_present();

        // Small delay to avoid busy-waiting
        SDL_Delay(1);
    }

    // Cleanup
    metal_stamp_cleanup();
    SDL_DestroyWindow(window);

    return 0;
}

#endif  // METAL_TEST_MODE

// =============================================================================
// Main Entry Point
// =============================================================================

extern "C" int drawing_mobile_main(int argc, char* argv[]) {
    std::cout << "========================================" << std::endl;
    std::cout << "   Drawing Canvas - iOS" << std::endl;
    std::cout << "========================================" << std::endl;

#if METAL_TEST_MODE
    // Pure C++ Metal test mode
    return metal_test_main();
#else
    // Initialize jank runtime on a large stack thread
    if (!init_jank_runtime_on_large_stack()) {
        std::cerr << "[drawing_mobile] Failed to initialize jank" << std::endl;
        return 1;
    }

    // Call the jank main function
    call_jank_main_impl();

    std::cout << "[drawing_mobile] App finished" << std::endl;
    return 0;
#endif
}
