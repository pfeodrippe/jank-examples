// Drawing Mobile iOS - jank-powered drawing app
// Uses SDL3 + Metal via drawing_canvas.hpp singleton

// Define METAL_TEST_MODE to bypass jank and test Metal directly
#define METAL_TEST_MODE 1

#import <Foundation/Foundation.h>
#import <UIKit/UIKit.h>
#import <Photos/Photos.h>
#import <PhotosUI/PhotosUI.h>
#import <CoreText/CoreText.h>
#include <iostream>
#include <sstream>
#include <string>
#include <mutex>
#include <condition_variable>
#include <pthread.h>
#include <algorithm>  // For std::max, std::min

#include <SDL3/SDL.h>

// Helper to check if a touch event comes from pen/mouse input (not a real finger)
// SDL_PEN_TOUCHID = -2 (pen-generated), SDL_MOUSE_TOUCHID = -1 (mouse-generated)
static inline bool isSyntheticTouchEvent(SDL_TouchID touchID) {
    return touchID == (SDL_TouchID)-1 || touchID == (SDL_TouchID)-2;
}

#include "../src/vybe/app/drawing/native/metal_renderer.h"
#include "../src/vybe/app/drawing/native/animation_thread.h"
#import "brush_importer.h"

// jank runtime headers
// iOS defines 'nil' as a macro which conflicts with jank's object_type::nil
#pragma push_macro("nil")
#undef nil
#include <gc.h>
#include <jank/runtime/context.hpp>
#include <jank/runtime/core.hpp>
#include <jank/runtime/core/make_box.hpp>
#include <jank/runtime/behavior/callable.hpp>
#include <jank/runtime/module/loader.hpp>
#include <jank/error.hpp>

// iOS JIT support
#if defined(JANK_IOS_JIT)
#include <jank/ios/eval_server.hpp>
#include <jank/compile_server/remote_compile.hpp>
extern "C" void jank_debug_print_sizeof();
#endif

#pragma pop_macro("nil")

// =============================================================================
// jank Integration (following SdfViewerMobile pattern)
// =============================================================================

// External AOT init function generated by ios-bundle
extern "C" void jank_aot_init();

static bool jank_initialized = false;

#if defined(JANK_IOS_JIT)
// Hybrid JIT mode: AOT core libs + JIT user code
static bool load_jank_modules_jit() {
    std::cout << "[drawing_mobile] Loading AOT core modules..." << std::endl;

    // jank_aot_init() loads:
    // 1. clojure.core-native, clojure.core, other core libs
    // 2. nREPL native module (jank.nrepl-server.asio) - inserted by ios-bundle when JANK_IOS_JIT
    // 3. application modules
    jank_aot_init();

    std::cout << "[drawing_mobile] All modules loaded! Ready for REPL." << std::endl;
    return true;
}
#endif

// Forward declaration for large-stack wrapper
static bool init_jank_runtime_impl();

// Large stack wrapper for running jank on iOS
// iOS main thread has only ~1MB stack, but jank's recursive codegen needs more.
struct jank_init_result {
    std::mutex mtx;
    std::condition_variable cv;
    bool done = false;
    bool success = false;
};

// Forward declaration - call_jank_metal_main() is defined later
static void call_jank_metal_main();

static void* jank_init_thread_func(void* arg) {
    auto* result = static_cast<jank_init_result*>(arg);

    bool success = init_jank_runtime_impl();

    // Also call jank_metal_main on this large-stack thread!
    // The require call triggers deep JIT recursion that needs 8MB stack.
    if (success) {
        std::cout << "[drawing_mobile] Calling jank metal main on large stack thread..." << std::endl;
        call_jank_metal_main();
    }

    {
        std::lock_guard<std::mutex> lock(result->mtx);
        result->success = success;
        result->done = true;
    }
    result->cv.notify_one();
    return nullptr;
}

static bool init_jank_runtime_on_large_stack() {
    constexpr size_t STACK_SIZE = 8 * 1024 * 1024; // 8MB stack

    // Initialize GC on main thread FIRST - before creating worker thread
    std::cout << "[drawing_mobile] Initializing Boehm GC on main thread..." << std::endl;
    GC_init();

    // CRITICAL: Disable GC during worker thread execution to avoid
    // "Collecting from unknown thread" errors.
    std::cout << "[drawing_mobile] Disabling GC during initialization..." << std::endl;
    GC_disable();

    pthread_attr_t attr;
    pthread_attr_init(&attr);
    pthread_attr_setstacksize(&attr, STACK_SIZE);

    jank_init_result result;
    pthread_t thread;

    std::cout << "[drawing_mobile] Starting initialization on thread with " << (STACK_SIZE / 1024 / 1024) << "MB stack..." << std::endl;

    int err = pthread_create(&thread, &attr, jank_init_thread_func, &result);
    pthread_attr_destroy(&attr);

    if (err != 0) {
        std::cerr << "[drawing_mobile] Failed to create large-stack thread: " << err << std::endl;
        // Fall back to running on current thread (re-enable GC first)
        GC_enable();
        return init_jank_runtime_impl();
    }

    // Wait for the thread to complete
    {
        std::unique_lock<std::mutex> lock(result.mtx);
        result.cv.wait(lock, [&result] { return result.done; });
    }

    pthread_join(thread, nullptr);

    // Re-enable GC now that initialization is complete
    std::cout << "[drawing_mobile] Re-enabling GC after initialization..." << std::endl;
    GC_enable();

    return result.success;
}

// Initialize jank runtime for iOS (actual implementation)
// NOTE: GC_init() is called by init_jank_runtime_on_large_stack() before this
static bool init_jank_runtime_impl() {
    try {
        std::cout << "[drawing_mobile] Creating runtime context..." << std::endl;
        jank::runtime::__rt_ctx = new (GC_malloc(sizeof(jank::runtime::context)))
            jank::runtime::context{};

#if defined(JANK_IOS_JIT)
        // Print sizeof for key types to help diagnose ABI mismatches
        jank_debug_print_sizeof();

        // Configure and connect to remote compile server on macOS
#if TARGET_OS_SIMULATOR
        std::string const remote_host = "127.0.0.1";
        uint16_t const remote_port = 5572;  // DrawingMobile simulator uses port 5572
#else
        // Device needs Mac's actual IP - update for your network!
        std::string const remote_host = "192.168.2.25";
        uint16_t const remote_port = 5573;  // DrawingMobile device uses port 5573
#endif

        std::cout << "[drawing_mobile] Configuring remote compile server at " << remote_host << ":" << remote_port << "..." << std::endl;
        jank::compile_server::configure_remote_compile(remote_host, remote_port);

        if (jank::compile_server::connect_remote_compile()) {
            std::cout << "[drawing_mobile] Connected to remote compile server!" << std::endl;
        } else {
            std::cout << "[drawing_mobile] Warning: Could not connect to remote compile server." << std::endl;
        }

        // JIT mode: Load modules from bundled source files
        std::cout << "[drawing_mobile] JIT mode - loading modules from source..." << std::endl;
        if (!load_jank_modules_jit()) {
            std::cerr << "[drawing_mobile] JIT module loading failed" << std::endl;
            return false;
        }
#else
        // AOT mode: Load all modules via auto-generated init function
        jank_aot_init();
#endif

        jank_initialized = true;
        std::cout << "[drawing_mobile] Runtime initialized successfully!" << std::endl;
        return true;
    } catch (jtl::ref<jank::error::base> const& e) {
        std::cerr << "[drawing_mobile] Error initializing runtime: " << e->message << std::endl;
        if (e->cause) {
            std::cerr << "[drawing_mobile]   caused by: " << e->cause->message << std::endl;
        }
        return false;
    } catch (const std::exception& e) {
        std::cerr << "[drawing_mobile] Error initializing runtime (std): " << e.what() << std::endl;
        return false;
    }
}

// Call the jank-exported -main function
static void call_jank_main_impl() {
    try {
        // Set up thread bindings (required for dynamic vars like *ns*)
        jank::runtime::context::binding_scope bindings;

        // Find clojure.core/require
        auto require_var = jank::runtime::__rt_ctx->find_var(
            jank::runtime::make_box<jank::runtime::obj::symbol>("clojure.core/require")
        );
        if (require_var.is_nil()) {
            std::cerr << "[drawing_mobile] Could not find clojure.core/require" << std::endl;
            return;
        }

        // Call (require 'vybe.app.drawing)
        std::cout << "[drawing_mobile] Loading vybe.app.drawing..." << std::endl;
        jank::runtime::dynamic_call(
            require_var->deref(),
            jank::runtime::make_box<jank::runtime::obj::symbol>("vybe.app.drawing")
        );
        std::cout << "[drawing_mobile] vybe.app.drawing loaded!" << std::endl;

        // Find and call -main
        auto main_var = jank::runtime::__rt_ctx->intern_var("vybe.app.drawing", "-main");
        if (!main_var.is_ok()) {
            std::cerr << "[drawing_mobile] Could not find vybe.app.drawing/-main" << std::endl;
            return;
        }

        std::cout << "[drawing_mobile] Calling vybe.app.drawing/-main with nREPL port 5581..." << std::endl;
        jank::runtime::dynamic_call(
            main_var.expect_ok()->deref(),
            jank::runtime::make_box<jank::runtime::obj::integer>(5581)
        );

    } catch (jtl::ref<jank::error::base> const& e) {
        std::cerr << "\n";
        std::cerr << "=== jank Runtime Error ===" << std::endl;
        std::cerr << e->message << std::endl;
        if (e->source.file != jank::read::no_source_path) {
            std::cerr << "at " << e->source.to_string() << std::endl;
        }
        if (e->cause) {
            std::cerr << "caused by: " << e->cause->message << std::endl;
        }
    } catch (std::exception& e) {
        std::cerr << "[drawing_mobile] Failed to run app: " << e.what() << std::endl;
    }
}

// Call vybe.app.drawing.metal/-main (just starts nREPL for Metal test mode)
static void call_jank_metal_main() {
    try {
        jank::runtime::context::binding_scope bindings;

        auto require_var = jank::runtime::__rt_ctx->find_var(
            jank::runtime::make_box<jank::runtime::obj::symbol>("clojure.core/require")
        );
        if (require_var.is_nil()) {
            std::cerr << "[metal] Could not find clojure.core/require" << std::endl;
            return;
        }

        std::cout << "[metal] Loading vybe.app.drawing.metal..." << std::endl;
        jank::runtime::dynamic_call(
            require_var->deref(),
            jank::runtime::make_box<jank::runtime::obj::symbol>("vybe.app.drawing.metal")
        );

        auto main_var = jank::runtime::__rt_ctx->intern_var("vybe.app.drawing.metal", "-main");
        if (!main_var.is_ok()) {
            std::cerr << "[metal] Could not find vybe.app.drawing.metal/-main" << std::endl;
            return;
        }

        std::cout << "[metal] Starting nREPL on port 5580..." << std::endl;
        jank::runtime::dynamic_call(
            main_var.expect_ok()->deref(),
            jank::runtime::make_box<jank::runtime::obj::integer>(5580)
        );

    } catch (jtl::ref<jank::error::base> const& e) {
        std::cerr << "[metal] nREPL error: " << e->message << std::endl;
    } catch (std::exception& e) {
        std::cerr << "[metal] nREPL error: " << e.what() << std::endl;
    }
}

// =============================================================================
// Metal Test Mode - Pure C++ SDL + Metal rendering (no jank)
// =============================================================================

#if METAL_TEST_MODE

// =============================================================================
// Texture Picker Helper
// =============================================================================

typedef enum {
    TextureTypeShape = 0,
    TextureTypeGrain = 1
} TextureType;

// Callback function pointer for when texture is loaded
typedef void (*TextureLoadedCallback)(int32_t textureId, TextureType type);

// Global pending request state
static TextureType g_pendingTextureType = TextureTypeShape;
static SDL_Window* g_sdlWindow = nullptr;

// Global texture button state (set in main, updated by callback)
static bool g_shapeTextureHasTexture = false;
static int32_t g_shapeTextureId = -1;
static bool g_grainTextureHasTexture = false;
static int32_t g_grainTextureId = -1;

// Global brush picker state
static NSMutableArray<NSNumber*>* g_brushIds = nil;
static int32_t g_selectedBrushId = -1;
static int g_selectedBrushIndex = 0;
static bool g_brushPickerVisible = false;
static bool g_brushesLoaded = false;

// Brush picker scroll state
static float g_brushPickerScrollOffset = 0.0f;  // Current scroll offset (pixels)
static bool g_brushPickerIsDragging = false;    // Currently dragging to scroll
static float g_brushPickerDragStartY = 0.0f;    // Y position where drag started
static float g_brushPickerDragStartOffset = 0.0f; // Scroll offset when drag started
static SDL_FingerID g_brushPickerDragFingerId = 0; // Finger used for scrolling

// Eraser mode state
static bool g_eraserMode = false;  // When true, paint with background color

// Paper background color (off-white, matches weave :bg-color [0.95 0.95 0.92 1.0])
static const float PAPER_BG_R = 0.95f;
static const float PAPER_BG_G = 0.95f;
static const float PAPER_BG_B = 0.92f;
static const float PAPER_BG_A = 1.0f;

// Objective-C delegate for PHPicker
@interface TexturePickerDelegate : NSObject <PHPickerViewControllerDelegate>
@property (nonatomic, assign) TextureType textureType;
@end

@implementation TexturePickerDelegate

- (void)picker:(PHPickerViewController *)picker didFinishPicking:(NSArray<PHPickerResult *> *)results {
    [picker dismissViewControllerAnimated:YES completion:nil];

    if (results.count == 0) {
        std::cout << "[TexturePicker] User cancelled" << std::endl;
        return;
    }

    PHPickerResult* result = results[0];

    // Check if the result can provide an image
    if (![result.itemProvider canLoadObjectOfClass:[UIImage class]]) {
        std::cout << "[TexturePicker] Cannot load image from selection" << std::endl;
        return;
    }

    TextureType capturedType = self.textureType;

    [result.itemProvider loadObjectOfClass:[UIImage class] completionHandler:^(id<NSItemProviderReading> _Nullable object, NSError * _Nullable error) {
        if (error) {
            std::cout << "[TexturePicker] Error loading image: " << [[error localizedDescription] UTF8String] << std::endl;
            return;
        }

        UIImage* image = (UIImage*)object;
        if (!image) {
            std::cout << "[TexturePicker] Image is nil" << std::endl;
            return;
        }

        std::cout << "[TexturePicker] Got image: " << image.size.width << "x" << image.size.height << std::endl;

        // Process image on main thread
        dispatch_async(dispatch_get_main_queue(), ^{
            // Convert to grayscale and load as texture
            CGImageRef cgImage = image.CGImage;
            if (!cgImage) {
                std::cout << "[TexturePicker] No CGImage" << std::endl;
                return;
            }

            // Determine target size (power of 2, max 1024 for efficiency)
            size_t srcWidth = CGImageGetWidth(cgImage);
            size_t srcHeight = CGImageGetHeight(cgImage);
            size_t maxDim = MAX(srcWidth, srcHeight);
            size_t targetSize = 512;
            if (maxDim > 512) targetSize = 1024;
            if (maxDim > 1024) targetSize = 2048;

            std::cout << "[TexturePicker] Converting to " << targetSize << "x" << targetSize << " grayscale" << std::endl;

            // Create grayscale context
            CGColorSpaceRef graySpace = CGColorSpaceCreateDeviceGray();
            uint8_t* pixels = (uint8_t*)calloc(targetSize * targetSize, 1);

            CGContextRef ctx = CGBitmapContextCreate(
                pixels,
                targetSize, targetSize,
                8,  // bits per component
                targetSize,  // bytes per row
                graySpace,
                kCGImageAlphaNone
            );

            // Calculate aspect-fit rectangle
            float srcAspect = (float)srcWidth / (float)srcHeight;
            float dstAspect = 1.0f;  // Square
            CGRect drawRect;

            if (srcAspect > dstAspect) {
                // Source is wider - fit to width
                float h = targetSize / srcAspect;
                drawRect = CGRectMake(0, (targetSize - h) / 2.0f, targetSize, h);
            } else {
                // Source is taller - fit to height
                float w = targetSize * srcAspect;
                drawRect = CGRectMake((targetSize - w) / 2.0f, 0, w, targetSize);
            }

            // Fill with black (transparent in brush terms)
            CGContextSetFillColorWithColor(ctx, [UIColor blackColor].CGColor);
            CGContextFillRect(ctx, CGRectMake(0, 0, targetSize, targetSize));

            // Draw image
            CGContextDrawImage(ctx, drawRect, cgImage);

            // Load into Metal texture
            int32_t textureId = metal_stamp_load_texture_data(pixels, (int)targetSize, (int)targetSize);

            // Cleanup
            CGContextRelease(ctx);
            CGColorSpaceRelease(graySpace);
            free(pixels);

            if (textureId > 0) {
                std::cout << "[TexturePicker] Loaded texture ID: " << textureId << std::endl;

                // Apply texture based on type
                if (capturedType == TextureTypeShape) {
                    metal_stamp_set_brush_shape_texture(textureId);
                    std::cout << "[TexturePicker] Set as SHAPE texture" << std::endl;
                } else {
                    metal_stamp_set_brush_grain_texture(textureId);
                    std::cout << "[TexturePicker] Set as GRAIN texture" << std::endl;
                }

                // Update global state for UI
                if (capturedType == TextureTypeShape) {
                    g_shapeTextureHasTexture = true;
                    g_shapeTextureId = textureId;
                    std::cout << "[TexturePicker] Updated global shape texture state" << std::endl;
                } else {
                    g_grainTextureHasTexture = true;
                    g_grainTextureId = textureId;
                    std::cout << "[TexturePicker] Updated global grain texture state" << std::endl;
                }
            } else {
                std::cout << "[TexturePicker] Failed to load texture" << std::endl;
            }
        });
    }];
}

@end

// Global delegate instance (must persist while picker is shown)
static TexturePickerDelegate* g_pickerDelegate = nil;

// =============================================================================
// Pulley Gesture Logic (unified - no separate swipe detection)
// =============================================================================
// Pulley appears IMMEDIATELY on finger down. First movement changes one frame,
// then 800ms lockout before rotation scrubbing begins.

// Function to show texture picker
static void showTexturePicker(SDL_Window* window, TextureType type) {
    if (!window) {
        std::cout << "[TexturePicker] No window provided" << std::endl;
        return;
    }

    // Get UIWindow from SDL
    SDL_PropertiesID props = SDL_GetWindowProperties(window);
    UIWindow* uiWindow = (__bridge UIWindow*)SDL_GetPointerProperty(props, SDL_PROP_WINDOW_UIKIT_WINDOW_POINTER, NULL);

    if (!uiWindow) {
        std::cout << "[TexturePicker] Cannot get UIWindow from SDL" << std::endl;
        return;
    }

    UIViewController* rootVC = uiWindow.rootViewController;
    if (!rootVC) {
        std::cout << "[TexturePicker] No root view controller" << std::endl;
        return;
    }

    std::cout << "[TexturePicker] Opening picker for " << (type == TextureTypeShape ? "SHAPE" : "GRAIN") << std::endl;

    // Create delegate
    if (!g_pickerDelegate) {
        g_pickerDelegate = [[TexturePickerDelegate alloc] init];
    }
    g_pickerDelegate.textureType = type;

    // Configure picker
    PHPickerConfiguration* config = [[PHPickerConfiguration alloc] init];
    config.selectionLimit = 1;
    config.filter = [PHPickerFilter imagesFilter];

    PHPickerViewController* picker = [[PHPickerViewController alloc] initWithConfiguration:config];
    picker.delegate = g_pickerDelegate;

    // Present picker with delay to avoid SDL touch event interference
    dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(0.1 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^{
        [rootVC presentViewController:picker animated:YES completion:^{
            std::cout << "[TexturePicker] Picker presented" << std::endl;
        }];
    });
}

// =============================================================================
// Brush Picker Functions
// =============================================================================

// Load brushes from the bundled brushset files
static void loadBrushesFromBundledFile() {
    if (g_brushesLoaded) return;

    @autoreleasepool {  // Release temp objects from brush loading
    NSLog(@"[BrushPicker] Loading bundled brushsets...");

    g_brushIds = [[NSMutableArray alloc] init];

    // Brushsets to load from app bundle (in order)
    NSArray<NSString*>* bundleNames = @[@"brushes", @"BetterThanBasics", @"WC_brushes_For_Paperlike"];

    for (NSString* bundleName in bundleNames) {
        NSArray<NSNumber*>* brushIds = [BrushImporter loadBundledBrushSet:bundleName];
        if (brushIds.count > 0) {
            [g_brushIds addObjectsFromArray:brushIds];
            NSLog(@"[BrushPicker] Loaded %lu brushes from bundle: %@",
                  (unsigned long)brushIds.count, bundleName);
        }
    }

    // Load brushes from pre-extracted folders (containing .brushset and .brush files)
    NSArray<NSString*>* folderNames = @[@"Goodtype_Extracted"];
    for (NSString* folderName in folderNames) {
        NSArray<NSNumber*>* brushIds = [BrushImporter loadBundledBrushFolder:folderName];
        if (brushIds.count > 0) {
            [g_brushIds addObjectsFromArray:brushIds];
            NSLog(@"[BrushPicker] Loaded %lu brushes from folder: %@",
                  (unsigned long)brushIds.count, folderName);
        }
    }

    if (g_brushIds.count > 0) {
        g_brushesLoaded = true;
        g_selectedBrushIndex = 0;
        g_selectedBrushId = [g_brushIds[0] intValue];
        [BrushImporter applyBrush:g_selectedBrushId];
        NSLog(@"[BrushPicker] Total: %lu brushes loaded", (unsigned long)g_brushIds.count);
    } else {
        NSLog(@"[BrushPicker] No brushes loaded");
    }
    }  // End @autoreleasepool
}

// Select next brush in the list
static void selectNextBrush() {
    if (!g_brushIds || g_brushIds.count == 0) return;

    g_selectedBrushIndex = (g_selectedBrushIndex + 1) % (int)g_brushIds.count;
    g_selectedBrushId = [g_brushIds[g_selectedBrushIndex] intValue];
    [BrushImporter applyBrush:g_selectedBrushId];

    ImportedBrush* brush = [BrushImporter getBrushById:g_selectedBrushId];
    if (brush) {
        NSLog(@"[BrushPicker] Selected brush %d: %s", g_selectedBrushIndex, brush->name);
    }
}

// Select previous brush in the list
static void selectPrevBrush() {
    if (!g_brushIds || g_brushIds.count == 0) return;

    g_selectedBrushIndex = (g_selectedBrushIndex - 1 + (int)g_brushIds.count) % (int)g_brushIds.count;
    g_selectedBrushId = [g_brushIds[g_selectedBrushIndex] intValue];
    [BrushImporter applyBrush:g_selectedBrushId];

    ImportedBrush* brush = [BrushImporter getBrushById:g_selectedBrushId];
    if (brush) {
        NSLog(@"[BrushPicker] Selected brush %d: %s", g_selectedBrushIndex, brush->name);
    }
}

// Get currently selected brush name
static const char* getSelectedBrushName() {
    if (g_selectedBrushId < 0) return "No Brush";

    ImportedBrush* brush = [BrushImporter getBrushById:g_selectedBrushId];
    if (brush) return brush->name;
    return "Unknown";
}

// =============================================================================
// Brush Picker Button Configuration
// =============================================================================

static const float BRUSH_BUTTON_WIDTH = 200.0f;
static const float BRUSH_BUTTON_HEIGHT = 60.0f;

struct BrushButtonConfig {
    float x, y;
    float width, height;
};

static bool isPointInBrushButton(const BrushButtonConfig& btn, float px, float py) {
    return px >= btn.x && px <= btn.x + btn.width &&
           py >= btn.y && py <= btn.y + btn.height;
}

static void drawBrushButton(const BrushButtonConfig& btn) {
    // Outer glow/border - orange/amber to stand out
    metal_stamp_queue_ui_rect(btn.x - 4, btn.y - 4, btn.width + 8, btn.height + 8,
                              0.95f, 0.6f, 0.2f, 0.9f, 14.0f);

    // Background - dark gray
    metal_stamp_queue_ui_rect(btn.x, btn.y, btn.width, btn.height,
                              0.15f, 0.15f, 0.18f, 0.95f, 10.0f);

    // Simple pencil icon using rectangles
    float iconX = btn.x + 15.0f;
    float iconY = btn.y + 10.0f;
    float iconW = 12.0f;
    float iconH = 40.0f;

    // Pencil body (yellow)
    metal_stamp_queue_ui_rect(iconX, iconY, iconW, iconH,
                              0.95f, 0.85f, 0.3f, 1.0f, 3.0f);

    // Pencil tip (pink/eraser top)
    metal_stamp_queue_ui_rect(iconX, iconY - 8.0f, iconW, 8.0f,
                              0.9f, 0.5f, 0.6f, 1.0f, 2.0f);

    // Pencil point (dark)
    metal_stamp_queue_ui_rect(iconX + 2.0f, iconY + iconH, iconW - 4.0f, 8.0f,
                              0.3f, 0.25f, 0.2f, 1.0f, 1.0f);

    // "Brush" text indicator area - show if brushes loaded
    if (g_brushesLoaded) {
        // Green indicator dot to show brushes are loaded
        metal_stamp_queue_ui_rect(btn.x + btn.width - 20.0f, btn.y + 5.0f, 12.0f, 12.0f,
                                  0.3f, 0.9f, 0.4f, 1.0f, 6.0f);
    }
}

// =============================================================================
// Eraser Button Configuration
// =============================================================================

static const float ERASER_BUTTON_SIZE = 60.0f;

struct EraserButtonConfig {
    float x, y;
    float size;
};

static bool isPointInEraserButton(const EraserButtonConfig& btn, float px, float py) {
    return px >= btn.x && px <= btn.x + btn.size &&
           py >= btn.y && py <= btn.y + btn.size;
}

static void drawEraserButton(const EraserButtonConfig& btn, bool isActive) {
    // Background - changes color when active
    if (isActive) {
        // Active: pink/red background
        metal_stamp_queue_ui_rect(btn.x - 3, btn.y - 3, btn.size + 6, btn.size + 6,
                                  0.9f, 0.3f, 0.4f, 0.95f, 12.0f);
        metal_stamp_queue_ui_rect(btn.x, btn.y, btn.size, btn.size,
                                  0.8f, 0.2f, 0.3f, 0.95f, 10.0f);
    } else {
        // Inactive: dark gray
        metal_stamp_queue_ui_rect(btn.x - 3, btn.y - 3, btn.size + 6, btn.size + 6,
                                  0.4f, 0.4f, 0.45f, 0.8f, 12.0f);
        metal_stamp_queue_ui_rect(btn.x, btn.y, btn.size, btn.size,
                                  0.2f, 0.2f, 0.25f, 0.95f, 10.0f);
    }

    // Eraser icon - simple rectangle shape
    float iconX = btn.x + btn.size * 0.2f;
    float iconY = btn.y + btn.size * 0.15f;
    float iconW = btn.size * 0.6f;
    float iconH = btn.size * 0.7f;

    // Eraser body (pink top half)
    metal_stamp_queue_ui_rect(iconX, iconY, iconW, iconH * 0.4f,
                              0.95f, 0.6f, 0.7f, 1.0f, 4.0f);

    // Eraser bottom (darker band)
    metal_stamp_queue_ui_rect(iconX, iconY + iconH * 0.4f, iconW, iconH * 0.2f,
                              0.5f, 0.5f, 0.55f, 1.0f, 0.0f);

    // Eraser holder (blue/gray)
    metal_stamp_queue_ui_rect(iconX, iconY + iconH * 0.6f, iconW, iconH * 0.4f,
                              0.3f, 0.4f, 0.6f, 1.0f, 2.0f);
}

// =============================================================================
// Brush Picker Panel Configuration (constants needed by text rendering)
// =============================================================================

static const float BRUSH_PICKER_ITEM_SIZE = 180.0f;
static const float BRUSH_PICKER_ITEM_GAP = 12.0f;
static const float BRUSH_PICKER_PADDING = 20.0f;
static const int BRUSH_PICKER_COLS = 4;

// =============================================================================
// Text Rendering for Brush Names
// =============================================================================

// Cache for rendered text textures: key = brushId, value = textureId
static std::map<int32_t, int32_t> g_brushNameTextures;
static std::map<int32_t, std::pair<int32_t, int32_t>> g_brushNameSizes;  // width, height

// Render text to a Metal texture and return the texture ID
static int32_t renderTextToTexture(const char* text, float fontSize, int maxWidth) {
    if (!text || strlen(text) == 0) return -1;

    NSString* nsText = [NSString stringWithUTF8String:text];

    // Create attributed string with white text
    UIFont* font = [UIFont systemFontOfSize:fontSize weight:UIFontWeightMedium];
    NSDictionary* attributes = @{
        NSFontAttributeName: font,
        NSForegroundColorAttributeName: [UIColor whiteColor]
    };

    // Calculate text size
    CGSize textSize = [nsText boundingRectWithSize:CGSizeMake(maxWidth, CGFLOAT_MAX)
                                           options:NSStringDrawingUsesLineFragmentOrigin
                                        attributes:attributes
                                           context:nil].size;

    int width = (int)ceilf(textSize.width);
    int height = (int)ceilf(textSize.height);

    if (width <= 0 || height <= 0) return -1;

    // Create bitmap context for rendering
    NSUInteger bytesPerPixel = 4;
    NSUInteger bytesPerRow = width * bytesPerPixel;
    uint8_t* rawData = (uint8_t*)calloc(height * bytesPerRow, sizeof(uint8_t));

    CGColorSpaceRef colorSpace = CGColorSpaceCreateDeviceRGB();
    CGContextRef context = CGBitmapContextCreate(rawData, width, height,
                                                  8, bytesPerRow, colorSpace,
                                                  kCGImageAlphaPremultipliedLast);
    CGColorSpaceRelease(colorSpace);

    if (!context) {
        free(rawData);
        return -1;
    }

    // Flip context for UIKit coordinate system
    CGContextTranslateCTM(context, 0, height);
    CGContextScaleCTM(context, 1.0, -1.0);

    // Draw text using UIKit
    UIGraphicsPushContext(context);
    [nsText drawInRect:CGRectMake(0, 0, width, height) withAttributes:attributes];
    UIGraphicsPopContext();

    CGContextRelease(context);

    // Load into Metal
    int32_t textureId = metal_stamp_load_rgba_texture_data(rawData, width, height);

    free(rawData);

    // Store the size
    if (textureId > 0) {
        // Size will be stored by caller using brushId
    }

    return textureId;
}

// Get or create text texture for a brush name
static int32_t getBrushNameTexture(int32_t brushId, const char* name, int* outWidth, int* outHeight) {
    // Check cache
    auto it = g_brushNameTextures.find(brushId);
    if (it != g_brushNameTextures.end()) {
        auto sizeIt = g_brushNameSizes.find(brushId);
        if (sizeIt != g_brushNameSizes.end()) {
            *outWidth = sizeIt->second.first;
            *outHeight = sizeIt->second.second;
        }
        return it->second;
    }

    // Render new texture
    float fontSize = 14.0f;
    int maxWidth = (int)BRUSH_PICKER_ITEM_SIZE - 10;

    NSString* nsText = [NSString stringWithUTF8String:name];
    UIFont* font = [UIFont systemFontOfSize:fontSize weight:UIFontWeightMedium];
    NSDictionary* attributes = @{
        NSFontAttributeName: font,
        NSForegroundColorAttributeName: [UIColor whiteColor]
    };

    CGSize textSize = [nsText boundingRectWithSize:CGSizeMake(maxWidth, CGFLOAT_MAX)
                                           options:NSStringDrawingUsesLineFragmentOrigin
                                        attributes:attributes
                                           context:nil].size;

    int width = (int)ceilf(textSize.width);
    int height = (int)ceilf(textSize.height);

    int32_t textureId = renderTextToTexture(name, fontSize, maxWidth);

    if (textureId > 0) {
        g_brushNameTextures[brushId] = textureId;
        g_brushNameSizes[brushId] = {width, height};
        *outWidth = width;
        *outHeight = height;
    }

    return textureId;
}

// =============================================================================
// Brush Picker Panel Structs and Functions
// =============================================================================

struct BrushPickerConfig {
    float x, y;          // Position (top-left of panel)
    float width, height; // Panel dimensions
    bool isOpen;
    float scrollOffset;  // Vertical scroll offset in pixels (positive = scrolled down)
};

static bool isPointInBrushPicker(const BrushPickerConfig& picker, float px, float py) {
    if (!picker.isOpen) return false;
    return px >= picker.x && px <= picker.x + picker.width &&
           py >= picker.y && py <= picker.y + picker.height;
}

// Returns brush index at point, or -1 if none
// Uses global g_brushPickerScrollOffset for scroll position
static int getBrushAtPoint(const BrushPickerConfig& picker, float px, float py) {
    if (!picker.isOpen || !g_brushIds || [g_brushIds count] == 0) return -1;

    // Check if point is within the brush grid area
    float gridX = picker.x + BRUSH_PICKER_PADDING;
    float gridY = picker.y + BRUSH_PICKER_PADDING;

    float relX = px - gridX;
    // Add scroll offset to get the "virtual" position in the full content
    float relY = py - gridY + g_brushPickerScrollOffset;

    float cellSize = BRUSH_PICKER_ITEM_SIZE + BRUSH_PICKER_ITEM_GAP;  // 192
    int col = (int)(relX / cellSize);
    int row = (int)(relY / cellSize);

    // Debug: show exact position within cell
    float cellRelX = relX - col * cellSize;
    float cellRelY = relY - row * cellSize;
    NSLog(@"[BrushPicker] HIT TEST: rel(%.1f,%.1f) scroll=%.1f -> row=%d col=%d, cellRel(%.1f,%.1f)",
          relX, relY - g_brushPickerScrollOffset, g_brushPickerScrollOffset, row, col, cellRelX, cellRelY);

    if (relX < 0 || relY < 0) return -1;
    if (col >= BRUSH_PICKER_COLS) return -1;

    int brushIndex = row * BRUSH_PICKER_COLS + col;
    if (brushIndex >= (int)[g_brushIds count]) return -1;

    // Verify point is actually within the item bounds (not in gap)
    // Item positions are in virtual (scrolled) coordinates
    float virtualItemX = col * cellSize;
    float virtualItemY = row * cellSize;

    float localRelX = relX - virtualItemX;
    float localRelY = relY - virtualItemY;

    bool inBounds = (localRelX >= 0 && localRelX <= BRUSH_PICKER_ITEM_SIZE &&
                     localRelY >= 0 && localRelY <= BRUSH_PICKER_ITEM_SIZE);

    NSLog(@"[BrushPicker] BOUNDS CHECK: localRel(%.1f,%.1f) inBounds=%d -> brushIdx=%d",
          localRelX, localRelY, inBounds, inBounds ? brushIndex : -1);

    if (inBounds) {
        return brushIndex;
    }

    return -1;
}

static void drawBrushPicker(const BrushPickerConfig& picker, int windowHeight) {
    if (!picker.isOpen) return;

    // Semi-transparent background
    metal_stamp_queue_ui_rect(picker.x, picker.y, picker.width, picker.height,
                              0.15f, 0.15f, 0.2f, 0.95f, 15.0f);

    // Border
    metal_stamp_queue_ui_rect(picker.x - 3, picker.y - 3, picker.width + 6, picker.height + 6,
                              0.3f, 0.3f, 0.4f, 0.8f, 18.0f);

    if (!g_brushIds || [g_brushIds count] == 0) return;

    // Draw brush items in a grid with scroll support
    float gridX = picker.x + BRUSH_PICKER_PADDING;
    float gridY = picker.y + BRUSH_PICKER_PADDING;
    float cellSize = BRUSH_PICKER_ITEM_SIZE + BRUSH_PICKER_ITEM_GAP;

    // Calculate content dimensions
    int brushCount = (int)[g_brushIds count];
    int rowCount = (brushCount + BRUSH_PICKER_COLS - 1) / BRUSH_PICKER_COLS;
    float contentHeight = rowCount * cellSize - BRUSH_PICKER_ITEM_GAP;
    float visibleHeight = picker.height - BRUSH_PICKER_PADDING * 2;

    // Clamp scroll offset to valid range
    float maxScroll = std::max(0.0f, contentHeight - visibleHeight);
    g_brushPickerScrollOffset = std::max(0.0f, std::min(g_brushPickerScrollOffset, maxScroll));

    for (int i = 0; i < brushCount; i++) {
        int col = i % BRUSH_PICKER_COLS;
        int row = i / BRUSH_PICKER_COLS;

        float itemX = gridX + col * cellSize;
        // Apply scroll offset (negative offset moves items up)
        float itemY = gridY + row * cellSize - g_brushPickerScrollOffset;

        // Check if item is within visible area (accounting for scroll)
        float visibleTop = picker.y + BRUSH_PICKER_PADDING;
        float visibleBottom = picker.y + picker.height - BRUSH_PICKER_PADDING;

        // Skip items completely above visible area
        if (itemY + BRUSH_PICKER_ITEM_SIZE < visibleTop) {
            continue;
        }
        // Skip items completely below visible area
        if (itemY > visibleBottom) {
            continue;
        }

        int32_t brushId = [[g_brushIds objectAtIndex:i] intValue];
        bool isSelected = (brushId == g_selectedBrushId);

        // Draw selection highlight
        if (isSelected) {
            metal_stamp_queue_ui_rect(itemX - 4, itemY - 4,
                                      BRUSH_PICKER_ITEM_SIZE + 8, BRUSH_PICKER_ITEM_SIZE + 8,
                                      0.3f, 0.7f, 0.9f, 0.9f, 8.0f);
        }

        // Draw brush item background
        metal_stamp_queue_ui_rect(itemX, itemY, BRUSH_PICKER_ITEM_SIZE, BRUSH_PICKER_ITEM_SIZE,
                                  0.25f, 0.25f, 0.3f, 0.9f, 6.0f);

        // Draw brush thumbnail preview (stroke preview)
        ImportedBrush* brush = [BrushImporter getBrushById:brushId];

        // FIRST: Check if brush is unsupported (no shape texture = uses bundled Procreate resources)
        if (brush && brush->shapeTextureId < 0) {
            // UNSUPPORTED BRUSH: Draw a red X to indicate brush cannot be used
            float centerX = itemX + BRUSH_PICKER_ITEM_SIZE / 2;
            float centerY = itemY + BRUSH_PICKER_ITEM_SIZE / 2;
            float xSize = 30.0f;
            float xThickness = 6.0f;

            // Draw red background circle
            metal_stamp_queue_ui_rect(centerX - xSize - 5, centerY - xSize - 5,
                                      (xSize + 5) * 2, (xSize + 5) * 2,
                                      0.3f, 0.1f, 0.1f, 0.8f, xSize + 5);

            // Draw X using two thick lines
            metal_stamp_queue_ui_rect(centerX - xSize, centerY - xThickness/2,
                                      xSize * 2, xThickness,
                                      0.9f, 0.2f, 0.2f, 1.0f, 2.0f);
            metal_stamp_queue_ui_rect(centerX - xThickness/2, centerY - xSize,
                                      xThickness, xSize * 2,
                                      0.9f, 0.2f, 0.2f, 1.0f, 2.0f);
        } else if (brush && brush->thumbnailTextureId > 0) {
            // Draw the actual brush thumbnail (Procreate QuickLook preview)
            float thumbPadding = 5.0f;
            float thumbX = itemX + thumbPadding;
            float thumbY = itemY + thumbPadding;
            float thumbW = BRUSH_PICKER_ITEM_SIZE - thumbPadding * 2;
            float thumbH = BRUSH_PICKER_ITEM_SIZE - thumbPadding * 2;

            // Calculate aspect ratio to fit 327x100 thumbnail
            float thumbAspect = (float)brush->thumbnailWidth / (float)brush->thumbnailHeight;
            float boxAspect = thumbW / thumbH;

            float drawW, drawH, drawX, drawY;
            if (thumbAspect > boxAspect) {
                drawW = thumbW;
                drawH = thumbW / thumbAspect;
                drawX = thumbX;
                drawY = thumbY + (thumbH - drawH) / 2;
            } else {
                drawH = thumbH;
                drawW = thumbH * thumbAspect;
                drawX = thumbX + (thumbW - drawW) / 2;
                drawY = thumbY;
            }

            // Draw the thumbnail texture with white tint
            metal_stamp_queue_ui_textured_rect(drawX, drawY, drawW, drawH,
                                               brush->thumbnailTextureId,
                                               1.0f, 1.0f, 1.0f, 1.0f);
        } else if (brush && brush->shapeTextureId >= 0) {
            // Fallback: Draw shape texture indicator
            metal_stamp_queue_ui_rect(itemX + 10, itemY + 10,
                                      BRUSH_PICKER_ITEM_SIZE - 20, BRUSH_PICKER_ITEM_SIZE - 20,
                                      0.4f, 0.4f, 0.5f, 0.8f, 4.0f);
        } else {
            // No brush data - draw placeholder
            metal_stamp_queue_ui_rect(itemX + 10, itemY + 10,
                                      BRUSH_PICKER_ITEM_SIZE - 20, BRUSH_PICKER_ITEM_SIZE - 20,
                                      0.3f, 0.3f, 0.3f, 0.5f, 4.0f);
        }

        // Draw brush name below thumbnail (like Procreate)
        if (brush && brush->name[0] != '\0') {
            int textWidth = 0, textHeight = 0;
            int32_t nameTextureId = getBrushNameTexture(brushId, brush->name, &textWidth, &textHeight);

            if (nameTextureId > 0 && textWidth > 0 && textHeight > 0) {
                // Position text centered at bottom of item
                float textX = itemX + (BRUSH_PICKER_ITEM_SIZE - textWidth) / 2;
                float textY = itemY + BRUSH_PICKER_ITEM_SIZE - textHeight - 8;

                // Draw semi-transparent background for readability
                float bgPadding = 4;
                metal_stamp_queue_ui_rect(textX - bgPadding, textY - bgPadding,
                                          textWidth + bgPadding * 2, textHeight + bgPadding * 2,
                                          0.0f, 0.0f, 0.0f, 0.6f, 4.0f);

                // Draw the text
                metal_stamp_queue_ui_textured_rect(textX, textY, textWidth, textHeight,
                                                   nameTextureId,
                                                   1.0f, 1.0f, 1.0f, 1.0f);
            }
        }
    }

    // Draw scroll indicator on right edge if content is scrollable
    if (contentHeight > visibleHeight) {
        float scrollBarWidth = 6.0f;
        float scrollBarPadding = 4.0f;
        float scrollBarX = picker.x + picker.width - scrollBarWidth - scrollBarPadding;

        // Calculate scroll bar dimensions
        float scrollRatio = visibleHeight / contentHeight;
        float scrollBarHeight = std::max(40.0f, visibleHeight * scrollRatio);
        float scrollRange = visibleHeight - scrollBarHeight;
        float scrollProgress = (maxScroll > 0) ? (g_brushPickerScrollOffset / maxScroll) : 0.0f;
        float scrollBarY = picker.y + BRUSH_PICKER_PADDING + scrollProgress * scrollRange;

        // Draw scroll track (darker)
        metal_stamp_queue_ui_rect(scrollBarX, picker.y + BRUSH_PICKER_PADDING,
                                  scrollBarWidth, visibleHeight,
                                  0.1f, 0.1f, 0.15f, 0.5f, scrollBarWidth / 2);

        // Draw scroll thumb (brighter)
        metal_stamp_queue_ui_rect(scrollBarX, scrollBarY,
                                  scrollBarWidth, scrollBarHeight,
                                  0.5f, 0.5f, 0.6f, 0.8f, scrollBarWidth / 2);
    }
}

// =============================================================================
// Texture Button Configuration
// =============================================================================

struct TextureButtonConfig {
    float x, y;
    float width, height;
    TextureType type;
    bool hasTexture;
    int32_t textureId;
};

static bool isPointInTextureButton(const TextureButtonConfig& btn, float px, float py) {
    return px >= btn.x && px <= btn.x + btn.width &&
           py >= btn.y && py <= btn.y + btn.height;
}

static void drawTextureButton(const TextureButtonConfig& btn, const char* label) {
    // Background - darker purple/blue color for visibility
    float bgAlpha = 0.9f;
    metal_stamp_queue_ui_rect(btn.x, btn.y, btn.width, btn.height,
                              0.4f, 0.3f, 0.6f, bgAlpha, 8.0f);

    // Border - always show for visibility
    metal_stamp_queue_ui_rect(btn.x - 2, btn.y - 2, btn.width + 4, btn.height + 4,
                              0.2f, 0.2f, 0.3f, 0.9f, 10.0f);

    // Show highlight if has texture
    if (btn.hasTexture) {
        metal_stamp_queue_ui_rect(btn.x - 4, btn.y - 4, btn.width + 8, btn.height + 8,
                                  0.4f, 0.7f, 1.0f, 0.8f, 12.0f);
    }
}

// =============================================================================
// UI Slider Configuration
// =============================================================================

struct SliderConfig {
    float x, y;           // Position (top-left)
    float width, height;  // Size
    float value;          // Current value (0.0 - 1.0)
    float minVal, maxVal; // Value range
    bool isDragging;
};

// =============================================================================
// Color Picker Configuration
// =============================================================================

struct ColorPreset {
    float r, g, b;
    const char* name;
};

// =============================================================================
// Canvas Transform - Pan/Zoom/Rotate state
// =============================================================================

struct CanvasTransform {
    float panX, panY;      // Pan offset in screen pixels
    float scale;           // Zoom level (1.0 = 100%)
    float rotation;        // Rotation in radians
    float pivotX, pivotY;  // Transform pivot (usually screen center)
};

// =============================================================================
// Canvas Reset Animation (Procreate-style smooth snap)
// =============================================================================

struct CanvasResetAnimation {
    bool isAnimating;
    Uint64 startTimeMs;
    float durationMs;

    // Start values (what we're animating FROM)
    float startPanX, startPanY;
    float startScale;
    float startRotation;

    // Target values (what we're animating TO)
    float targetPanX, targetPanY;
    float targetScale;
    float targetRotation;
};

// Ease-out cubic for smooth deceleration
static float easeOutCubic(float t) {
    return 1.0f - powf(1.0f - t, 3.0f);
}

// Linear interpolation
static float lerp(float a, float b, float t) {
    return a + (b - a) * t;
}

// Shortest path angle interpolation (handles wrap-around)
static float lerpAngle(float a, float b, float t) {
    // Normalize angles to -PI to PI
    while (a > M_PI) a -= 2.0f * M_PI;
    while (a < -M_PI) a += 2.0f * M_PI;
    while (b > M_PI) b -= 2.0f * M_PI;
    while (b < -M_PI) b += 2.0f * M_PI;

    // Find shortest path
    float diff = b - a;
    if (diff > M_PI) diff -= 2.0f * M_PI;
    if (diff < -M_PI) diff += 2.0f * M_PI;

    return a + diff * t;
}

// =============================================================================
// Two-Finger Gesture Tracking
// =============================================================================

struct TwoFingerGesture {
    bool isActive;
    SDL_FingerID finger0_id, finger1_id;

    // Starting positions (normalized 0-1)
    float finger0_startX, finger0_startY;
    float finger1_startX, finger1_startY;

    // Current positions (normalized 0-1)
    float finger0_currX, finger0_currY;
    float finger1_currX, finger1_currY;

    // Canvas transform at gesture start (baseline)
    float basePanX, basePanY;
    float baseScale;
    float baseRotation;

    // For quick-pinch detection (Procreate-style reset)
    Uint64 startTimeMs;
    float startDistance;  // Initial distance between fingers
};

// =============================================================================
// Three-Finger Gesture Tracking (for redo)
// =============================================================================

struct ThreeFingerGesture {
    bool isActive;
    SDL_FingerID finger0_id, finger1_id, finger2_id;

    // Starting positions (normalized 0-1)
    float finger0_startX, finger0_startY;
    float finger1_startX, finger1_startY;
    float finger2_startX, finger2_startY;

    // Current positions (normalized 0-1)
    float finger0_currX, finger0_currY;
    float finger1_currX, finger1_currY;
    float finger2_currX, finger2_currY;

    // Timing for tap detection
    Uint64 startTimeMs;
};

// =============================================================================
// Simple Frame Storage (snapshot-based animation)
// =============================================================================

struct FrameStore {
    std::vector<std::vector<uint8_t>> frames;  // CPU backup snapshots per frame
    int currentFrame = 0;
    int canvasWidth = 0;
    int canvasHeight = 0;
    bool gpuCacheReady = false;
    bool dirty = false;  // True if current frame was modified (needs save before switching)
    static const int MAX_FRAMES = 12;  // Looom-style wheel
};

static FrameStore g_frameStore;

static void framestore_init(int w, int h) {
    g_frameStore.canvasWidth = w;
    g_frameStore.canvasHeight = h;
    g_frameStore.frames.clear();
    g_frameStore.frames.resize(FrameStore::MAX_FRAMES);  // Pre-allocate 12 frames
    g_frameStore.currentFrame = 0;

    // Initialize GPU frame cache for instant switching
    g_frameStore.gpuCacheReady = metal_stamp_init_frame_cache(FrameStore::MAX_FRAMES);
    if (g_frameStore.gpuCacheReady) {
        NSLog(@"[FrameStore] GPU frame cache initialized (%d frames)", FrameStore::MAX_FRAMES);
    } else {
        NSLog(@"[FrameStore] GPU frame cache FAILED - falling back to CPU");
    }
}

// Fast save - only GPU cache (for frame switching)
static void framestore_save_current_fast() {
    int frame = g_frameStore.currentFrame;
    if (frame < 0 || frame >= FrameStore::MAX_FRAMES) return;

    // GPU->GPU copy is INSTANT
    if (g_frameStore.gpuCacheReady) {
        metal_stamp_cache_frame_to_gpu(frame);
    }
}

// Full save - GPU cache + CPU backup (only call after drawing completes)
static void framestore_save_current() {
    int frame = g_frameStore.currentFrame;
    if (frame < 0 || frame >= FrameStore::MAX_FRAMES) return;

    // GPU cache (instant)
    if (g_frameStore.gpuCacheReady) {
        metal_stamp_cache_frame_to_gpu(frame);
    }

    // CPU backup (slow - only for persistence)
    uint8_t* pixels = nullptr;
    int size = metal_stamp_capture_snapshot(&pixels);
    if (pixels && size > 0) {
        g_frameStore.frames[frame].assign(pixels, pixels + size);
        metal_stamp_free_snapshot(pixels);
    }

    g_frameStore.dirty = false;
}

static void framestore_load_frame(int index) {
    if (index < 0 || index >= FrameStore::MAX_FRAMES) return;

    // Switch undo tree to match the frame we're loading
    metal_stamp_undo_set_frame(index);

    // Try GPU cache first (INSTANT - no CPU->GPU transfer!)
    if (g_frameStore.gpuCacheReady && metal_stamp_is_frame_cached(index)) {
        metal_stamp_switch_to_cached_frame(index);
        g_frameStore.currentFrame = index;
        return;
    }

    // Fall back to CPU restore
    auto& pixels = g_frameStore.frames[index];
    if (!pixels.empty()) {
        metal_stamp_restore_snapshot(pixels.data(), (int)pixels.size(),
                                     g_frameStore.canvasWidth, g_frameStore.canvasHeight);
        // Also cache to GPU for next time
        if (g_frameStore.gpuCacheReady) {
            metal_stamp_cache_frame_to_gpu(index);
        }
    } else {
        // Empty frame - clear canvas to paper background
        metal_stamp_clear_canvas(PAPER_BG_R, PAPER_BG_G, PAPER_BG_B, PAPER_BG_A);
        // Cache the empty frame too
        if (g_frameStore.gpuCacheReady) {
            metal_stamp_cache_frame_to_gpu(index);
        }
    }
    g_frameStore.currentFrame = index;
}

static void framestore_goto_frame(int index) {
    if (index == g_frameStore.currentFrame) return;
    if (index < 0 || index >= FrameStore::MAX_FRAMES) return;

    // No save needed - frame was saved after drawing ended!
    framestore_load_frame(index);
}

static int framestore_get_frame_count() {
    return (int)g_frameStore.frames.size();
}

static int framestore_get_current_frame() {
    return g_frameStore.currentFrame;
}

// =============================================================================
// FrameStore C API (for REPL - uses same system as wheel)
// =============================================================================

extern "C" {

void frame_next() {
    int next = (g_frameStore.currentFrame + 1) % FrameStore::MAX_FRAMES;
    // No save needed - frame was saved after drawing ended!
    framestore_load_frame(next);
}

void frame_prev() {
    int prev = (g_frameStore.currentFrame - 1 + FrameStore::MAX_FRAMES) % FrameStore::MAX_FRAMES;
    // No save needed - frame was saved after drawing ended!
    framestore_load_frame(prev);
}

void frame_goto(int index) {
    if (index < 0 || index >= FrameStore::MAX_FRAMES) return;
    // No save needed - frame was saved after drawing ended!
    framestore_load_frame(index);
}

int frame_current() {
    return g_frameStore.currentFrame;
}

int frame_count() {
    return FrameStore::MAX_FRAMES;
}

} // extern "C"

// =============================================================================
// Frame Wheel UI (Looom-style frame navigation)
// =============================================================================

struct FrameWheel {
    float centerX, centerY;  // Center position (screen coords)
    float radius;            // Outer radius
    float innerRadius;       // Inner radius (donut shape)
    bool isDragging;
    float dragStartAngle;     // Where finger touched (in radians)
    int dragStartFrame;       // Which frame we were on when drag started
};

// =============================================================================
// Pulley - Looom-style time navigation (appears at finger touch location)
// =============================================================================

struct Pulley {
    bool active;              // Is pulley currently shown
    bool firstMoveDone;       // Has first frame change happened?
    Uint64 lockoutUntilMs;    // No more frame changes until this time (800ms after first move)
    float startX, startY;     // Initial finger position (for first move detection)
    float centerX, centerY;   // Pulley center (left of finger touch)
    float fingerX, fingerY;   // Current finger position (for drawing indicator)
    float referenceAngle;     // Reference angle for rotation scrubbing (set after lockout)
    int startFrame;           // Frame when rotation reference was set
    float radius;             // Visual radius of pulley
};

static Pulley g_pulley = {
    .active = false,
    .firstMoveDone = false,
    .lockoutUntilMs = 0,
    .startX = 0, .startY = 0,
    .centerX = 0, .centerY = 0,
    .fingerX = 0, .fingerY = 0,
    .referenceAngle = 0,
    .startFrame = 0,
    .radius = 180.0f  // 3x larger for visibility
};

// Lockout period after first frame change (ms)
static const Uint64 PULLEY_LOCKOUT_MS = 800;

// Draw pulley at current position (circle with indicator line to finger)
static void drawPulley(const Pulley& pulley, int currentFrame, int totalFrames) {
    if (!pulley.active) return;

    const float PI = 3.14159265f;

    // Draw circle outline using small dots
    const int segments = 24;
    const float dotSize = 4.0f;
    for (int i = 0; i < segments; i++) {
        float angle = (float)i / segments * 2.0f * PI;
        float x = pulley.centerX + cosf(angle) * pulley.radius - dotSize / 2;
        float y = pulley.centerY + sinf(angle) * pulley.radius - dotSize / 2;
        // Dark gray dots forming circle outline
        metal_stamp_queue_ui_rect(x, y, dotSize, dotSize, 0.3f, 0.3f, 0.3f, 0.7f, dotSize / 2);
    }

    // Draw center dot
    metal_stamp_queue_ui_rect(pulley.centerX - 5, pulley.centerY - 5, 10, 10,
                              0.2f, 0.2f, 0.2f, 0.8f, 5);

    // Draw indicator line from center towards finger (using dots)
    float angle = atan2f(pulley.fingerY - pulley.centerY, pulley.fingerX - pulley.centerX);
    const int lineDots = 8;
    for (int i = 1; i <= lineDots; i++) {
        float t = (float)i / lineDots * pulley.radius * 0.85f;
        float dotX = pulley.centerX + cosf(angle) * t - 3;
        float dotY = pulley.centerY + sinf(angle) * t - 3;
        metal_stamp_queue_ui_rect(dotX, dotY, 6, 6, 0.1f, 0.1f, 0.1f, 0.9f, 3);
    }
}

// Get angle from pulley center to point
static float getPulleyAngle(const Pulley& pulley, float x, float y) {
    return atan2f(y - pulley.centerY, x - pulley.centerX);
}

// Screen width for coordinate conversion (set in main loop)
static int g_screenWidth = 0;

// Draw frame wheel - Looom-style solid circle with frame holes
// Uses wheel.centerX/centerY directly (same coords as touch handling)
static void drawFrameWheel(const FrameWheel& wheel, int totalFrames, int currentFrame, float rotation) {
    const float PI = 3.14159265f;

    // Bigger wheel size
    float bigRadius = wheel.radius * 1.3f;

    // Draw solid dark circle background (approximated with segments)
    const int bgSegments = 16;
    for (int i = 0; i < bgSegments; i++) {
        float angle1 = (float)i / bgSegments * 2.0f * PI;
        float angle2 = (float)(i + 1) / bgSegments * 2.0f * PI;

        float x1 = wheel.centerX + cosf(angle1) * bigRadius;
        float y1 = wheel.centerY + sinf(angle1) * bigRadius;
        float x2 = wheel.centerX + cosf(angle2) * bigRadius;
        float y2 = wheel.centerY + sinf(angle2) * bigRadius;

        float minX = std::min({wheel.centerX, x1, x2});
        float maxX = std::max({wheel.centerX, x1, x2});
        float minY = std::min({wheel.centerY, y1, y2});
        float maxY = std::max({wheel.centerY, y1, y2});

        metal_stamp_queue_ui_rect(minX, minY, maxX - minX + 1, maxY - minY + 1,
                                  0.25f, 0.25f, 0.3f, 0.95f, 0.0f);
    }

    // Draw frame "holes" around the edge - rotate with wheel
    int maxFrames = 12;
    float holeRadius = bigRadius * 0.72f;
    float holeSize = 16.0f;

    for (int f = 0; f < maxFrames; f++) {
        // Apply rotation so holes visually spin with the wheel
        float frameAngle = rotation + (float)f / maxFrames * 2.0f * PI - PI/2.0f;
        float hx = wheel.centerX + cosf(frameAngle) * holeRadius;
        float hy = wheel.centerY + sinf(frameAngle) * holeRadius;

        // Frame 0 is ORANGE for reference, others are white/gray
        if (f == 0) {
            // Orange marker for frame 0
            metal_stamp_queue_ui_rect(hx - holeSize/2, hy - holeSize/2, holeSize, holeSize,
                                      1.0f, 0.5f, 0.0f, 1.0f, holeSize/2);
        } else {
            float brightness = (f < totalFrames) ? 0.9f : 0.5f;
            metal_stamp_queue_ui_rect(hx - holeSize/2, hy - holeSize/2, holeSize, holeSize,
                                      brightness, brightness, brightness, 1.0f, holeSize/2);
        }
    }

    // Draw fixed indicator at top (shows current frame position)
    float indicatorSize = 10.0f;
    metal_stamp_queue_ui_rect(wheel.centerX - indicatorSize/2, wheel.centerY - bigRadius - 12,
                              indicatorSize, indicatorSize, 1.0f, 0.2f, 0.2f, 1.0f, indicatorSize/2);
}

// Check if point is in frame wheel (full circle)
// Wheel position is in SCREEN coordinates (same as touch events)
static bool isPointInFrameWheel(const FrameWheel& wheel, float px, float py) {
    float dx = px - wheel.centerX;
    float dy = py - wheel.centerY;
    float dist = sqrtf(dx * dx + dy * dy);
    float bigRadius = wheel.radius * 1.3f;  // Match visual size
    return dist <= bigRadius + 20;  // Full circle with padding
}

// Get angle from wheel center to point (screen coordinates)
static float getWheelAngle(const FrameWheel& wheel, float px, float py) {
    return atan2f(py - wheel.centerY, px - wheel.centerX);
}

// Helper: Calculate distance between two points
static float pointDistance(float x1, float y1, float x2, float y2) {
    float dx = x2 - x1;
    float dy = y2 - y1;
    return sqrtf(dx * dx + dy * dy);
}

// Helper: Calculate angle between two points (radians)
static float pointAngle(float x1, float y1, float x2, float y2) {
    return atan2f(y2 - y1, x2 - x1);
}

// Convert screen coordinates to canvas coordinates (for drawing on transformed canvas)
// This MUST match the shader's inverse transform exactly!
static void screenToCanvas(float screenX, float screenY, const CanvasTransform& transform,
                           int screenWidth, int screenHeight,
                           float& canvasX, float& canvasY) {
    // Apply inverse transform to get canvas position
    // This matches the shader's canvas_blit_vertex exactly

    // 1. Translate to pivot
    float x = screenX - transform.pivotX;
    float y = screenY - transform.pivotY;

    // 2. Undo pan
    x -= transform.panX;
    y -= transform.panY;

    // 3. Undo scale
    x /= transform.scale;
    y /= transform.scale;

    // 4. Undo rotation
    float c = cosf(-transform.rotation);
    float s = sinf(-transform.rotation);
    float rx = x * c - y * s;
    float ry = x * s + y * c;

    // 5. Translate back from pivot
    canvasX = rx + transform.pivotX;
    canvasY = ry + transform.pivotY;
}

// Update canvas transform from gesture
static void updateTransformFromGesture(CanvasTransform& transform, const TwoFingerGesture& gesture,
                                       int screenWidth, int screenHeight) {
    if (!gesture.isActive) return;

    // Calculate start and current vectors (in screen pixels)
    float startDist = pointDistance(
        gesture.finger0_startX * screenWidth, gesture.finger0_startY * screenHeight,
        gesture.finger1_startX * screenWidth, gesture.finger1_startY * screenHeight
    );
    float currDist = pointDistance(
        gesture.finger0_currX * screenWidth, gesture.finger0_currY * screenHeight,
        gesture.finger1_currX * screenWidth, gesture.finger1_currY * screenHeight
    );

    // Scale: ratio of distances
    float deltaScale = (startDist > 1.0f) ? (currDist / startDist) : 1.0f;
    transform.scale = gesture.baseScale * deltaScale;

    // Clamp scale
    if (transform.scale < 0.1f) transform.scale = 0.1f;
    if (transform.scale > 10.0f) transform.scale = 10.0f;

    // Rotation: difference in angles
    float startAngle = pointAngle(
        gesture.finger0_startX, gesture.finger0_startY,
        gesture.finger1_startX, gesture.finger1_startY
    );
    float currAngle = pointAngle(
        gesture.finger0_currX, gesture.finger0_currY,
        gesture.finger1_currX, gesture.finger1_currY
    );
    float deltaRotation = currAngle - startAngle;
    transform.rotation = gesture.baseRotation + deltaRotation;

    // Pan: center point displacement (in screen pixels)
    float startCenterX = (gesture.finger0_startX + gesture.finger1_startX) / 2.0f * screenWidth;
    float startCenterY = (gesture.finger0_startY + gesture.finger1_startY) / 2.0f * screenHeight;
    float currCenterX = (gesture.finger0_currX + gesture.finger1_currX) / 2.0f * screenWidth;
    float currCenterY = (gesture.finger0_currY + gesture.finger1_currY) / 2.0f * screenHeight;

    transform.panX = gesture.basePanX + (currCenterX - startCenterX);
    transform.panY = gesture.basePanY + (currCenterY - startCenterY);

    // Update pivot to gesture center
    transform.pivotX = currCenterX;
    transform.pivotY = currCenterY;
}

// =============================================================================
// Color Picker - Grid-based color selection panel
// =============================================================================

// HSV to RGB conversion helper
static void hsvToRgb(float h, float s, float v, float& r, float& g, float& b) {
    if (s <= 0.0f) { r = g = b = v; return; }
    float hh = h;
    if (hh >= 360.0f) hh = 0.0f;
    hh /= 60.0f;
    int i = (int)hh;
    float ff = hh - i;
    float p = v * (1.0f - s);
    float q = v * (1.0f - (s * ff));
    float t = v * (1.0f - (s * (1.0f - ff)));
    switch(i) {
        case 0: r = v; g = t; b = p; break;
        case 1: r = q; g = v; b = p; break;
        case 2: r = p; g = v; b = t; break;
        case 3: r = p; g = q; b = v; break;
        case 4: r = t; g = p; b = v; break;
        default: r = v; g = p; b = q; break;
    }
}

// Color picker configuration
static const int COLOR_GRID_COLS = 6;
static const int COLOR_GRID_ROWS = 5;
static const float COLOR_SWATCH_SIZE = 50.0f;
static const float COLOR_SWATCH_GAP = 6.0f;
static const float COLOR_PICKER_PADDING = 12.0f;

struct ColorPickerState {
    bool isOpen;
    float x, y;              // Panel position (top-left)
    float width, height;     // Panel size
    float currentR, currentG, currentB;  // Current selected color
};

// Generate color grid (hue varies by column, brightness by row)
static void getGridColor(int col, int row, float& r, float& g, float& b) {
    if (row == COLOR_GRID_ROWS - 1) {
        // Bottom row: grayscale
        float gray = (float)col / (COLOR_GRID_COLS - 1);
        r = g = b = gray;
    } else {
        // Color rows: vary hue by column, saturation/brightness by row
        float hue = (float)col / COLOR_GRID_COLS * 360.0f;
        float sat = 0.85f;
        float val = 1.0f - (float)row / (COLOR_GRID_ROWS - 1) * 0.6f;  // 1.0 to 0.4
        hsvToRgb(hue, sat, val, r, g, b);
    }
}

struct ColorButtonConfig {
    float x, y;           // Position (top-left)
    float size;           // Diameter
};

// Check if point is inside color button
static bool isPointInColorButton(const ColorButtonConfig& btn, float px, float py) {
    float cx = btn.x + btn.size / 2.0f;
    float cy = btn.y + btn.size / 2.0f;
    float dx = px - cx;
    float dy = py - cy;
    return (dx*dx + dy*dy) <= (btn.size/2.0f * btn.size/2.0f);
}

// Check if point is inside color picker panel
static bool isPointInColorPicker(const ColorPickerState& picker, float px, float py) {
    return picker.isOpen &&
           px >= picker.x && px <= picker.x + picker.width &&
           py >= picker.y && py <= picker.y + picker.height;
}

// Get which color swatch was tapped (-1 if none)
static int getSwatchAtPoint(const ColorPickerState& picker, float px, float py) {
    if (!picker.isOpen) return -1;

    float gridX = picker.x + COLOR_PICKER_PADDING;
    float gridY = picker.y + COLOR_PICKER_PADDING;

    float relX = px - gridX;
    float relY = py - gridY;

    if (relX < 0 || relY < 0) return -1;

    int col = (int)(relX / (COLOR_SWATCH_SIZE + COLOR_SWATCH_GAP));
    int row = (int)(relY / (COLOR_SWATCH_SIZE + COLOR_SWATCH_GAP));

    if (col >= COLOR_GRID_COLS || row >= COLOR_GRID_ROWS) return -1;

    // Check if actually inside the swatch (not in gap)
    float swatchLocalX = relX - col * (COLOR_SWATCH_SIZE + COLOR_SWATCH_GAP);
    float swatchLocalY = relY - row * (COLOR_SWATCH_SIZE + COLOR_SWATCH_GAP);
    if (swatchLocalX > COLOR_SWATCH_SIZE || swatchLocalY > COLOR_SWATCH_SIZE) return -1;

    return row * COLOR_GRID_COLS + col;
}

// Draw color picker button (shows current color)
static void drawColorButton(const ColorButtonConfig& btn, const ColorPickerState& picker) {
    // Outer ring (white)
    metal_stamp_queue_ui_rect(btn.x, btn.y, btn.size, btn.size,
                              1.0f, 1.0f, 1.0f, 1.0f, btn.size / 2.0f);

    // Inner color circle
    float innerMargin = 4.0f;
    float innerSize = btn.size - innerMargin * 2;
    metal_stamp_queue_ui_rect(btn.x + innerMargin, btn.y + innerMargin, innerSize, innerSize,
                              picker.currentR, picker.currentG, picker.currentB, 1.0f, innerSize / 2.0f);
}

// Draw color picker panel
static void drawColorPicker(const ColorPickerState& picker) {
    if (!picker.isOpen) return;

    // Panel background (dark semi-transparent)
    metal_stamp_queue_ui_rect(picker.x, picker.y, picker.width, picker.height,
                              0.15f, 0.15f, 0.15f, 0.95f, 12.0f);

    // Draw color grid
    float gridX = picker.x + COLOR_PICKER_PADDING;
    float gridY = picker.y + COLOR_PICKER_PADDING;

    for (int row = 0; row < COLOR_GRID_ROWS; row++) {
        for (int col = 0; col < COLOR_GRID_COLS; col++) {
            float r, g, b;
            getGridColor(col, row, r, g, b);

            float swatchX = gridX + col * (COLOR_SWATCH_SIZE + COLOR_SWATCH_GAP);
            float swatchY = gridY + row * (COLOR_SWATCH_SIZE + COLOR_SWATCH_GAP);

            metal_stamp_queue_ui_rect(swatchX, swatchY, COLOR_SWATCH_SIZE, COLOR_SWATCH_SIZE,
                                      r, g, b, 1.0f, 6.0f);
        }
    }
}

// Check if point is inside slider track area
static bool isPointInSlider(const SliderConfig& slider, float px, float py) {
    return px >= slider.x && px <= slider.x + slider.width &&
           py >= slider.y && py <= slider.y + slider.height;
}

// Draw a vertical slider (Procreate-style)
static void drawVerticalSlider(const SliderConfig& slider, int screenHeight,
                               float r, float g, float b, const char* label) {
    // Slider track background (dark semi-transparent)
    metal_stamp_queue_ui_rect(slider.x, slider.y, slider.width, slider.height,
                              0.2f, 0.2f, 0.2f, 0.7f, 10.0f);

    // Filled portion (shows current value)
    float fillHeight = slider.height * slider.value;
    float fillY = slider.y + slider.height - fillHeight;
    if (fillHeight > 0) {
        metal_stamp_queue_ui_rect(slider.x, fillY, slider.width, fillHeight,
                                  r, g, b, 0.9f, 10.0f);
    }

    // Slider knob/handle
    float knobSize = slider.width * 1.3f;
    float knobX = slider.x + slider.width / 2.0f - knobSize / 2.0f;
    float knobY = fillY - knobSize / 2.0f;
    metal_stamp_queue_ui_rect(knobX, knobY, knobSize, knobSize,
                              1.0f, 1.0f, 1.0f, 1.0f, knobSize / 2.0f);

    // Inner knob circle (colored)
    float innerSize = knobSize * 0.7f;
    float innerX = knobX + (knobSize - innerSize) / 2.0f;
    float innerY = knobY + (knobSize - innerSize) / 2.0f;
    metal_stamp_queue_ui_rect(innerX, innerY, innerSize, innerSize,
                              r, g, b, 1.0f, innerSize / 2.0f);
}

static int metal_test_main() {
    std::cout << "========================================" << std::endl;
    std::cout << "   METAL TEST MODE - Pure C++ Rendering" << std::endl;
    std::cout << "========================================" << std::endl;

    // Disable pen events from generating touch events
    // This prevents Apple Pencil from triggering finger events (which would activate pulley)
    SDL_SetHint(SDL_HINT_PEN_TOUCH_EVENTS, "0");

    // Create SDL window
    SDL_Window* window = SDL_CreateWindow(
        "Metal Test",
        1024, 768,
        SDL_WINDOW_METAL | SDL_WINDOW_HIGH_PIXEL_DENSITY
    );

    if (!window) {
        std::cerr << "Failed to create window: " << SDL_GetError() << std::endl;
        return 1;
    }

    // Store window globally for texture picker
    g_sdlWindow = window;

    int width, height;
    SDL_GetWindowSizeInPixels(window, &width, &height);
    std::cout << "Window size: " << width << "x" << height << std::endl;
    g_screenWidth = width;  // Set for frame wheel coordinate conversion

    // Get pixel density for converting pen coordinates (in points) to pixels
    // Pen events use window coordinates (points), not physical pixels
    float pixelDensity = SDL_GetWindowPixelDensity(window);
    std::cout << "Pixel density: " << pixelDensity << std::endl;

    // Initialize Metal renderer
    std::cout << "Initializing Metal stamp renderer..." << std::endl;
    if (!metal_stamp_init(window, width, height)) {
        std::cerr << "Failed to initialize Metal renderer!" << std::endl;
        SDL_DestroyWindow(window);
        return 1;
    }
    std::cout << "Metal renderer initialized!" << std::endl;

    // Initialize jank runtime and start nREPL via vybe.app.drawing.metal namespace
    // NOTE: call_jank_metal_main() is now called inside init_jank_runtime_on_large_stack()
    // because the require call triggers deep JIT recursion that needs 8MB stack.
    std::cout << "Initializing jank runtime for nREPL..." << std::endl;
    if (init_jank_runtime_on_large_stack()) {
        std::cout << "Jank runtime initialized and nREPL started!" << std::endl;
    } else {
        std::cerr << "Warning: Failed to initialize jank runtime (nREPL unavailable)" << std::endl;
    }

    // Initialize per-frame undo trees (one undo tree per animation frame!)
    // Now memory-efficient: checkpoints every 10 strokes, ~165MB for 50 undo levels per frame
    metal_stamp_undo_init_with_frames(FrameStore::MAX_FRAMES);
    std::cout << "Per-frame undo trees initialized (" << FrameStore::MAX_FRAMES
              << " frames, checkpoints every 10 strokes)!" << std::endl;

    // =============================================================================
    // Initialize UI Sliders (Procreate-style vertical sliders on left edge)
    // =============================================================================

    const float SLIDER_WIDTH = 60.0f;
    const float SLIDER_HEIGHT = 300.0f;
    const float SLIDER_MARGIN = 40.0f;
    const float SLIDER_SPACING = 30.0f;

    SliderConfig sizeSlider = {
        .x = SLIDER_MARGIN,
        .y = height / 2.0f - SLIDER_HEIGHT - SLIDER_SPACING / 2.0f,
        .width = SLIDER_WIDTH,
        .height = SLIDER_HEIGHT,
        .value = 0.25f,  // 25% = 50px brush (range 10-200)
        .minVal = 10.0f,
        .maxVal = 200.0f,
        .isDragging = false
    };

    SliderConfig opacitySlider = {
        .x = SLIDER_MARGIN,
        .y = height / 2.0f + SLIDER_SPACING / 2.0f,
        .width = SLIDER_WIDTH,
        .height = SLIDER_HEIGHT,
        .value = 0.9f,  // 90% opacity
        .minVal = 0.0f,
        .maxVal = 1.0f,
        .isDragging = false
    };

    // =============================================================================
    // Initialize Color Button and Picker
    // =============================================================================

    const float COLOR_BUTTON_SIZE = 70.0f;
    ColorButtonConfig colorButton = {
        .x = SLIDER_MARGIN - (COLOR_BUTTON_SIZE - SLIDER_WIDTH) / 2.0f,  // Center under sliders
        .y = opacitySlider.y + opacitySlider.height + SLIDER_SPACING,
        .size = COLOR_BUTTON_SIZE
    };

    // Calculate color picker panel size
    float pickerWidth = COLOR_GRID_COLS * (COLOR_SWATCH_SIZE + COLOR_SWATCH_GAP) - COLOR_SWATCH_GAP + COLOR_PICKER_PADDING * 2;
    float pickerHeight = COLOR_GRID_ROWS * (COLOR_SWATCH_SIZE + COLOR_SWATCH_GAP) - COLOR_SWATCH_GAP + COLOR_PICKER_PADDING * 2;

    ColorPickerState colorPicker = {
        .isOpen = false,
        .x = colorButton.x + colorButton.size + 20.0f,  // Position to right of button
        .y = colorButton.y - pickerHeight / 2.0f + colorButton.size / 2.0f,  // Center vertically with button
        .width = pickerWidth,
        .height = pickerHeight,
        .currentR = 0.15f,  // Start with blue
        .currentG = 0.45f,
        .currentB = 0.75f
    };

    // Ensure picker stays on screen
    if (colorPicker.y < 10.0f) colorPicker.y = 10.0f;
    if (colorPicker.y + pickerHeight > height - 10.0f) colorPicker.y = height - pickerHeight - 10.0f;

    // =============================================================================
    // Initialize Texture Buttons (Shape and Grain)
    // =============================================================================
    const float TEXTURE_BUTTON_SIZE = 60.0f;
    const float TEXTURE_BUTTON_GAP = 10.0f;

    // Position texture buttons at top-right corner of the canvas (portrait coords)
    // Due to 90 rotation, this appears at top-right in landscape view
    // Note: coordinate system is rotated - portrait (width x height) maps to landscape display
    float textureButtonsX = width - TEXTURE_BUTTON_SIZE * 2 - TEXTURE_BUTTON_GAP - 40.0f;
    float textureButtonsY = height - TEXTURE_BUTTON_SIZE * 2 - TEXTURE_BUTTON_GAP - 40.0f;

    TextureButtonConfig shapeTextureButton = {
        .x = textureButtonsX,
        .y = textureButtonsY,
        .width = TEXTURE_BUTTON_SIZE,
        .height = TEXTURE_BUTTON_SIZE,
        .type = TextureTypeShape,
        .hasTexture = false,
        .textureId = -1
    };

    TextureButtonConfig grainTextureButton = {
        .x = textureButtonsX + TEXTURE_BUTTON_SIZE + TEXTURE_BUTTON_GAP,
        .y = textureButtonsY,
        .width = TEXTURE_BUTTON_SIZE,
        .height = TEXTURE_BUTTON_SIZE,
        .type = TextureTypeGrain,
        .hasTexture = false,
        .textureId = -1
    };

    // =============================================================================
    // Initialize Brush Picker Button
    // =============================================================================

    // Position brush button above the sliders
    BrushButtonConfig brushButton = {
        .x = SLIDER_MARGIN,
        .y = sizeSlider.y - BRUSH_BUTTON_HEIGHT - 30.0f,
        .width = BRUSH_BUTTON_WIDTH,
        .height = BRUSH_BUTTON_HEIGHT
    };

    // Position eraser button to the right of brush button
    EraserButtonConfig eraserButton = {
        .x = brushButton.x + brushButton.width + 20.0f,
        .y = brushButton.y + (brushButton.height - ERASER_BUTTON_SIZE) / 2,
        .size = ERASER_BUTTON_SIZE
    };

    // Initialize brush picker panel - position in center of screen
    float brushPickerWidth = BRUSH_PICKER_COLS * (BRUSH_PICKER_ITEM_SIZE + BRUSH_PICKER_ITEM_GAP) + BRUSH_PICKER_PADDING * 2 - BRUSH_PICKER_ITEM_GAP;
    float brushPickerHeight = 800.0f;  // Show more brushes
    BrushPickerConfig brushPicker = {
        .x = (width - brushPickerWidth) / 2,
        .y = (height - brushPickerHeight) / 2,
        .width = brushPickerWidth,
        .height = brushPickerHeight,
        .isOpen = true,  // Start open for testing thumbnails
        .scrollOffset = 0
    };

    // Calculate initial brush values from slider positions
    float brushSize = sizeSlider.minVal + sizeSlider.value * (sizeSlider.maxVal - sizeSlider.minVal);
    float brushOpacity = opacitySlider.minVal + opacitySlider.value * (opacitySlider.maxVal - opacitySlider.minVal);

    // Set DEFAULT brush settings (will be overridden by loaded brush)
    metal_stamp_set_brush_type(1);  // Textured brush
    metal_stamp_set_brush_hardness(0.35f);
    metal_stamp_set_brush_spacing(0.06f);
    metal_stamp_set_brush_grain_scale(1.8f);
    metal_stamp_set_brush_size_pressure(0.8f);
    metal_stamp_set_brush_opacity_pressure(0.3f);
    metal_stamp_set_brush_scatter(3.0f);
    metal_stamp_set_brush_size_jitter(0.15f);
    metal_stamp_set_brush_opacity_jitter(0.1f);

    // Load brushes from bundled brushset - this overrides defaults with actual brush settings
    loadBrushesFromBundledFile();

    // Set user-controlled values (these don't come from brush, only from UI)
    metal_stamp_set_brush_size(brushSize);
    metal_stamp_set_brush_opacity(brushOpacity);
    metal_stamp_set_brush_color(colorPicker.currentR, colorPicker.currentG, colorPicker.currentB, 1.0f);

    // Clear canvas to off-white paper (same as weave bg-color)
    metal_stamp_clear_canvas(PAPER_BG_R, PAPER_BG_G, PAPER_BG_B, PAPER_BG_A);

    // Initialize frame store for animation
    framestore_init(width, height);
    NSLog(@"[FrameStore] Initialized with canvas %dx%d", width, height);

    // =============================================================================
    // Initialize Canvas Transform and Gesture State
    // =============================================================================

    // Calculate default transform to fit and center canvas on screen
    // Canvas is 4K (3840x2160), screen may have different aspect ratio
    const float canvasWidth = 3840.0f;
    const float canvasHeight = 2160.0f;
    float scaleX = (float)width / canvasWidth;
    float scaleY = (float)height / canvasHeight;
    float defaultScale = fminf(scaleX, scaleY);  // Fit entire canvas

    // Calculate pan to center the canvas
    // Math: for screenCenter to map to canvasCenter in shader:
    // pan = (screenCenter - canvasCenter) * scale
    float screenCenterX = width / 2.0f;
    float screenCenterY = height / 2.0f;
    float canvasCenterX = canvasWidth / 2.0f;
    float canvasCenterY = canvasHeight / 2.0f;
    float defaultPanX = (screenCenterX - canvasCenterX) * defaultScale;
    float defaultPanY = (screenCenterY - canvasCenterY) * defaultScale;

    NSLog(@"[Canvas] Default transform: scale=%.3f, pan=(%.1f, %.1f)", defaultScale, defaultPanX, defaultPanY);

    CanvasTransform canvasTransform = {
        .panX = defaultPanX,
        .panY = defaultPanY,
        .scale = defaultScale,
        .rotation = 0.0f,
        .pivotX = width / 2.0f,
        .pivotY = height / 2.0f
    };

    TwoFingerGesture gesture = {
        .isActive = false,
        .finger0_id = 0,
        .finger1_id = 0,
        .finger0_startX = 0, .finger0_startY = 0,
        .finger1_startX = 0, .finger1_startY = 0,
        .finger0_currX = 0, .finger0_currY = 0,
        .finger1_currX = 0, .finger1_currY = 0,
        .basePanX = 0, .basePanY = 0,
        .baseScale = 1.0f,
        .baseRotation = 0.0f,
        .startTimeMs = 0,
        .startDistance = 0.0f
    };

    ThreeFingerGesture threeFingerGesture = {
        .isActive = false,
        .finger0_id = 0, .finger1_id = 0, .finger2_id = 0,
        .finger0_startX = 0, .finger0_startY = 0,
        .finger1_startX = 0, .finger1_startY = 0,
        .finger2_startX = 0, .finger2_startY = 0,
        .finger0_currX = 0, .finger0_currY = 0,
        .finger1_currX = 0, .finger1_currY = 0,
        .finger2_currX = 0, .finger2_currY = 0,
        .startTimeMs = 0
    };

    // Canvas reset animation state
    CanvasResetAnimation resetAnim = {
        .isAnimating = false,
        .startTimeMs = 0,
        .durationMs = 250.0f,  // 250ms for smooth but snappy feel
        .startPanX = defaultPanX, .startPanY = defaultPanY,
        .startScale = defaultScale,
        .startRotation = 0.0f,
        .targetPanX = defaultPanX, .targetPanY = defaultPanY,
        .targetScale = defaultScale,
        .targetRotation = 0.0f
    };

    // Track single finger for potential gesture start
    bool hasFinger0 = false;
    SDL_FingerID pendingFinger0_id = 0;
    float pendingFinger0_x = 0, pendingFinger0_y = 0;

    // Track drawing state
    bool is_drawing = false;
    bool needs_stroke_restart = false;  // Set when frame changes mid-stroke
    float last_x = 0, last_y = 0;
    float pen_pressure = 1.0f;  // Track Apple Pencil pressure from axis events
    bool pencil_detected = false;  // Set true when Apple Pencil is used - disables finger drawing

    // Helper: end stroke before frame change (used by pulley)
    auto endStrokeForFrameChange = [&]() {
        if (is_drawing && !needs_stroke_restart) {
            metal_stamp_undo_end_stroke();
            framestore_save_current_fast();
            needs_stroke_restart = true;
        }
    };

    // Frame wheel for animation frame navigation (Looom-style)
    // Position in SCREEN coordinates (same as touch events)
    // Metal UI conversion happens in drawFrameWheel
    FrameWheel frameWheel = {
        .centerX = width - 100.0f,    // Right side (screen coords)
        .centerY = height - 140.0f,   // Bottom (screen coords)
        .radius = 70.0f,              // Bigger wheel
        .innerRadius = 25.0f,
        .isDragging = false,
        .dragStartAngle = 0.0f,
        .dragStartFrame = 0
    };

    // Main loop
    bool running = true;
    while (running) {
        @autoreleasepool {  // CRITICAL: Release temporary ObjC objects each frame to prevent memory leak
        // Sync texture button state from globals (updated by picker callback)
        shapeTextureButton.hasTexture = g_shapeTextureHasTexture;
        shapeTextureButton.textureId = g_shapeTextureId;
        grainTextureButton.hasTexture = g_grainTextureHasTexture;
        grainTextureButton.textureId = g_grainTextureId;

        SDL_Event event;
        while (SDL_PollEvent(&event)) {
            switch (event.type) {
                case SDL_EVENT_QUIT:
                    running = false;
                    break;

                case SDL_EVENT_FINGER_DOWN: {
                    // Log ALL finger events to debug pencil detection
                    NSLog(@"[FINGER_DOWN] touchID=%lld (pen=-2)", (long long)event.tfinger.touchID);

                    // Filter out synthetic touch events from pen input
                    if (isSyntheticTouchEvent(event.tfinger.touchID)) {
                        NSLog(@"[FINGER_DOWN] Filtered pen touch");
                        break;
                    }

                    // NOTE: No palm rejection here - finger is used for PULLEY control
                    // even while pencil is drawing. Pulley = time navigation with finger.

                    // Finger events: Used for UI interaction, gestures, and PULLEY
                    // Drawing is done via Apple Pencil (pen events) only

                    // Log raw normalized finger coordinates
                    NSLog(@"[DEBUG] Raw finger: (%.4f, %.4f) * (%d, %d) touchID=%lld",
                          event.tfinger.x, event.tfinger.y, width, height, (long long)event.tfinger.touchID);

                    float x = event.tfinger.x * width;
                    float y = event.tfinger.y * height;
                    SDL_FingerID fingerId = event.tfinger.fingerID;

                    // Check UI elements FIRST (before gesture tracking)
                    bool handledByUI = false;
                    if (!gesture.isActive) {
                        float sliderHitPadding = 30.0f;
                        SliderConfig expandedSize = sizeSlider;
                        expandedSize.x -= sliderHitPadding;
                        expandedSize.width += sliderHitPadding * 2;
                        expandedSize.y -= sliderHitPadding;
                        expandedSize.height += sliderHitPadding * 2;

                        SliderConfig expandedOpacity = opacitySlider;
                        expandedOpacity.x -= sliderHitPadding;
                        expandedOpacity.width += sliderHitPadding * 2;
                        expandedOpacity.y -= sliderHitPadding;
                        expandedOpacity.height += sliderHitPadding * 2;

                        if (isPointInSlider(expandedSize, x, y)) {
                            sizeSlider.isDragging = true;
                            float relY = (y - sizeSlider.y) / sizeSlider.height;
                            sizeSlider.value = 1.0f - std::max(0.0f, std::min(1.0f, relY));
                            brushSize = sizeSlider.minVal + sizeSlider.value * (sizeSlider.maxVal - sizeSlider.minVal);
                            metal_stamp_set_brush_size(brushSize);
                            std::cout << "Size slider: " << (int)brushSize << "px" << std::endl;
                            handledByUI = true;
                        } else if (isPointInSlider(expandedOpacity, x, y)) {
                            opacitySlider.isDragging = true;
                            float relY = (y - opacitySlider.y) / opacitySlider.height;
                            opacitySlider.value = 1.0f - std::max(0.0f, std::min(1.0f, relY));
                            brushOpacity = opacitySlider.minVal + opacitySlider.value * (opacitySlider.maxVal - opacitySlider.minVal);
                            metal_stamp_set_brush_opacity(brushOpacity);
                            std::cout << "Opacity slider: " << (int)(brushOpacity * 100) << "%" << std::endl;
                            handledByUI = true;
                        } else if (isPointInColorPicker(colorPicker, x, y)) {
                            int swatchIdx = getSwatchAtPoint(colorPicker, x, y);
                            if (swatchIdx >= 0) {
                                int col = swatchIdx % COLOR_GRID_COLS;
                                int row = swatchIdx / COLOR_GRID_COLS;
                                getGridColor(col, row, colorPicker.currentR, colorPicker.currentG, colorPicker.currentB);
                                metal_stamp_set_brush_color(colorPicker.currentR, colorPicker.currentG, colorPicker.currentB, 1.0f);
                                colorPicker.isOpen = false;
                                std::cout << "Color selected from picker" << std::endl;
                            }
                            handledByUI = true;
                        } else if (isPointInColorButton(colorButton, x, y)) {
                            colorPicker.isOpen = !colorPicker.isOpen;
                            std::cout << "Color picker " << (colorPicker.isOpen ? "opened" : "closed") << std::endl;
                            handledByUI = true;
                        } else if (colorPicker.isOpen) {
                            colorPicker.isOpen = false;
                            std::cout << "Color picker closed (tap outside)" << std::endl;
                            handledByUI = true;
                        }

                        // Texture buttons removed - frame wheel handles this area now
                        if (isPointInBrushPicker(brushPicker, x, y)) {
                            // Start tracking touch for scroll/tap detection
                            g_brushPickerIsDragging = true;
                            g_brushPickerDragFingerId = fingerId;
                            g_brushPickerDragStartY = y;
                            g_brushPickerDragStartOffset = g_brushPickerScrollOffset;
                            NSLog(@"[BrushPicker] Touch down at y=%.1f, scroll=%.1f", y, g_brushPickerScrollOffset);
                            handledByUI = true;
                        } else if (isPointInBrushButton(brushButton, x, y)) {
                            // Toggle brush picker open/closed
                            brushPicker.isOpen = !brushPicker.isOpen;
                            NSLog(@"[BrushPicker] %s", brushPicker.isOpen ? "Opened" : "Closed");
                            handledByUI = true;
                        } else if (isPointInEraserButton(eraserButton, x, y)) {
                            // Toggle eraser mode
                            g_eraserMode = !g_eraserMode;
                            if (g_eraserMode) {
                                // Set brush color to off-white paper (same as canvas background)
                                metal_stamp_set_brush_color(PAPER_BG_R, PAPER_BG_G, PAPER_BG_B, PAPER_BG_A);
                                NSLog(@"[Eraser] Eraser mode ON");
                            } else {
                                // Restore to current color picker color
                                metal_stamp_set_brush_color(colorPicker.currentR, colorPicker.currentG, colorPicker.currentB, 1.0f);
                                NSLog(@"[Eraser] Eraser mode OFF");
                            }
                            handledByUI = true;
                        } else if (brushPicker.isOpen) {
                            // Tap outside picker closes it
                            brushPicker.isOpen = false;
                            NSLog(@"[BrushPicker] Closed (tap outside)");
                            handledByUI = true;
                        }

                        // Frame wheel touch handling (single finger)
                        if (!handledByUI && isPointInFrameWheel(frameWheel, x, y)) {
                            frameWheel.isDragging = true;
                            frameWheel.dragStartAngle = getWheelAngle(frameWheel, x, y);
                            frameWheel.dragStartFrame = framestore_get_current_frame();
                            // No save needed - frame was saved after drawing ended!
                            NSLog(@"[FrameWheel] Started dragging from frame %d",
                                  frameWheel.dragStartFrame);
                            handledByUI = true;
                        }

                        // Debug: Log tap position vs all UI element bounds
                        NSLog(@"[DEBUG] Tap at (%.1f, %.1f) - width=%d height=%d", x, y, width, height);
                        NSLog(@"[DEBUG]   Brush button at (%.1f, %.1f) size (%.1fx%.1f)",
                              brushButton.x, brushButton.y, brushButton.width, brushButton.height);
                        NSLog(@"[DEBUG]   Size slider at (%.1f, %.1f) size (%.1fx%.1f)",
                              sizeSlider.x, sizeSlider.y, sizeSlider.width, sizeSlider.height);
                        NSLog(@"[DEBUG]   Opacity slider at (%.1f, %.1f) size (%.1fx%.1f)",
                              opacitySlider.x, opacitySlider.y, opacitySlider.width, opacitySlider.height);
                    }

                    // If not handled by UI, track for gestures OR single-finger drawing
                    if (!handledByUI) {
                        // Check for third finger during two-finger gesture
                        if (gesture.isActive && !threeFingerGesture.isActive &&
                            fingerId != gesture.finger0_id && fingerId != gesture.finger1_id) {
                            // Third finger down - start three-finger gesture (for redo)
                            threeFingerGesture.isActive = true;
                            threeFingerGesture.finger0_id = gesture.finger0_id;
                            threeFingerGesture.finger1_id = gesture.finger1_id;
                            threeFingerGesture.finger2_id = fingerId;
                            threeFingerGesture.finger0_startX = gesture.finger0_currX;
                            threeFingerGesture.finger0_startY = gesture.finger0_currY;
                            threeFingerGesture.finger1_startX = gesture.finger1_currX;
                            threeFingerGesture.finger1_startY = gesture.finger1_currY;
                            threeFingerGesture.finger2_startX = event.tfinger.x;
                            threeFingerGesture.finger2_startY = event.tfinger.y;
                            threeFingerGesture.finger0_currX = threeFingerGesture.finger0_startX;
                            threeFingerGesture.finger0_currY = threeFingerGesture.finger0_startY;
                            threeFingerGesture.finger1_currX = threeFingerGesture.finger1_startX;
                            threeFingerGesture.finger1_currY = threeFingerGesture.finger1_startY;
                            threeFingerGesture.finger2_currX = threeFingerGesture.finger2_startX;
                            threeFingerGesture.finger2_currY = threeFingerGesture.finger2_startY;
                            threeFingerGesture.startTimeMs = SDL_GetTicks();
                            std::cout << "Three-finger gesture started (for redo)" << std::endl;
                        }
                        else if (!gesture.isActive) {
                            // NOTE: SDL_HINT_PEN_TOUCH_EVENTS="0" prevents pencil from generating
                            // finger events, so we don't need to filter them here.
                            if (!hasFinger0) {
                                // First finger down - activate PULLEY IMMEDIATELY
                                hasFinger0 = true;
                                pendingFinger0_id = fingerId;
                                pendingFinger0_x = event.tfinger.x;
                                pendingFinger0_y = event.tfinger.y;

                                // Activate pulley IMMEDIATELY - no delay!
                                // NOTE: Do NOT call framestore_save_current() here - it takes 500ms!
                                // Frame will be saved on first movement when actually needed.
                                g_pulley.active = true;
                                g_pulley.firstMoveDone = false;
                                g_pulley.lockoutUntilMs = 0;
                                g_pulley.startX = x;
                                g_pulley.startY = y;
                                g_pulley.fingerX = x;
                                g_pulley.fingerY = y;
                                g_pulley.centerX = x - g_pulley.radius;  // Pulley center to the left
                                g_pulley.centerY = y;
                                g_pulley.referenceAngle = 0;  // Will be set after lockout
                                g_pulley.startFrame = framestore_get_current_frame();
                                NSLog(@"[Pulley] IMMEDIATE activation at (%.1f, %.1f), frame %d", x, y, g_pulley.startFrame);
                            } else if (pendingFinger0_id != fingerId) {
                                // Second finger down - STOP pulley and start two-finger gesture!
                                if (g_pulley.active) {
                                    g_pulley.active = false;
                                    NSLog(@"[Pulley] Deactivated - switching to gesture");
                                }
                                if (is_drawing) {
                                    metal_stamp_undo_cancel_stroke();  // Cancel incomplete stroke
                                    is_drawing = false;
                                    std::cout << "Drawing cancelled - switching to gesture" << std::endl;
                                }
                                gesture.isActive = true;
                                gesture.finger0_id = pendingFinger0_id;
                                gesture.finger1_id = fingerId;
                                gesture.finger0_startX = pendingFinger0_x;
                                gesture.finger0_startY = pendingFinger0_y;
                                gesture.finger1_startX = event.tfinger.x;
                                gesture.finger1_startY = event.tfinger.y;
                                gesture.finger0_currX = gesture.finger0_startX;
                                gesture.finger0_currY = gesture.finger0_startY;
                                gesture.finger1_currX = gesture.finger1_startX;
                                gesture.finger1_currY = gesture.finger1_startY;
                                // Store current transform as baseline
                                gesture.basePanX = canvasTransform.panX;
                                gesture.basePanY = canvasTransform.panY;
                                gesture.baseScale = canvasTransform.scale;
                                gesture.baseRotation = canvasTransform.rotation;
                                // For quick-pinch and tap detection
                                gesture.startTimeMs = SDL_GetTicks();
                                gesture.startDistance = pointDistance(
                                    gesture.finger0_startX * width, gesture.finger0_startY * height,
                                    gesture.finger1_startX * width, gesture.finger1_startY * height
                                );
                                std::cout << "Two-finger gesture started (scale: " << canvasTransform.scale
                                          << ", rotation: " << canvasTransform.rotation << ")" << std::endl;
                            }
                        }
                    }
                    break;
                }

                case SDL_EVENT_FINGER_MOTION: {
                    if (isSyntheticTouchEvent(event.tfinger.touchID)) {
                        break;
                    }

                    // NOTE: No palm rejection - finger controls PULLEY even while pencil draws

                    float x = event.tfinger.x * width;
                    float y = event.tfinger.y * height;
                    SDL_FingerID fingerId = event.tfinger.fingerID;

                    // Handle three-finger gesture motion
                    if (threeFingerGesture.isActive) {
                        if (fingerId == threeFingerGesture.finger0_id) {
                            threeFingerGesture.finger0_currX = event.tfinger.x;
                            threeFingerGesture.finger0_currY = event.tfinger.y;
                        } else if (fingerId == threeFingerGesture.finger1_id) {
                            threeFingerGesture.finger1_currX = event.tfinger.x;
                            threeFingerGesture.finger1_currY = event.tfinger.y;
                        } else if (fingerId == threeFingerGesture.finger2_id) {
                            threeFingerGesture.finger2_currX = event.tfinger.x;
                            threeFingerGesture.finger2_currY = event.tfinger.y;
                        }
                    }
                    // Handle two-finger gesture motion
                    else if (gesture.isActive) {
                        // Update the moving finger's current position
                        if (fingerId == gesture.finger0_id) {
                            gesture.finger0_currX = event.tfinger.x;
                            gesture.finger0_currY = event.tfinger.y;
                        } else if (fingerId == gesture.finger1_id) {
                            gesture.finger1_currX = event.tfinger.x;
                            gesture.finger1_currY = event.tfinger.y;
                        }
                        // Update canvas transform from gesture
                        updateTransformFromGesture(canvasTransform, gesture, width, height);
                    }
                    // NOTE: Single-finger drawing removed - pencil only!
                    // Handle PULLEY ACTIVE - unified gesture handling
                    // 1. First movement  change one frame, start 800ms lockout
                    // 2. During lockout  no frame changes
                    // 3. After lockout  rotation scrubbing
                    else if (g_pulley.active && hasFinger0 && fingerId == pendingFinger0_id) {
                        pendingFinger0_x = event.tfinger.x;
                        pendingFinger0_y = event.tfinger.y;
                        g_pulley.fingerX = x;
                        g_pulley.fingerY = y;

                        Uint64 now = SDL_GetTicks();
                        const float PI = 3.14159265f;

                        if (!g_pulley.firstMoveDone) {
                            // PHASE 1: First movement detection (vertical)
                            float deltaY = y - g_pulley.startY;
                            const float FIRST_MOVE_THRESHOLD = 20.0f;  // 20px threshold

                            if (fabsf(deltaY) > FIRST_MOVE_THRESHOLD) {
                                endStrokeForFrameChange();
                                // First significant movement - change one frame
                                if (deltaY > 0) {
                                    frame_next();
                                    NSLog(@"[Pulley] First move DOWN -> frame %d", framestore_get_current_frame());
                                } else {
                                    frame_prev();
                                    NSLog(@"[Pulley] First move UP -> frame %d", framestore_get_current_frame());
                                }
                                g_pulley.firstMoveDone = true;
                                g_pulley.lockoutUntilMs = now + PULLEY_LOCKOUT_MS;
                            }
                        }
                        else if (now < g_pulley.lockoutUntilMs) {
                            // PHASE 2: Lockout period - no frame changes
                            // Just track finger position for visual feedback
                        }
                        else {
                            // PHASE 3: After lockout - rotation scrubbing
                            // On first frame after lockout, set reference angle
                            if (g_pulley.referenceAngle == 0 && g_pulley.lockoutUntilMs > 0) {
                                g_pulley.referenceAngle = getPulleyAngle(g_pulley, x, y);
                                g_pulley.startFrame = framestore_get_current_frame();
                                NSLog(@"[Pulley] Lockout ended, rotation reference set at angle %.2f, frame %d",
                                      g_pulley.referenceAngle, g_pulley.startFrame);
                            }

                            // Rotation scrubbing - angle from center to finger controls frame
                            float currentAngle = getPulleyAngle(g_pulley, x, y);
                            float angleDelta = currentAngle - g_pulley.referenceAngle;

                            // Normalize to -PI to PI
                            while (angleDelta > PI) angleDelta -= 2 * PI;
                            while (angleDelta < -PI) angleDelta += 2 * PI;

                            // Map angle delta to frame offset (12 frames = 2*PI)
                            int frameDelta = (int)roundf(angleDelta / (2.0f * PI / 12.0f));
                            int newFrame = g_pulley.startFrame + frameDelta;
                            while (newFrame < 0) newFrame += 12;
                            newFrame = newFrame % 12;

                            // Switch frame if different
                            if (newFrame != framestore_get_current_frame()) {
                                endStrokeForFrameChange();
                                framestore_load_frame(newFrame);
                            }
                        }
                    }
                    // Update pending finger position (in case it becomes part of gesture)
                    else if (hasFinger0 && fingerId == pendingFinger0_id) {
                        pendingFinger0_x = event.tfinger.x;
                        pendingFinger0_y = event.tfinger.y;
                    }
                    // Handle UI slider dragging
                    // Handle brush picker scrolling
                    else if (g_brushPickerIsDragging && fingerId == g_brushPickerDragFingerId) {
                        // Update scroll offset based on drag distance
                        float deltaY = g_brushPickerDragStartY - y;  // Drag down = positive delta = scroll down
                        g_brushPickerScrollOffset = g_brushPickerDragStartOffset + deltaY;
                        // Note: clamping happens in drawBrushPicker
                    }
                    else if (sizeSlider.isDragging) {
                        float relY = (y - sizeSlider.y) / sizeSlider.height;
                        sizeSlider.value = 1.0f - std::max(0.0f, std::min(1.0f, relY));
                        brushSize = sizeSlider.minVal + sizeSlider.value * (sizeSlider.maxVal - sizeSlider.minVal);
                        metal_stamp_set_brush_size(brushSize);
                    } else if (opacitySlider.isDragging) {
                        float relY = (y - opacitySlider.y) / opacitySlider.height;
                        opacitySlider.value = 1.0f - std::max(0.0f, std::min(1.0f, relY));
                        brushOpacity = opacitySlider.minVal + opacitySlider.value * (opacitySlider.maxVal - opacitySlider.minVal);
                        metal_stamp_set_brush_opacity(brushOpacity);
                    } else if (frameWheel.isDragging) {
                        // Calculate angle change from drag start
                        float currentAngle = getWheelAngle(frameWheel, x, y);
                        float angleDelta = currentAngle - frameWheel.dragStartAngle;

                        // Normalize to -PI to PI
                        const float PI = 3.14159265f;
                        while (angleDelta > PI) angleDelta -= 2 * PI;
                        while (angleDelta < -PI) angleDelta += 2 * PI;

                        // Frame selection is DISCRETE (12 positions)
                        // When wheel rotates clockwise, LOWER frame numbers come to top
                        // So positive angleDelta (clockwise) = SUBTRACT from frame number
                        int frameDelta = (int)roundf(angleDelta / (2.0f * PI / 12.0f));
                        int newFrame = frameWheel.dragStartFrame - frameDelta;  // SUBTRACT to match visual
                        while (newFrame < 0) newFrame += 12;
                        newFrame = newFrame % 12;

                        // Load frame without saving (save happened at drag start)
                        if (newFrame != framestore_get_current_frame()) {
                            framestore_load_frame(newFrame);
                        }
                    }
                    break;
                }

                case SDL_EVENT_FINGER_UP: {
                    if (isSyntheticTouchEvent(event.tfinger.touchID)) {
                        break;
                    }

                    // NOTE: No palm rejection - finger controls PULLEY even while pencil draws

                    SDL_FingerID fingerId = event.tfinger.fingerID;

                    // Constants for tap detection
                    const Uint64 TAP_MAX_DURATION_MS = 200;    // Max duration for a tap
                    const float TAP_MAX_MOVEMENT = 20.0f;     // Max movement in pixels for a tap

                    // Handle three-finger gesture release (for redo)
                    if (threeFingerGesture.isActive) {
                        if (fingerId == threeFingerGesture.finger0_id ||
                            fingerId == threeFingerGesture.finger1_id ||
                            fingerId == threeFingerGesture.finger2_id) {

                            Uint64 gestureDuration = SDL_GetTicks() - threeFingerGesture.startTimeMs;

                            // Check if it was a tap (short duration, minimal movement)
                            float move0 = pointDistance(
                                threeFingerGesture.finger0_startX * width, threeFingerGesture.finger0_startY * height,
                                threeFingerGesture.finger0_currX * width, threeFingerGesture.finger0_currY * height);
                            float move1 = pointDistance(
                                threeFingerGesture.finger1_startX * width, threeFingerGesture.finger1_startY * height,
                                threeFingerGesture.finger1_currX * width, threeFingerGesture.finger1_currY * height);
                            float move2 = pointDistance(
                                threeFingerGesture.finger2_startX * width, threeFingerGesture.finger2_startY * height,
                                threeFingerGesture.finger2_currX * width, threeFingerGesture.finger2_currY * height);

                            float maxMove = std::max({move0, move1, move2});

                            if (gestureDuration < TAP_MAX_DURATION_MS && maxMove < TAP_MAX_MOVEMENT) {
                                // Three-finger tap detected - REDO!
                                if (metal_stamp_can_redo()) {
                                    metal_stamp_redo();
                                    // CRITICAL: Update frame cache after redo so frame switching preserves the redone state
                                    framestore_save_current_fast();
                                    std::cout << " Three-finger tap: REDO!" << std::endl;
                                } else {
                                    std::cout << " Three-finger tap: No redo available" << std::endl;
                                }
                            }

                            threeFingerGesture.isActive = false;
                            gesture.isActive = false;  // Also end two-finger gesture
                            hasFinger0 = false;
                            std::cout << "Three-finger gesture ended" << std::endl;
                        }
                    }
                    // Handle two-finger gesture release
                    else if (gesture.isActive) {
                        if (fingerId == gesture.finger0_id || fingerId == gesture.finger1_id) {
                            // One of the gesture fingers lifted - end gesture

                            Uint64 gestureDuration = SDL_GetTicks() - gesture.startTimeMs;
                            float endDistance = pointDistance(
                                gesture.finger0_currX * width, gesture.finger0_currY * height,
                                gesture.finger1_currX * width, gesture.finger1_currY * height
                            );
                            float distanceRatio = gesture.startDistance > 0 ? endDistance / gesture.startDistance : 1.0f;

                            // Check for two-finger tap (undo) - short duration, minimal movement
                            float move0 = pointDistance(
                                gesture.finger0_startX * width, gesture.finger0_startY * height,
                                gesture.finger0_currX * width, gesture.finger0_currY * height);
                            float move1 = pointDistance(
                                gesture.finger1_startX * width, gesture.finger1_startY * height,
                                gesture.finger1_currX * width, gesture.finger1_currY * height);
                            float maxMove = std::max(move0, move1);

                            if (gestureDuration < TAP_MAX_DURATION_MS && maxMove < TAP_MAX_MOVEMENT) {
                                // Two-finger tap detected - UNDO!
                                if (metal_stamp_can_undo()) {
                                    metal_stamp_undo();
                                    // CRITICAL: Update frame cache after undo so frame switching preserves the undone state
                                    framestore_save_current_fast();
                                    std::cout << " Two-finger tap: UNDO!" << std::endl;
                                } else {
                                    std::cout << " Two-finger tap: No undo available" << std::endl;
                                }
                            }
                            // Quick pinch/spread: short duration (<300ms) and significant distance change
                            else if (gestureDuration < 300) {
                                const float PINCH_THRESHOLD = 0.7f;
                                const float SPREAD_THRESHOLD = 1.4f;

                                if (distanceRatio < PINCH_THRESHOLD || distanceRatio > SPREAD_THRESHOLD) {
                                    // Start animated reset to default view
                                    resetAnim.isAnimating = true;
                                    resetAnim.startTimeMs = SDL_GetTicks();

                                    // Store current values as start
                                    resetAnim.startPanX = canvasTransform.panX;
                                    resetAnim.startPanY = canvasTransform.panY;
                                    resetAnim.startScale = canvasTransform.scale;
                                    resetAnim.startRotation = canvasTransform.rotation;

                                    // Target: default view (centered canvas with fitScale)
                                    resetAnim.targetPanX = defaultPanX;
                                    resetAnim.targetPanY = defaultPanY;
                                    resetAnim.targetScale = defaultScale;
                                    resetAnim.targetRotation = 0.0f;

                                    // CRITICAL: Reset pivot to screen center immediately
                                    // (pivot changes during gestures but must return to center for correct default view)
                                    canvasTransform.pivotX = width / 2.0f;
                                    canvasTransform.pivotY = height / 2.0f;

                                    std::cout << " Quick-pinch: Animating to default view..." << std::endl;
                                }
                            }

                            gesture.isActive = false;
                            hasFinger0 = false;
                            std::cout << "Two-finger gesture ended (scale: " << canvasTransform.scale
                                      << ", rotation: " << (canvasTransform.rotation * 180.0f / M_PI) << ""
                                      << ", pan: " << canvasTransform.panX << ", " << canvasTransform.panY << ")" << std::endl;
                        }
                    }
                    // NOTE: Single-finger drawing removed - pencil only!
                    // Handle PULLEY release - deactivate pulley
                    else if (g_pulley.active && hasFinger0 && fingerId == pendingFinger0_id) {
                        g_pulley.active = false;
                        hasFinger0 = false;
                        NSLog(@"[Pulley] Deactivated on finger up, frame %d", framestore_get_current_frame());
                    }
                    // Handle pending single finger release (non-drawing, legacy swipe)
                    else if (hasFinger0 && fingerId == pendingFinger0_id) {
                        hasFinger0 = false;
                    }
                    // Handle UI slider release
                    else if (sizeSlider.isDragging) {
                        sizeSlider.isDragging = false;
                        std::cout << "Size set to: " << (int)brushSize << "px" << std::endl;
                    } else if (opacitySlider.isDragging) {
                        opacitySlider.isDragging = false;
                        std::cout << "Opacity set to: " << (int)(brushOpacity * 100) << "%" << std::endl;
                    }
                    // Handle brush picker finger up - detect tap vs scroll
                    else if (g_brushPickerIsDragging && fingerId == g_brushPickerDragFingerId) {
                        float y = event.tfinger.y * height;
                        float x = event.tfinger.x * width;
                        float totalMovement = std::abs(y - g_brushPickerDragStartY);

                        // If minimal movement, treat as tap (select brush)
                        const float TAP_THRESHOLD = 15.0f;  // pixels
                        if (totalMovement < TAP_THRESHOLD) {
                            int brushIdx = getBrushAtPoint(brushPicker, x, y);
                            NSLog(@"[BrushPicker] Tap detected (moved %.1fpx), checking brush at (%.1f,%.1f) -> idx=%d",
                                  totalMovement, x, y, brushIdx);
                            if (brushIdx >= 0) {
                                g_selectedBrushIndex = brushIdx;
                                g_selectedBrushId = [[g_brushIds objectAtIndex:brushIdx] intValue];
                                [BrushImporter applyBrush:g_selectedBrushId];
                                NSLog(@"[BrushPicker] Selected brush %d from picker", brushIdx);
                                brushPicker.isOpen = false;  // Close picker after selection
                            }
                        } else {
                            NSLog(@"[BrushPicker] Scroll ended (moved %.1fpx), scroll=%.1f",
                                  totalMovement, g_brushPickerScrollOffset);
                        }

                        g_brushPickerIsDragging = false;
                    }
                    // Handle frame wheel release
                    else if (frameWheel.isDragging) {
                        frameWheel.isDragging = false;
                        NSLog(@"[FrameWheel] Released on frame %d", framestore_get_current_frame());
                    }
                    break;
                }

                // =============================================================
                // Apple Pencil / Stylus Events (SDL3 Pen API)
                // =============================================================

                case SDL_EVENT_PEN_AXIS: {
                    // Track pressure from axis events
                    if (event.paxis.axis == SDL_PEN_AXIS_PRESSURE) {
                        pen_pressure = event.paxis.value;
                    }
                    break;
                }

                case SDL_EVENT_PEN_DOWN: {
                    // Apple Pencil detected - disable finger drawing
                    if (!pencil_detected) {
                        pencil_detected = true;
                        NSLog(@"[Input] Apple Pencil detected - finger drawing disabled");
                    }

                    // Pen coordinates are in window points, need to convert to pixels
                    float screenX = event.ptouch.x * pixelDensity;
                    float screenY = event.ptouch.y * pixelDensity;

                    // pen_pressure is set via SDL_EVENT_PEN_AXIS events
                    if (pen_pressure <= 0.0f) pen_pressure = 1.0f;

                    NSLog(@"[PEN] DOWN: raw(%.1f,%.1f) * %.1f = screen(%.1f,%.1f) pressure=%.2f",
                          event.ptouch.x, event.ptouch.y, pixelDensity, screenX, screenY, pen_pressure);

                    // Check if touch is on a slider (UI is in screen space, not canvas space)
                    float sliderHitPadding = 30.0f;
                    SliderConfig expandedSize = sizeSlider;
                    expandedSize.x -= sliderHitPadding;
                    expandedSize.width += sliderHitPadding * 2;
                    expandedSize.y -= sliderHitPadding;
                    expandedSize.height += sliderHitPadding * 2;

                    SliderConfig expandedOpacity = opacitySlider;
                    expandedOpacity.x -= sliderHitPadding;
                    expandedOpacity.width += sliderHitPadding * 2;
                    expandedOpacity.y -= sliderHitPadding;
                    expandedOpacity.height += sliderHitPadding * 2;

                    if (isPointInSlider(expandedSize, screenX, screenY)) {
                        sizeSlider.isDragging = true;
                        float relY = (screenY - sizeSlider.y) / sizeSlider.height;
                        sizeSlider.value = 1.0f - std::max(0.0f, std::min(1.0f, relY));
                        brushSize = sizeSlider.minVal + sizeSlider.value * (sizeSlider.maxVal - sizeSlider.minVal);
                        metal_stamp_set_brush_size(brushSize);
                        std::cout << "Size slider (pen): " << (int)brushSize << "px" << std::endl;
                    } else if (isPointInSlider(expandedOpacity, screenX, screenY)) {
                        opacitySlider.isDragging = true;
                        float relY = (screenY - opacitySlider.y) / opacitySlider.height;
                        opacitySlider.value = 1.0f - std::max(0.0f, std::min(1.0f, relY));
                        brushOpacity = opacitySlider.minVal + opacitySlider.value * (opacitySlider.maxVal - opacitySlider.minVal);
                        metal_stamp_set_brush_opacity(brushOpacity);
                        std::cout << "Opacity slider (pen): " << (int)(brushOpacity * 100) << "%" << std::endl;
                    } else if (isPointInColorPicker(colorPicker, screenX, screenY)) {
                        // Check if tapped a color swatch (pen)
                        int swatchIdx = getSwatchAtPoint(colorPicker, screenX, screenY);
                        if (swatchIdx >= 0) {
                            int col = swatchIdx % COLOR_GRID_COLS;
                            int row = swatchIdx / COLOR_GRID_COLS;
                            getGridColor(col, row, colorPicker.currentR, colorPicker.currentG, colorPicker.currentB);
                            metal_stamp_set_brush_color(colorPicker.currentR, colorPicker.currentG, colorPicker.currentB, 1.0f);
                            colorPicker.isOpen = false;
                            std::cout << "Color selected from picker (pen)" << std::endl;
                        }
                    } else if (isPointInColorButton(colorButton, screenX, screenY)) {
                        // Toggle color picker panel (pen)
                        colorPicker.isOpen = !colorPicker.isOpen;
                        std::cout << "Color picker " << (colorPicker.isOpen ? "opened" : "closed") << " (pen)" << std::endl;
                    } else if (colorPicker.isOpen) {
                        // Tap outside picker closes it (pen)
                        colorPicker.isOpen = false;
                        std::cout << "Color picker closed (tap outside, pen)" << std::endl;
                    // Texture buttons removed - frame wheel handles this area now
                    } else if (isPointInBrushPicker(brushPicker, screenX, screenY)) {
                        // Handle tap on brush picker (pen)
                        int brushIdx = getBrushAtPoint(brushPicker, screenX, screenY);
                        NSLog(@"[BrushPicker] DEBUG (pen): tap(%.1f,%.1f) brushIdx=%d", screenX, screenY, brushIdx);
                        if (brushIdx >= 0) {
                            g_selectedBrushIndex = brushIdx;
                            g_selectedBrushId = [[g_brushIds objectAtIndex:brushIdx] intValue];
                            [BrushImporter applyBrush:g_selectedBrushId];
                            NSLog(@"[BrushPicker] Selected brush %d from picker (pen)", brushIdx);
                            brushPicker.isOpen = false;
                        }
                    } else if (isPointInBrushButton(brushButton, screenX, screenY)) {
                        // Toggle brush picker open/closed (pen)
                        brushPicker.isOpen = !brushPicker.isOpen;
                        NSLog(@"[BrushPicker] %s (pen)", brushPicker.isOpen ? "Opened" : "Closed");
                    } else if (isPointInEraserButton(eraserButton, screenX, screenY)) {
                        // Toggle eraser mode (pen)
                        g_eraserMode = !g_eraserMode;
                        if (g_eraserMode) {
                            // Set brush color to off-white paper (same as canvas background)
                            metal_stamp_set_brush_color(PAPER_BG_R, PAPER_BG_G, PAPER_BG_B, PAPER_BG_A);
                            NSLog(@"[Eraser] Eraser mode ON (pen)");
                        } else {
                            metal_stamp_set_brush_color(colorPicker.currentR, colorPicker.currentG, colorPicker.currentB, 1.0f);
                            NSLog(@"[Eraser] Eraser mode OFF (pen)");
                        }
                    } else if (brushPicker.isOpen) {
                        // Tap outside picker closes it (pen)
                        brushPicker.isOpen = false;
                        NSLog(@"[BrushPicker] Closed (tap outside, pen)");
                    } else {
                        // Drawing with Apple Pencil - convert screen coords to canvas coords
                        float canvasX, canvasY;
                        screenToCanvas(screenX, screenY, canvasTransform, width, height, canvasX, canvasY);

                        // PALM REJECTION: Cancel canvas manipulation gestures (not pulley!)
                        // Pulley (hasFinger0) should continue working alongside pencil drawing
                        if (gesture.isActive) {
                            gesture.isActive = false;
                            NSLog(@"[PalmReject] Cancelled two-finger gesture - pencil drawing started");
                        }
                        // NOTE: Do NOT cancel hasFinger0/pulley - it works alongside pencil!
                        if (threeFingerGesture.isActive) {
                            threeFingerGesture.isActive = false;
                            NSLog(@"[PalmReject] Cancelled three-finger gesture - pencil drawing started");
                        }

                        metal_stamp_undo_begin_stroke(canvasX, canvasY, pen_pressure);
                        last_x = canvasX;
                        last_y = canvasY;
                        is_drawing = true;
                    }
                    break;
                }

                case SDL_EVENT_PEN_MOTION: {
                    // Pen coordinates are in window points, need to convert to pixels
                    float screenX = event.pmotion.x * pixelDensity;
                    float screenY = event.pmotion.y * pixelDensity;

                    // pen_pressure is updated via SDL_EVENT_PEN_AXIS events
                    if (pen_pressure <= 0.0f) pen_pressure = 1.0f;

                    if (sizeSlider.isDragging) {
                        float relY = (screenY - sizeSlider.y) / sizeSlider.height;
                        sizeSlider.value = 1.0f - std::max(0.0f, std::min(1.0f, relY));
                        brushSize = sizeSlider.minVal + sizeSlider.value * (sizeSlider.maxVal - sizeSlider.minVal);
                        metal_stamp_set_brush_size(brushSize);
                    } else if (opacitySlider.isDragging) {
                        float relY = (screenY - opacitySlider.y) / opacitySlider.height;
                        opacitySlider.value = 1.0f - std::max(0.0f, std::min(1.0f, relY));
                        brushOpacity = opacitySlider.minVal + opacitySlider.value * (opacitySlider.maxVal - opacitySlider.minVal);
                        metal_stamp_set_brush_opacity(brushOpacity);
                    } else if (is_drawing) {
                        // Convert screen coords to canvas coords for drawing
                        float canvasX, canvasY;
                        screenToCanvas(screenX, screenY, canvasTransform, width, height, canvasX, canvasY);

                        // If frame changed mid-stroke, start a new stroke in the new frame
                        if (needs_stroke_restart) {
                            metal_stamp_undo_begin_stroke(canvasX, canvasY, pen_pressure);
                            last_x = canvasX;
                            last_y = canvasY;
                            needs_stroke_restart = false;
                            NSLog(@"[PEN] Restarted stroke in new frame at (%.1f, %.1f)", canvasX, canvasY);
                        } else {
                            float dx = canvasX - last_x;
                            float dy = canvasY - last_y;
                            if (dx*dx + dy*dy > 1.0f) {
                                metal_stamp_undo_add_stroke_point(canvasX, canvasY, pen_pressure);
                                last_x = canvasX;
                                last_y = canvasY;
                            }
                        }
                    }
                    break;
                }

                case SDL_EVENT_PEN_UP: {
                    if (sizeSlider.isDragging) {
                        sizeSlider.isDragging = false;
                        std::cout << "Size set to (pen): " << (int)brushSize << "px" << std::endl;
                    } else if (opacitySlider.isDragging) {
                        opacitySlider.isDragging = false;
                        std::cout << "Opacity set to (pen): " << (int)(brushOpacity * 100) << "%" << std::endl;
                    } else if (is_drawing) {
                        // If stroke was already ended due to frame change, just clear flag
                        if (needs_stroke_restart) {
                            needs_stroke_restart = false;
                            NSLog(@"[PEN] Pen up - stroke was already ended for frame change");
                        } else {
                            std::cout << "Pen up - ending stroke" << std::endl;
                            metal_stamp_undo_end_stroke();
                            // Save to GPU cache AFTER drawing - so frame switching is instant!
                            framestore_save_current_fast();
                        }
                        is_drawing = false;
                    }
                    pen_pressure = 1.0f;  // Reset pressure
                    break;
                }

                // NOTE: On iOS simulator, mouse events also fire alongside finger events
                // but with different coordinates (pixels vs normalized). We only handle
                // finger events to avoid duplicate strokes.
                // Mouse events are commented out for iOS:
                /*
                case SDL_EVENT_MOUSE_BUTTON_DOWN: {
                    float x = event.button.x;
                    float y = event.button.y;
                    std::cout << "Mouse down: " << x << ", " << y << std::endl;
                    metal_stamp_undo_begin_stroke(x, y, 1.0f);
                    is_drawing = true;
                    break;
                }

                case SDL_EVENT_MOUSE_MOTION: {
                    if (is_drawing) {
                        float x = event.motion.x;
                        float y = event.motion.y;
                        metal_stamp_undo_add_stroke_point(x, y, 1.0f);
                    }
                    break;
                }

                case SDL_EVENT_MOUSE_BUTTON_UP: {
                    if (is_drawing) {
                        std::cout << "Mouse up - ending stroke" << std::endl;
                        metal_stamp_undo_end_stroke();
                        is_drawing = false;
                    }
                    break;
                }
                */
            }
        }

        // Render the current stroke (for real-time preview)
        metal_stamp_render_stroke();

        // Update canvas reset animation (Procreate-style smooth snap)
        if (resetAnim.isAnimating) {
            Uint64 elapsed = SDL_GetTicks() - resetAnim.startTimeMs;
            float t = (float)elapsed / resetAnim.durationMs;

            if (t >= 1.0f) {
                // Animation complete
                t = 1.0f;
                resetAnim.isAnimating = false;
                std::cout << " Canvas reset animation complete" << std::endl;
            }

            // Apply easing
            float easedT = easeOutCubic(t);

            // Interpolate all transform values
            canvasTransform.panX = lerp(resetAnim.startPanX, resetAnim.targetPanX, easedT);
            canvasTransform.panY = lerp(resetAnim.startPanY, resetAnim.targetPanY, easedT);
            canvasTransform.scale = lerp(resetAnim.startScale, resetAnim.targetScale, easedT);
            canvasTransform.rotation = lerpAngle(resetAnim.startRotation, resetAnim.targetRotation, easedT);
        }

        // Apply canvas transform before presenting
        metal_stamp_set_canvas_transform(
            canvasTransform.panX, canvasTransform.panY,
            canvasTransform.scale, canvasTransform.rotation,
            canvasTransform.pivotX, canvasTransform.pivotY
        );

        // Draw UI sliders (queued before present)
        // Size slider - blue tint
        drawVerticalSlider(sizeSlider, height, 0.3f, 0.5f, 0.9f, "Size");
        // Opacity slider - gray/white tint
        drawVerticalSlider(opacitySlider, height, 0.6f, 0.6f, 0.6f, "Opacity");
        // Color picker button
        drawColorButton(colorButton, colorPicker);
        // Color picker panel (if open)
        drawColorPicker(colorPicker);

        // Texture buttons removed - using frame wheel instead

        // Brush picker button
        drawBrushButton(brushButton);

        // Eraser toggle button
        drawEraserButton(eraserButton, g_eraserMode);

        // Brush picker panel (if open)
        drawBrushPicker(brushPicker, height);

        // Frame wheel for animation (Looom-style)
        // Rotation is derived from current frame - no separate state
        int totalFrames = framestore_get_frame_count();
        int currentFrame = framestore_get_current_frame();
        const float PI = 3.14159265f;
        float rotation = -(float)currentFrame / (float)totalFrames * 2.0f * PI;
        drawFrameWheel(frameWheel, totalFrames, currentFrame, rotation);

        // Draw pulley if active (Looom-style time navigation)
        drawPulley(g_pulley, currentFrame, totalFrames);

        // Present with UI overlay
        metal_stamp_present();

        // Small delay to avoid busy-waiting
        SDL_Delay(1);
        }  // End @autoreleasepool - releases all temp ObjC objects
    }

    // Cleanup
    metal_stamp_cleanup();
    SDL_DestroyWindow(window);

    return 0;
}

#endif  // METAL_TEST_MODE

// =============================================================================
// Main Entry Point
// =============================================================================

extern "C" int drawing_mobile_main(int argc, char* argv[]) {
    std::cout << "========================================" << std::endl;
    std::cout << "   Drawing Canvas - iOS" << std::endl;
    std::cout << "========================================" << std::endl;

#if METAL_TEST_MODE
    // Pure C++ Metal test mode
    return metal_test_main();
#else
    // Initialize jank runtime on a large stack thread
    if (!init_jank_runtime_on_large_stack()) {
        std::cerr << "[drawing_mobile] Failed to initialize jank" << std::endl;
        return 1;
    }

    // Call the jank main function
    call_jank_main_impl();

    std::cout << "[drawing_mobile] App finished" << std::endl;
    return 0;
#endif
}
