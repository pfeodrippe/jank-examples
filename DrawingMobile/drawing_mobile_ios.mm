// Drawing Mobile iOS - jank-powered drawing app
// Uses SDL3 + Metal via drawing_canvas.hpp singleton

// Define METAL_TEST_MODE to bypass jank and test Metal directly
#define METAL_TEST_MODE 1

#import <Foundation/Foundation.h>
#import <UIKit/UIKit.h>
#include <iostream>
#include <sstream>
#include <string>
#include <mutex>
#include <condition_variable>
#include <pthread.h>

#include <SDL3/SDL.h>
#include "../src/vybe/app/drawing/native/metal_renderer.h"

// jank runtime headers
// iOS defines 'nil' as a macro which conflicts with jank's object_type::nil
#pragma push_macro("nil")
#undef nil
#include <gc.h>
#include <jank/runtime/context.hpp>
#include <jank/runtime/core.hpp>
#include <jank/runtime/core/make_box.hpp>
#include <jank/runtime/behavior/callable.hpp>
#include <jank/runtime/module/loader.hpp>
#include <jank/error.hpp>

// iOS JIT support
#if defined(JANK_IOS_JIT)
#include <jank/ios/eval_server.hpp>
#include <jank/compile_server/remote_compile.hpp>
extern "C" void jank_debug_print_sizeof();
#endif

#pragma pop_macro("nil")

// =============================================================================
// jank Integration (following SdfViewerMobile pattern)
// =============================================================================

// External AOT init function generated by ios-bundle
extern "C" void jank_aot_init();

static bool jank_initialized = false;

#if defined(JANK_IOS_JIT)
// Hybrid JIT mode: AOT core libs + JIT user code
static bool load_jank_modules_jit() {
    std::cout << "[drawing_mobile] Loading AOT core modules..." << std::endl;

    // jank_aot_init() loads:
    // 1. clojure.core-native, clojure.core, other core libs
    // 2. nREPL native module (jank.nrepl-server.asio) - inserted by ios-bundle when JANK_IOS_JIT
    // 3. application modules
    jank_aot_init();

    std::cout << "[drawing_mobile] All modules loaded! Ready for REPL." << std::endl;
    return true;
}
#endif

// Forward declaration for large-stack wrapper
static bool init_jank_runtime_impl();

// Large stack wrapper for running jank on iOS
// iOS main thread has only ~1MB stack, but jank's recursive codegen needs more.
struct jank_init_result {
    std::mutex mtx;
    std::condition_variable cv;
    bool done = false;
    bool success = false;
};

static void* jank_init_thread_func(void* arg) {
    auto* result = static_cast<jank_init_result*>(arg);

    bool success = init_jank_runtime_impl();

    {
        std::lock_guard<std::mutex> lock(result->mtx);
        result->success = success;
        result->done = true;
    }
    result->cv.notify_one();
    return nullptr;
}

static bool init_jank_runtime_on_large_stack() {
    constexpr size_t STACK_SIZE = 8 * 1024 * 1024; // 8MB stack

    // Initialize GC on main thread FIRST - before creating worker thread
    std::cout << "[drawing_mobile] Initializing Boehm GC on main thread..." << std::endl;
    GC_init();

    // CRITICAL: Disable GC during worker thread execution to avoid
    // "Collecting from unknown thread" errors.
    std::cout << "[drawing_mobile] Disabling GC during initialization..." << std::endl;
    GC_disable();

    pthread_attr_t attr;
    pthread_attr_init(&attr);
    pthread_attr_setstacksize(&attr, STACK_SIZE);

    jank_init_result result;
    pthread_t thread;

    std::cout << "[drawing_mobile] Starting initialization on thread with " << (STACK_SIZE / 1024 / 1024) << "MB stack..." << std::endl;

    int err = pthread_create(&thread, &attr, jank_init_thread_func, &result);
    pthread_attr_destroy(&attr);

    if (err != 0) {
        std::cerr << "[drawing_mobile] Failed to create large-stack thread: " << err << std::endl;
        // Fall back to running on current thread (re-enable GC first)
        GC_enable();
        return init_jank_runtime_impl();
    }

    // Wait for the thread to complete
    {
        std::unique_lock<std::mutex> lock(result.mtx);
        result.cv.wait(lock, [&result] { return result.done; });
    }

    pthread_join(thread, nullptr);

    // Re-enable GC now that initialization is complete
    std::cout << "[drawing_mobile] Re-enabling GC after initialization..." << std::endl;
    GC_enable();

    return result.success;
}

// Initialize jank runtime for iOS (actual implementation)
// NOTE: GC_init() is called by init_jank_runtime_on_large_stack() before this
static bool init_jank_runtime_impl() {
    try {
        std::cout << "[drawing_mobile] Creating runtime context..." << std::endl;
        jank::runtime::__rt_ctx = new (GC_malloc(sizeof(jank::runtime::context)))
            jank::runtime::context{};

#if defined(JANK_IOS_JIT)
        // Print sizeof for key types to help diagnose ABI mismatches
        jank_debug_print_sizeof();

        // Configure and connect to remote compile server on macOS
#if TARGET_OS_SIMULATOR
        std::string const remote_host = "127.0.0.1";
        uint16_t const remote_port = 5572;  // DrawingMobile simulator uses port 5572
#else
        // Device needs Mac's actual IP - update for your network!
        std::string const remote_host = "192.168.2.25";
        uint16_t const remote_port = 5573;  // DrawingMobile device uses port 5573
#endif

        std::cout << "[drawing_mobile] Configuring remote compile server at " << remote_host << ":" << remote_port << "..." << std::endl;
        jank::compile_server::configure_remote_compile(remote_host, remote_port);

        if (jank::compile_server::connect_remote_compile()) {
            std::cout << "[drawing_mobile] Connected to remote compile server!" << std::endl;
        } else {
            std::cout << "[drawing_mobile] Warning: Could not connect to remote compile server." << std::endl;
        }

        // JIT mode: Load modules from bundled source files
        std::cout << "[drawing_mobile] JIT mode - loading modules from source..." << std::endl;
        if (!load_jank_modules_jit()) {
            std::cerr << "[drawing_mobile] JIT module loading failed" << std::endl;
            return false;
        }
#else
        // AOT mode: Load all modules via auto-generated init function
        jank_aot_init();
#endif

        jank_initialized = true;
        std::cout << "[drawing_mobile] Runtime initialized successfully!" << std::endl;
        return true;
    } catch (jtl::ref<jank::error::base> const& e) {
        std::cerr << "[drawing_mobile] Error initializing runtime: " << e->message << std::endl;
        if (e->cause) {
            std::cerr << "[drawing_mobile]   caused by: " << e->cause->message << std::endl;
        }
        return false;
    } catch (const std::exception& e) {
        std::cerr << "[drawing_mobile] Error initializing runtime (std): " << e.what() << std::endl;
        return false;
    }
}

// Call the jank-exported -main function
static void call_jank_main_impl() {
    try {
        // Set up thread bindings (required for dynamic vars like *ns*)
        jank::runtime::context::binding_scope bindings;

        // Find clojure.core/require
        auto require_var = jank::runtime::__rt_ctx->find_var(
            jank::runtime::make_box<jank::runtime::obj::symbol>("clojure.core/require")
        );
        if (require_var.is_nil()) {
            std::cerr << "[drawing_mobile] Could not find clojure.core/require" << std::endl;
            return;
        }

        // Call (require 'vybe.app.drawing)
        std::cout << "[drawing_mobile] Loading vybe.app.drawing..." << std::endl;
        jank::runtime::dynamic_call(
            require_var->deref(),
            jank::runtime::make_box<jank::runtime::obj::symbol>("vybe.app.drawing")
        );
        std::cout << "[drawing_mobile] vybe.app.drawing loaded!" << std::endl;

        // Find and call -main
        auto main_var = jank::runtime::__rt_ctx->intern_var("vybe.app.drawing", "-main");
        if (!main_var.is_ok()) {
            std::cerr << "[drawing_mobile] Could not find vybe.app.drawing/-main" << std::endl;
            return;
        }

        std::cout << "[drawing_mobile] Calling vybe.app.drawing/-main with nREPL port 5581..." << std::endl;
        jank::runtime::dynamic_call(
            main_var.expect_ok()->deref(),
            jank::runtime::make_box<jank::runtime::obj::integer>(5581)
        );

    } catch (jtl::ref<jank::error::base> const& e) {
        std::cerr << "\n";
        std::cerr << "=== jank Runtime Error ===" << std::endl;
        std::cerr << e->message << std::endl;
        if (e->source.file != jank::read::no_source_path) {
            std::cerr << "at " << e->source.to_string() << std::endl;
        }
        if (e->cause) {
            std::cerr << "caused by: " << e->cause->message << std::endl;
        }
    } catch (std::exception& e) {
        std::cerr << "[drawing_mobile] Failed to run app: " << e.what() << std::endl;
    }
}

// =============================================================================
// Metal Test Mode - Pure C++ SDL + Metal rendering (no jank)
// =============================================================================

#if METAL_TEST_MODE

static int metal_test_main() {
    std::cout << "========================================" << std::endl;
    std::cout << "   METAL TEST MODE - Pure C++ Rendering" << std::endl;
    std::cout << "========================================" << std::endl;

    // Create SDL window
    SDL_Window* window = SDL_CreateWindow(
        "Metal Test",
        1024, 768,
        SDL_WINDOW_METAL | SDL_WINDOW_HIGH_PIXEL_DENSITY
    );

    if (!window) {
        std::cerr << "Failed to create window: " << SDL_GetError() << std::endl;
        return 1;
    }

    int width, height;
    SDL_GetWindowSizeInPixels(window, &width, &height);
    std::cout << "Window size: " << width << "x" << height << std::endl;

    // Initialize Metal renderer
    std::cout << "Initializing Metal stamp renderer..." << std::endl;
    if (!metal_stamp_init(window, width, height)) {
        std::cerr << "Failed to initialize Metal renderer!" << std::endl;
        SDL_DestroyWindow(window);
        return 1;
    }
    std::cout << "Metal renderer initialized!" << std::endl;

    // Set brush settings - Huntsman Crayon with pressure dynamics
    metal_stamp_set_brush_type(1);  // Crayon brush!
    metal_stamp_set_brush_size(50.0f);  // Base size
    metal_stamp_set_brush_hardness(0.35f);  // Crayon hardness
    metal_stamp_set_brush_opacity(0.9f);
    metal_stamp_set_brush_spacing(0.06f);  // Tight spacing for smooth strokes
    metal_stamp_set_brush_grain_scale(1.8f);  // Visible paper grain
    metal_stamp_set_brush_color(0.15f, 0.45f, 0.75f, 1.0f);  // Nice blue crayon

    // Pressure dynamics - Apple Pencil / touch pressure affects stroke
    metal_stamp_set_brush_size_pressure(0.8f);    // Pressure strongly affects size
    metal_stamp_set_brush_opacity_pressure(0.3f); // Pressure slightly affects opacity

    // Scatter and jitter for organic crayon feel
    metal_stamp_set_brush_scatter(3.0f);          // Subtle scatter perpendicular to stroke
    metal_stamp_set_brush_size_jitter(0.15f);     // Subtle size variation (15%)
    metal_stamp_set_brush_opacity_jitter(0.1f);   // Subtle opacity variation (10%)

    // Clear canvas to white
    metal_stamp_clear_canvas(1.0f, 1.0f, 1.0f, 1.0f);

    // Track drawing state
    bool is_drawing = false;
    float last_x = 0, last_y = 0;

    // Main loop
    bool running = true;
    while (running) {
        SDL_Event event;
        while (SDL_PollEvent(&event)) {
            switch (event.type) {
                case SDL_EVENT_QUIT:
                    running = false;
                    break;

                case SDL_EVENT_FINGER_DOWN: {
                    // Convert normalized coords to screen pixels
                    float x = event.tfinger.x * width;
                    float y = event.tfinger.y * height;
                    float pressure = event.tfinger.pressure;
                    if (pressure <= 0.0f) pressure = 1.0f;  // Default pressure

                    std::cout << "Touch down: " << x << ", " << y << " (pressure: " << pressure << ")" << std::endl;
                    metal_stamp_begin_stroke(x, y, pressure);
                    last_x = x;
                    last_y = y;
                    is_drawing = true;
                    break;
                }

                case SDL_EVENT_FINGER_MOTION: {
                    if (is_drawing) {
                        float x = event.tfinger.x * width;
                        float y = event.tfinger.y * height;
                        float pressure = event.tfinger.pressure;
                        if (pressure <= 0.0f) pressure = 1.0f;

                        // Only add point if moved more than 1 pixel (avoid spurious motion events)
                        float dx = x - last_x;
                        float dy = y - last_y;
                        if (dx*dx + dy*dy > 1.0f) {
                            metal_stamp_add_stroke_point(x, y, pressure);
                            last_x = x;
                            last_y = y;
                        }
                    }
                    break;
                }

                case SDL_EVENT_FINGER_UP: {
                    if (is_drawing) {
                        std::cout << "Touch up - ending stroke" << std::endl;
                        metal_stamp_end_stroke();
                        is_drawing = false;
                    }
                    break;
                }

                // NOTE: On iOS simulator, mouse events also fire alongside finger events
                // but with different coordinates (pixels vs normalized). We only handle
                // finger events to avoid duplicate strokes.
                // Mouse events are commented out for iOS:
                /*
                case SDL_EVENT_MOUSE_BUTTON_DOWN: {
                    float x = event.button.x;
                    float y = event.button.y;
                    std::cout << "Mouse down: " << x << ", " << y << std::endl;
                    metal_stamp_begin_stroke(x, y, 1.0f);
                    is_drawing = true;
                    break;
                }

                case SDL_EVENT_MOUSE_MOTION: {
                    if (is_drawing) {
                        float x = event.motion.x;
                        float y = event.motion.y;
                        metal_stamp_add_stroke_point(x, y, 1.0f);
                    }
                    break;
                }

                case SDL_EVENT_MOUSE_BUTTON_UP: {
                    if (is_drawing) {
                        std::cout << "Mouse up - ending stroke" << std::endl;
                        metal_stamp_end_stroke();
                        is_drawing = false;
                    }
                    break;
                }
                */
            }
        }

        // Render the current stroke (for real-time preview) and present
        metal_stamp_render_stroke();
        metal_stamp_present();

        // Small delay to avoid busy-waiting
        SDL_Delay(1);
    }

    // Cleanup
    metal_stamp_cleanup();
    SDL_DestroyWindow(window);

    return 0;
}

#endif  // METAL_TEST_MODE

// =============================================================================
// Main Entry Point
// =============================================================================

extern "C" int drawing_mobile_main(int argc, char* argv[]) {
    std::cout << "========================================" << std::endl;
    std::cout << "   Drawing Canvas - iOS" << std::endl;
    std::cout << "========================================" << std::endl;

#if METAL_TEST_MODE
    // Pure C++ Metal test mode
    return metal_test_main();
#else
    // Initialize jank runtime on a large stack thread
    if (!init_jank_runtime_on_large_stack()) {
        std::cerr << "[drawing_mobile] Failed to initialize jank" << std::endl;
        return 1;
    }

    // Call the jank main function
    call_jank_main_impl();

    std::cout << "[drawing_mobile] App finished" << std::endl;
    return 0;
#endif
}
