// Drawing Mobile iOS - jank-powered drawing app
// Uses SDL3 + Metal via drawing_canvas.hpp singleton

#import <Foundation/Foundation.h>
#import <UIKit/UIKit.h>
#include <iostream>
#include <sstream>
#include <string>
#include <mutex>
#include <condition_variable>
#include <pthread.h>

// jank runtime headers
// iOS defines 'nil' as a macro which conflicts with jank's object_type::nil
#pragma push_macro("nil")
#undef nil
#include <gc.h>
#include <jank/runtime/context.hpp>
#include <jank/runtime/core.hpp>
#include <jank/runtime/core/make_box.hpp>
#include <jank/runtime/behavior/callable.hpp>
#include <jank/runtime/module/loader.hpp>
#include <jank/error.hpp>

// iOS JIT support
#if defined(JANK_IOS_JIT)
#include <jank/ios/eval_server.hpp>
#include <jank/compile_server/remote_compile.hpp>
extern "C" void jank_debug_print_sizeof();
#endif

#pragma pop_macro("nil")

// =============================================================================
// jank Integration (following SdfViewerMobile pattern)
// =============================================================================

// External AOT init function generated by ios-bundle
extern "C" void jank_aot_init();

static bool jank_initialized = false;

#if defined(JANK_IOS_JIT)
// Hybrid JIT mode: AOT core libs + JIT user code
static bool load_jank_modules_jit() {
    std::cout << "[drawing_mobile] Loading AOT core modules..." << std::endl;

    // jank_aot_init() loads:
    // 1. clojure.core-native, clojure.core, other core libs
    // 2. nREPL native module (jank.nrepl-server.asio) - inserted by ios-bundle when JANK_IOS_JIT
    // 3. application modules
    jank_aot_init();

    std::cout << "[drawing_mobile] All modules loaded! Ready for REPL." << std::endl;
    return true;
}
#endif

// Forward declaration for large-stack wrapper
static bool init_jank_runtime_impl();

// Large stack wrapper for running jank on iOS
// iOS main thread has only ~1MB stack, but jank's recursive codegen needs more.
struct jank_init_result {
    std::mutex mtx;
    std::condition_variable cv;
    bool done = false;
    bool success = false;
};

static void* jank_init_thread_func(void* arg) {
    auto* result = static_cast<jank_init_result*>(arg);

    bool success = init_jank_runtime_impl();

    {
        std::lock_guard<std::mutex> lock(result->mtx);
        result->success = success;
        result->done = true;
    }
    result->cv.notify_one();
    return nullptr;
}

static bool init_jank_runtime_on_large_stack() {
    constexpr size_t STACK_SIZE = 8 * 1024 * 1024; // 8MB stack

    // Initialize GC on main thread FIRST - before creating worker thread
    std::cout << "[drawing_mobile] Initializing Boehm GC on main thread..." << std::endl;
    GC_init();

    // CRITICAL: Disable GC during worker thread execution to avoid
    // "Collecting from unknown thread" errors.
    std::cout << "[drawing_mobile] Disabling GC during initialization..." << std::endl;
    GC_disable();

    pthread_attr_t attr;
    pthread_attr_init(&attr);
    pthread_attr_setstacksize(&attr, STACK_SIZE);

    jank_init_result result;
    pthread_t thread;

    std::cout << "[drawing_mobile] Starting initialization on thread with " << (STACK_SIZE / 1024 / 1024) << "MB stack..." << std::endl;

    int err = pthread_create(&thread, &attr, jank_init_thread_func, &result);
    pthread_attr_destroy(&attr);

    if (err != 0) {
        std::cerr << "[drawing_mobile] Failed to create large-stack thread: " << err << std::endl;
        // Fall back to running on current thread (re-enable GC first)
        GC_enable();
        return init_jank_runtime_impl();
    }

    // Wait for the thread to complete
    {
        std::unique_lock<std::mutex> lock(result.mtx);
        result.cv.wait(lock, [&result] { return result.done; });
    }

    pthread_join(thread, nullptr);

    // Re-enable GC now that initialization is complete
    std::cout << "[drawing_mobile] Re-enabling GC after initialization..." << std::endl;
    GC_enable();

    return result.success;
}

// Initialize jank runtime for iOS (actual implementation)
// NOTE: GC_init() is called by init_jank_runtime_on_large_stack() before this
static bool init_jank_runtime_impl() {
    try {
        std::cout << "[drawing_mobile] Creating runtime context..." << std::endl;
        jank::runtime::__rt_ctx = new (GC_malloc(sizeof(jank::runtime::context)))
            jank::runtime::context{};

#if defined(JANK_IOS_JIT)
        // Print sizeof for key types to help diagnose ABI mismatches
        jank_debug_print_sizeof();

        // Configure and connect to remote compile server on macOS
#if TARGET_OS_SIMULATOR
        std::string const remote_host = "127.0.0.1";
        uint16_t const remote_port = 5572;  // DrawingMobile simulator uses port 5572
#else
        // Device needs Mac's actual IP - update for your network!
        std::string const remote_host = "192.168.2.25";
        uint16_t const remote_port = 5573;  // DrawingMobile device uses port 5573
#endif

        std::cout << "[drawing_mobile] Configuring remote compile server at " << remote_host << ":" << remote_port << "..." << std::endl;
        jank::compile_server::configure_remote_compile(remote_host, remote_port);

        if (jank::compile_server::connect_remote_compile()) {
            std::cout << "[drawing_mobile] Connected to remote compile server!" << std::endl;
        } else {
            std::cout << "[drawing_mobile] Warning: Could not connect to remote compile server." << std::endl;
        }

        // JIT mode: Load modules from bundled source files
        std::cout << "[drawing_mobile] JIT mode - loading modules from source..." << std::endl;
        if (!load_jank_modules_jit()) {
            std::cerr << "[drawing_mobile] JIT module loading failed" << std::endl;
            return false;
        }
#else
        // AOT mode: Load all modules via auto-generated init function
        jank_aot_init();
#endif

        jank_initialized = true;
        std::cout << "[drawing_mobile] Runtime initialized successfully!" << std::endl;
        return true;
    } catch (jtl::ref<jank::error::base> const& e) {
        std::cerr << "[drawing_mobile] Error initializing runtime: " << e->message << std::endl;
        if (e->cause) {
            std::cerr << "[drawing_mobile]   caused by: " << e->cause->message << std::endl;
        }
        return false;
    } catch (const std::exception& e) {
        std::cerr << "[drawing_mobile] Error initializing runtime (std): " << e.what() << std::endl;
        return false;
    }
}

// Call the jank-exported -main function
static void call_jank_main_impl() {
    try {
        // Set up thread bindings (required for dynamic vars like *ns*)
        jank::runtime::context::binding_scope bindings;

        // Find clojure.core/require
        auto require_var = jank::runtime::__rt_ctx->find_var(
            jank::runtime::make_box<jank::runtime::obj::symbol>("clojure.core/require")
        );
        if (require_var.is_nil()) {
            std::cerr << "[drawing_mobile] Could not find clojure.core/require" << std::endl;
            return;
        }

        // Call (require 'vybe.app.drawing)
        std::cout << "[drawing_mobile] Loading vybe.app.drawing..." << std::endl;
        jank::runtime::dynamic_call(
            require_var->deref(),
            jank::runtime::make_box<jank::runtime::obj::symbol>("vybe.app.drawing")
        );
        std::cout << "[drawing_mobile] vybe.app.drawing loaded!" << std::endl;

        // Find and call -main
        auto main_var = jank::runtime::__rt_ctx->intern_var("vybe.app.drawing", "-main");
        if (!main_var.is_ok()) {
            std::cerr << "[drawing_mobile] Could not find vybe.app.drawing/-main" << std::endl;
            return;
        }

        std::cout << "[drawing_mobile] Calling vybe.app.drawing/-main with nREPL port 5581..." << std::endl;
        jank::runtime::dynamic_call(
            main_var.expect_ok()->deref(),
            jank::runtime::make_box<jank::runtime::obj::integer>(5581)
        );

    } catch (jtl::ref<jank::error::base> const& e) {
        std::cerr << "\n";
        std::cerr << "=== jank Runtime Error ===" << std::endl;
        std::cerr << e->message << std::endl;
        if (e->source.file != jank::read::no_source_path) {
            std::cerr << "at " << e->source.to_string() << std::endl;
        }
        if (e->cause) {
            std::cerr << "caused by: " << e->cause->message << std::endl;
        }
    } catch (std::exception& e) {
        std::cerr << "[drawing_mobile] Failed to run app: " << e.what() << std::endl;
    }
}

// =============================================================================
// Main Entry Point
// =============================================================================

extern "C" int drawing_mobile_main(int argc, char* argv[]) {
    std::cout << "========================================" << std::endl;
    std::cout << "   Drawing Canvas - iOS" << std::endl;
    std::cout << "========================================" << std::endl;

    // Initialize jank runtime on a large stack thread
    if (!init_jank_runtime_on_large_stack()) {
        std::cerr << "[drawing_mobile] Failed to initialize jank" << std::endl;
        return 1;
    }

    // Call the jank main function
    call_jank_main_impl();

    std::cout << "[drawing_mobile] App finished" << std::endl;
    return 0;
}
