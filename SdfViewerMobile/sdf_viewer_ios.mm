// SDF Viewer iOS - Native C++ implementation using sdf_engine.hpp
// This uses the same Vulkan/MoltenVK rendering as macOS
// Now with jank runtime support for iOS AOT compilation

#import <Foundation/Foundation.h>
#import <UIKit/UIKit.h>
#include <iostream>
#include <string>
#include <pthread.h>
#include <atomic>
#include <condition_variable>
#include <mutex>

// Include the SDF engine header (inline functions)
// Note: SDF_ENGINE_IMPLEMENTATION is only defined in sdf_engine_impl.cpp
// to avoid duplicate tinygltf symbols
#include "../vulkan/sdf_engine.hpp"

// jank runtime headers
// iOS defines 'nil' as a macro which conflicts with jank's object_type::nil
#pragma push_macro("nil")
#undef nil
#include <gc.h>
#include <jank/runtime/context.hpp>
#include <jank/runtime/core.hpp>
#include <jank/runtime/behavior/callable.hpp>
#include <jank/runtime/module/loader.hpp>
#include <jank/error.hpp>
#pragma pop_macro("nil")

// =============================================================================
// C++ Bridge Functions for jank
// These are the real implementations that override the weak stubs in AOT code
// =============================================================================

static std::string g_resource_path;
static std::string g_shader_dir;

// Get the iOS bundle resource path
static std::string getBundleResourcePath() {
    NSString* bundlePath = [[NSBundle mainBundle] resourcePath];
    return std::string([bundlePath UTF8String]);
}

extern "C" {

// Lifecycle
bool vybe_ios_init_str(std::string const& shader_dir) {
    std::cout << "[vybe_ios] init_str: " << shader_dir << std::endl;
    g_resource_path = getBundleResourcePath();
    g_shader_dir = g_resource_path + "/" + shader_dir;

    // Enable touch-to-mouse event conversion for iOS
    // This allows touch events to generate synthetic mouse events
    SDL_SetHint(SDL_HINT_TOUCH_MOUSE_EVENTS, "1");
    std::cout << "[vybe_ios] Set SDL_HINT_TOUCH_MOUSE_EVENTS=1" << std::endl;

    if (!sdfx::init(g_shader_dir.c_str())) {
        std::cerr << "[vybe_ios] Failed to initialize SDF engine" << std::endl;
        return false;
    }

    sdfx::set_continuous_mode(true);
    return true;
}

void vybe_ios_cleanup() {
    std::cout << "[vybe_ios] cleanup" << std::endl;
    sdfx::cleanup();
}

bool vybe_ios_should_close() {
    return sdfx::should_close();
}

// Rendering
void vybe_ios_poll_events() {
    sdfx::poll_events_only();
}

void vybe_ios_update_uniforms(float dt) {
    sdfx::update_uniforms(dt);
}

void vybe_ios_draw_frame() {
    sdfx::draw_frame();
}

void vybe_ios_imgui_begin() {
    sdfx::imgui_begin_frame();
}

void vybe_ios_imgui_end() {
    sdfx::imgui_end_frame();
}

// Camera getters
float vybe_ios_get_camera_distance() {
    return sdfx::get_camera_distance();
}

float vybe_ios_get_camera_angle_x() {
    return sdfx::get_camera_angle_x();
}

float vybe_ios_get_camera_angle_y() {
    return sdfx::get_camera_angle_y();
}

float vybe_ios_get_camera_target_y() {
    return sdfx::get_camera_target_y();
}

// Camera setters
void vybe_ios_set_camera_distance(float v) {
    sdfx::set_camera_distance(v);
}

void vybe_ios_set_camera_angle_x(float v) {
    sdfx::set_camera_angle_x(v);
}

void vybe_ios_set_camera_angle_y(float v) {
    sdfx::set_camera_angle_y(v);
}

void vybe_ios_set_camera_target_y(float v) {
    sdfx::set_camera_target_y(v);
}

// Shader - returns pointer to static buffer
static std::string g_shader_name_buf;
const char* vybe_ios_get_shader_name_cstr() {
    g_shader_name_buf = sdfx::get_current_shader_name();
    return g_shader_name_buf.c_str();
}

int vybe_ios_get_shader_count() {
    return sdfx::get_shader_count();
}

void vybe_ios_next_shader() {
    int count = sdfx::get_shader_count();
    if (count <= 0) return;
    int current = sdfx::get_current_shader_index();
    int next = (current + 1) % count;
    sdfx::load_shader_at_index(next);
}

void vybe_ios_prev_shader() {
    int count = sdfx::get_shader_count();
    if (count <= 0) return;
    int current = sdfx::get_current_shader_index();
    int prev = (current - 1 + count) % count;
    sdfx::load_shader_at_index(prev);
}

// Time
double vybe_ios_get_time() {
    return sdfx::get_time();
}

const char* vybe_ios_get_resource_path() {
    return g_resource_path.c_str();
}

} // extern "C"

// =============================================================================
// jank AOT Module Entry Points
// =============================================================================

// Single entry point - loads all core and application modules in correct order
// This is auto-generated by build_ios_jank_aot.sh (for AOT builds)
extern "C" void jank_aot_init();

// Native function loader - registers C++ implementations into clojure.core-native namespace
// This is compiled from clojure/core_native.cpp and MUST be called before loading clojure.core
extern "C" void* jank_load_clojure_core_native();
extern "C" void* jank_load_jank_nrepl_server_asio();
extern "C" void jank_module_set_loaded(const char* module);

#if defined(JANK_IOS_JIT)
// AOT-compiled core library load functions
// These are provided by linking the clojure_*_generated.o files
extern "C" void* jank_load_core();           // clojure.core
extern "C" void* jank_load_string();         // clojure.string
extern "C" void* jank_load_set();            // clojure.set
extern "C" void* jank_load_walk();           // clojure.walk
extern "C" void* jank_load_template__();     // clojure.template (__ because 'template' is reserved)
extern "C" void* jank_load_test();           // clojure.test

// Hybrid mode: AOT core libs + JIT user code
// Core libs are pre-compiled for fast startup, user code is JIT-compiled
static bool load_jank_modules_jit() {
    std::cout << "[jank-hybrid] Loading AOT-compiled core libraries..." << std::endl;

    // CRITICAL: Load native functions FIRST - clojure.core depends on these!
    std::cout << "[jank-hybrid] Loading clojure.core-native (C++ implementations)..." << std::endl;
    jank_load_clojure_core_native();
    std::cout << "[jank-hybrid] clojure.core-native loaded!" << std::endl;

    // Load AOT-compiled core libraries
    std::cout << "[jank-hybrid] Loading clojure.core (AOT)..." << std::endl;
    jank_load_core();
    std::cout << "[jank-hybrid] clojure.core loaded!" << std::endl;

    std::cout << "[jank-hybrid] Loading clojure.string (AOT)..." << std::endl;
    jank_load_string();
    std::cout << "[jank-hybrid] clojure.string loaded!" << std::endl;

    std::cout << "[jank-hybrid] Loading clojure.set (AOT)..." << std::endl;
    jank_load_set();
    std::cout << "[jank-hybrid] clojure.set loaded!" << std::endl;

    std::cout << "[jank-hybrid] Loading clojure.walk (AOT)..." << std::endl;
    jank_load_walk();
    std::cout << "[jank-hybrid] clojure.walk loaded!" << std::endl;

    std::cout << "[jank-hybrid] Loading clojure.template (AOT)..." << std::endl;
    jank_load_template__();
    std::cout << "[jank-hybrid] clojure.template loaded!" << std::endl;

    std::cout << "[jank-hybrid] Loading clojure.test (AOT)..." << std::endl;
    jank_load_test();
    std::cout << "[jank-hybrid] clojure.test loaded!" << std::endl;

    // Register nREPL native module as loaded
    std::cout << "[jank-hybrid] Registering nREPL server native module..." << std::endl;
    jank_load_jank_nrepl_server_asio();
    jank_module_set_loaded("jank.nrepl-server.asio");
    std::cout << "[jank-hybrid] nREPL native module registered!" << std::endl;

    // Now load the application module via JIT
    std::cout << "[jank-hybrid] Loading vybe.sdf.ios from source (JIT)..." << std::endl;
    auto app_result = jank::runtime::__rt_ctx->load_module(
        "/vybe.sdf.ios",
        jank::runtime::module::origin::source
    );

    if (app_result.is_err()) {
        std::cerr << "[jank-hybrid] Failed to load vybe.sdf.ios: "
                  << app_result.expect_err()->message << std::endl;
        return false;
    }

    std::cout << "[jank-hybrid] vybe.sdf.ios loaded successfully!" << std::endl;
    return true;
}
#endif

// Forward declaration for large-stack wrapper
static bool init_jank_runtime_impl();

// Large stack wrapper for running jank on iOS
// iOS main thread has only ~1MB stack, but jank's recursive codegen needs more.
// We create a pthread with 8MB stack to run jank initialization.
// NOTE: These helpers are NOT in an anonymous namespace to avoid symbol mangling issues.
// The anonymous namespace was causing init_jank_runtime_impl() calls to be mangled
// as (anonymous namespace)::init_jank_runtime_impl() which didn't match the definition.

struct jank_init_result {
    std::mutex mtx;
    std::condition_variable cv;
    bool done = false;
    bool success = false;
};

static void* jank_init_thread_func(void* arg) {
    auto* result = static_cast<jank_init_result*>(arg);

    bool success = init_jank_runtime_impl();

    {
        std::lock_guard<std::mutex> lock(result->mtx);
        result->success = success;
        result->done = true;
    }
    result->cv.notify_one();
    return nullptr;
}

static bool init_jank_runtime_on_large_stack() {
    constexpr size_t STACK_SIZE = 8 * 1024 * 1024; // 8MB stack

    // Initialize GC on main thread FIRST - before creating worker thread
    std::cout << "[jank] Initializing Boehm GC on main thread..." << std::endl;
    GC_init();

    // CRITICAL: Disable GC during worker thread execution to avoid
    // "Collecting from unknown thread" errors. The worker thread
    // won't be registered with GC, so any collection attempt would fail.
    // GC will be re-enabled after init completes.
    std::cout << "[jank] Disabling GC during initialization..." << std::endl;
    GC_disable();

    pthread_attr_t attr;
    pthread_attr_init(&attr);
    pthread_attr_setstacksize(&attr, STACK_SIZE);

    jank_init_result result;
    pthread_t thread;

    std::cout << "[jank] Starting initialization on thread with " << (STACK_SIZE / 1024 / 1024) << "MB stack..." << std::endl;

    int err = pthread_create(&thread, &attr, jank_init_thread_func, &result);
    pthread_attr_destroy(&attr);

    if (err != 0) {
        std::cerr << "[jank] Failed to create large-stack thread: " << err << std::endl;
        // Fall back to running on current thread (re-enable GC first)
        GC_enable();
        return init_jank_runtime_impl();
    }

    // Wait for the thread to complete
    {
        std::unique_lock<std::mutex> lock(result.mtx);
        result.cv.wait(lock, [&result] { return result.done; });
    }

    pthread_join(thread, nullptr);

    // Re-enable GC now that initialization is complete
    std::cout << "[jank] Re-enabling GC after initialization..." << std::endl;
    GC_enable();

    return result.success;
}

// Initialize jank runtime for iOS (actual implementation)
// NOTE: GC_init() is called by init_jank_runtime_on_large_stack() before this
static bool init_jank_runtime_impl() {
    try {

        std::cout << "[jank] Creating runtime context..." << std::endl;
        jank::runtime::__rt_ctx = new (GC_malloc(sizeof(jank::runtime::context)))
            jank::runtime::context{};

#if defined(JANK_IOS_JIT)
        // JIT mode: Load modules from bundled source files
        std::cout << "[jank] JIT mode - loading modules from source..." << std::endl;
        if (!load_jank_modules_jit()) {
            std::cerr << "[jank] JIT module loading failed" << std::endl;
            return false;
        }
#else
        // AOT mode: Load all modules via auto-generated init function
        jank_aot_init();
#endif

        std::cout << "[jank] Runtime initialized successfully!" << std::endl;
        return true;
    } catch (jtl::ref<jank::error::base> const& e) {
        std::cerr << "[jank] Error initializing runtime: " << e->message << std::endl;
        if (e->cause) {
            std::cerr << "[jank]   caused by: " << e->cause->message << std::endl;
        }
        return false;
    } catch (const std::exception& e) {
        std::cerr << "[jank] Error initializing runtime (std): " << e.what() << std::endl;
        return false;
    }
}

// Call the jank-exported -main function
static void call_jank_main() {
    try {
        // Look up the -main var in vybe.sdf.ios
        auto var = jank::runtime::__rt_ctx->intern_var("vybe.sdf.ios", "-main");
        if (!var.is_ok()) {
            std::cerr << "[jank] Could not find vybe.sdf.ios/-main" << std::endl;
            return;
        }

        // Call it using dynamic_call (no args)
        std::cout << "[jank] Calling vybe.sdf.ios/-main..." << std::endl;
        jank::runtime::dynamic_call(var.expect_ok()->deref());
    } catch (const std::exception& e) {
        std::cerr << "[jank] Error calling -main: " << e.what() << std::endl;
    }
}

// =============================================================================
// Main Entry Point
// =============================================================================

extern "C" int sdf_viewer_main(int argc, char* argv[]) {
    @autoreleasepool {
        std::cout << std::endl;
        std::cout << "============================================" << std::endl;
        std::cout << "   SDF Viewer Mobile - iOS Edition" << std::endl;
#if defined(JANK_IOS_JIT)
        std::cout << "   (with jank JIT runtime)" << std::endl;
#else
        std::cout << "   (with jank AOT runtime)" << std::endl;
#endif
        std::cout << "============================================" << std::endl;
        std::cout << std::endl;

        // Initialize jank runtime on a thread with larger stack
        // (iOS main thread has ~1MB stack, jank needs ~8MB for recursive codegen)
        if (!init_jank_runtime_on_large_stack()) {
            std::cerr << "Warning: jank runtime initialization failed" << std::endl;
            std::cerr << "Continuing without jank support..." << std::endl;
            return 1;
        }

        // Call the jank main function (works for both JIT and AOT)
        call_jank_main();

        return 0;
    }
}
