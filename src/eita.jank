(ns eita
  (:require
   [jank.compiler :as jc]
   [jank.nrepl-server.server :as server]
   [jank.export :as je]))

(comment

  ;; PATH="/Users/pfeodrippe/dev/jank/compiler+runtime/build:$PATH" jank --module-path src run-main eita

  (server/start-server {:port 5557})

  (ns-publics (symbol (namespace `server/start-server)))

  (jank.compiler/native-source '(fn [x] (+ 4 x)))
  (jank.compiler/native-cpp-source '(fn [x] (+ 4 x)))

  (-main)

  (sample-fn)

  (cpp/raw "
#include <iostream>
#include <array> // For std::array

int ttt(int x) {
    std::array<int, 5> arr = {10, 20, 30, 40, 50};

    for (auto it = arr.begin(); it != arr.end(); ++it) {
        std::cout << *it << \" \"; // Dereference the iterator to get the element
    }
    std::cout << std::endl;
    return x;
}
")

  (cpp/ttt 4)

  (cpp/raw "
int my_ad(int x, int y) {
    return (x + y);
}
")

  (cpp/my_add 5 9)

  ()


  ())

(defn my-apply [f x]
  (f x))

(jank.export/register
 #'my-apply
 "my_apply"
 [:=> [:cat [:fn [:long] :long] :long] :long])

#_(defn multiplier []
  (fn [_ arr num-of-samples]
    (doseq []
      (* x 0.2))))

#_ (jc/native-aot-entrypoint-source
    ' (jank.export/register
       #'multiplier
       "my_multiplier"
       [:=> [:cat] [:fn [::void :vector :int] :long]]))

(comment

  (cpp/raw "
#include <dlfcn.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

typedef long (*my_apply_cb_fn)(long);
typedef long (*my_apply_fn)(my_apply_cb_fn, long);

static long host_square2(long x)
{
  return x * x;
}

int ddd (void) {
my_apply_fn my_apply = (my_apply_fn)dlsym(NULL, \"my_apply\");
if(my_apply == NULL)
  {
   return 1;
  }
return 0;
}
")

  (cpp/my_inc2)

  (cpp/raw "func_ptr3(host_square2, 5);")

  ())

(cpp/raw "
 inline int cpp_rawinline_hello() {
  return 20;
}
")

#_(cpp/raw "
 idfnlinde int cpp_rawinline_hello() {
  return 10;
}
")

(defn -main [& args]
  (println :ARGS args)
  (println (cpp/cpp_rawinline_hello))
  #_(printjln (cpp/cpp_rawinline_hello))
  (let [srv (server/start-server {:port 5557})]
    (read-line)
    (server/stop-server srv)))

#_(defn -main [& args]
    (println (str "shared-lib-invoked/" (count args))))

(defn sample-fn "demo doc"
  ([x] x)
  ([x y] (+ x y)))

(def my-fn
  "My function"
  (fn* [x] (+ x 10)))

(def ^{:arglists '([x] [y x])
       :doc "My function"}
  my-fn
  (fn* [x] (+ x 10)))
