(ns my-jolt-static)

;; JoltPhysics demo using static linking with precompiled wrapper
;; The wrapper creates shapes/bodies in precompiled code, avoiding vtable issues

(cpp/raw "
#include <iostream>
#include <cstdint>

// Provide emulated TLS stub for JIT - we're single-threaded so this works
extern \"C\" {
    struct __emutls_control {
        size_t size;
        size_t align;
        union { size_t offset; void *ptr; } object;
        void *templ;
    };

    void* __emutls_get_address(__emutls_control* control) {
        if (!control->object.ptr) {
            control->object.ptr = malloc(control->size);
            if (control->templ) {
                memcpy(control->object.ptr, control->templ, control->size);
            } else {
                memset(control->object.ptr, 0, control->size);
            }
        }
        return control->object.ptr;
    }
}

// Jolt AssertFailed stub (needed even in Release for some edge cases)
namespace JPH {
    using AssertFailedFunction = bool(*)(const char*, const char*, const char*, unsigned int);
    AssertFailedFunction AssertFailed = [](const char* expr, const char* msg, const char* file, unsigned int line) -> bool {
        std::cout << \"[JOLT ASSERT] \" << file << \":\" << line << \": (\" << expr << \") \" << (msg ? msg : \"\") << std::endl;
        return false;
    };
}

#include <jank/runtime/obj/opaque_box.hpp>
#include <jank/runtime/obj/persistent_vector.hpp>

// =============================================================================
// Declare the precompiled wrapper functions (from jolt_wrapper.cpp)
// These are compiled with Jolt, so vtables are correct!
// =============================================================================

extern \"C\" {
    // World management
    void* jolt_world_create();
    void jolt_world_destroy(void* world_ptr);

    // Shape creation (precompiled - correct vtables!)
    void* jolt_shape_create_sphere(float radius);
    void* jolt_shape_create_box(float half_x, float half_y, float half_z);
    void* jolt_shape_create_capsule(float half_height, float radius);
    void jolt_shape_release(void* shape_ptr);

    // Body creation with precompiled shapes
    uint32_t jolt_body_create_with_shape(
        void* world_ptr, void* shape_ptr,
        float x, float y, float z,
        bool is_dynamic, bool activate);

    // Convenience: create shape + body in one call
    uint32_t jolt_body_create_sphere(
        void* world_ptr,
        float x, float y, float z, float radius,
        bool is_dynamic, bool activate);

    uint32_t jolt_body_create_box(
        void* world_ptr,
        float x, float y, float z,
        float half_x, float half_y, float half_z,
        bool is_dynamic, bool activate);

    // Body manipulation
    void jolt_body_set_velocity(void* world_ptr, uint32_t body_id, float vx, float vy, float vz);
    void jolt_body_get_position(void* world_ptr, uint32_t body_id, float* out_x, float* out_y, float* out_z);
    void jolt_body_get_velocity(void* world_ptr, uint32_t body_id, float* out_vx, float* out_vy, float* out_vz);
    bool jolt_body_is_active(void* world_ptr, uint32_t body_id);
    void jolt_body_destroy(void* world_ptr, uint32_t body_id);

    // Simulation
    void jolt_world_step(void* world_ptr, float delta_time, int collision_steps);
    void jolt_world_optimize_broad_phase(void* world_ptr);

    // Utilities
    int jolt_world_get_num_bodies(void* world_ptr);
    int jolt_world_get_num_active_bodies(void* world_ptr);
}

// =============================================================================
// Jank wrapper functions - thin layer calling precompiled code
// =============================================================================

inline jank::runtime::object_ref jank_jolt_create_world()
{
    void* world = jolt_world_create();
    return jank::runtime::make_box<jank::runtime::obj::opaque_box>(world, \"JoltWorld\");
}

inline void jank_jolt_destroy_world(jank::runtime::object_ref world_box)
{
    auto opaque = jank::runtime::expect_object<jank::runtime::obj::opaque_box>(world_box);
    jolt_world_destroy(opaque->data.data);
}

inline jank::runtime::object_ref jank_jolt_create_sphere(
    jank::runtime::object_ref world_box,
    double x, double y, double z, double radius,
    bool is_dynamic, bool activate)
{
    auto opaque = jank::runtime::expect_object<jank::runtime::obj::opaque_box>(world_box);
    uint32_t body_id = jolt_body_create_sphere(
        opaque->data.data,
        static_cast<float>(x), static_cast<float>(y), static_cast<float>(z),
        static_cast<float>(radius),
        is_dynamic, activate
    );
    return jank::runtime::make_box(static_cast<int64_t>(body_id));
}

inline jank::runtime::object_ref jank_jolt_create_box(
    jank::runtime::object_ref world_box,
    double x, double y, double z,
    double half_x, double half_y, double half_z,
    bool is_dynamic, bool activate)
{
    auto opaque = jank::runtime::expect_object<jank::runtime::obj::opaque_box>(world_box);
    uint32_t body_id = jolt_body_create_box(
        opaque->data.data,
        static_cast<float>(x), static_cast<float>(y), static_cast<float>(z),
        static_cast<float>(half_x), static_cast<float>(half_y), static_cast<float>(half_z),
        is_dynamic, activate
    );
    return jank::runtime::make_box(static_cast<int64_t>(body_id));
}

inline void jank_jolt_set_velocity(
    jank::runtime::object_ref world_box,
    int64_t body_id,
    double vx, double vy, double vz)
{
    auto opaque = jank::runtime::expect_object<jank::runtime::obj::opaque_box>(world_box);
    jolt_body_set_velocity(
        opaque->data.data,
        static_cast<uint32_t>(body_id),
        static_cast<float>(vx), static_cast<float>(vy), static_cast<float>(vz)
    );
}

inline jank::runtime::object_ref jank_jolt_get_position(
    jank::runtime::object_ref world_box,
    int64_t body_id)
{
    auto opaque = jank::runtime::expect_object<jank::runtime::obj::opaque_box>(world_box);
    float x, y, z;
    jolt_body_get_position(opaque->data.data, static_cast<uint32_t>(body_id), &x, &y, &z);
    return jank::runtime::make_box<jank::runtime::obj::persistent_vector>(
        std::in_place,
        jank::runtime::make_box(static_cast<double>(x)),
        jank::runtime::make_box(static_cast<double>(y)),
        jank::runtime::make_box(static_cast<double>(z))
    );
}

inline jank::runtime::object_ref jank_jolt_get_velocity(
    jank::runtime::object_ref world_box,
    int64_t body_id)
{
    auto opaque = jank::runtime::expect_object<jank::runtime::obj::opaque_box>(world_box);
    float vx, vy, vz;
    jolt_body_get_velocity(opaque->data.data, static_cast<uint32_t>(body_id), &vx, &vy, &vz);
    return jank::runtime::make_box<jank::runtime::obj::persistent_vector>(
        std::in_place,
        jank::runtime::make_box(static_cast<double>(vx)),
        jank::runtime::make_box(static_cast<double>(vy)),
        jank::runtime::make_box(static_cast<double>(vz))
    );
}

inline bool jank_jolt_is_active(
    jank::runtime::object_ref world_box,
    int64_t body_id)
{
    auto opaque = jank::runtime::expect_object<jank::runtime::obj::opaque_box>(world_box);
    return jolt_body_is_active(opaque->data.data, static_cast<uint32_t>(body_id));
}

inline void jank_jolt_destroy_body(
    jank::runtime::object_ref world_box,
    int64_t body_id)
{
    auto opaque = jank::runtime::expect_object<jank::runtime::obj::opaque_box>(world_box);
    jolt_body_destroy(opaque->data.data, static_cast<uint32_t>(body_id));
}

inline void jank_jolt_step(
    jank::runtime::object_ref world_box,
    double delta_time)
{
    auto opaque = jank::runtime::expect_object<jank::runtime::obj::opaque_box>(world_box);
    jolt_world_step(opaque->data.data, static_cast<float>(delta_time), 1);
}

inline void jank_jolt_optimize_broad_phase(jank::runtime::object_ref world_box)
{
    auto opaque = jank::runtime::expect_object<jank::runtime::obj::opaque_box>(world_box);
    jolt_world_optimize_broad_phase(opaque->data.data);
}

inline int64_t jank_jolt_get_num_bodies(jank::runtime::object_ref world_box)
{
    auto opaque = jank::runtime::expect_object<jank::runtime::obj::opaque_box>(world_box);
    return static_cast<int64_t>(jolt_world_get_num_bodies(opaque->data.data));
}

inline int64_t jank_jolt_get_num_active_bodies(jank::runtime::object_ref world_box)
{
    auto opaque = jank::runtime::expect_object<jank::runtime::obj::opaque_box>(world_box);
    return static_cast<int64_t>(jolt_world_get_num_active_bodies(opaque->data.data));
}
")

;; =============================================================================
;; Jank wrapper functions
;; =============================================================================

(defn create-world []
  (cpp/jank_jolt_create_world))

(defn destroy-world! [world]
  (cpp/jank_jolt_destroy_world world))

(defn create-sphere
  "Create a sphere body. Returns body ID."
  ([world x y z radius]
   (create-sphere world x y z radius true true))
  ([world x y z radius dynamic?]
   (create-sphere world x y z radius dynamic? true))
  ([world x y z radius dynamic? activate?]
   (cpp/jank_jolt_create_sphere world x y z radius dynamic? activate?)))

(defn create-box
  "Create a box body with half-extents. Returns body ID."
  ([world x y z hx hy hz]
   (create-box world x y z hx hy hz true true))
  ([world x y z hx hy hz dynamic?]
   (create-box world x y z hx hy hz dynamic? true))
  ([world x y z hx hy hz dynamic? activate?]
   (cpp/jank_jolt_create_box world x y z hx hy hz dynamic? activate?)))

(defn set-velocity! [world body-id vx vy vz]
  (cpp/jank_jolt_set_velocity world body-id vx vy vz))

(defn get-position [world body-id]
  (cpp/jank_jolt_get_position world body-id))

(defn get-velocity [world body-id]
  (cpp/jank_jolt_get_velocity world body-id))

(defn active? [world body-id]
  (cpp/jank_jolt_is_active world body-id))

(defn destroy-body! [world body-id]
  (cpp/jank_jolt_destroy_body world body-id))

(defn step! [world dt]
  (cpp/jank_jolt_step world dt))

(defn optimize-broad-phase! [world]
  (cpp/jank_jolt_optimize_broad_phase world))

(defn num-bodies [world]
  (cpp/jank_jolt_get_num_bodies world))

(defn num-active-bodies [world]
  (cpp/jank_jolt_get_num_active_bodies world))

;; =============================================================================
;; Demo
;; =============================================================================

(defn -main [& args]
  (println "JoltPhysics Demo - Using Precompiled Wrapper")
  (println "=============================================")
  (println "")

  (println "Creating physics world...")
  (let [world (create-world)]
    (println "World created:" world)
    (println "")

    ;; Create a floor (static box)
    (println "Creating floor (static box at y=0)...")
    (let [floor-id (create-box world 0.0 -0.5 0.0 50.0 0.5 50.0 false false)]
      (println "Floor created, body ID:" floor-id)
      (println ""))

    ;; Create a dynamic sphere
    (println "Creating sphere (dynamic, at y=10)...")
    (let [sphere-id (create-sphere world 0.0 10.0 0.0 1.0 true true)]
      (println "Sphere created, body ID:" sphere-id)
      (println "Initial position:" (get-position world sphere-id))
      (println "Initial velocity:" (get-velocity world sphere-id))
      (println "Is active:" (active? world sphere-id))
      (println "")

      ;; Optimize broad phase after adding bodies
      (optimize-broad-phase! world)

      ;; Run simulation
      (println "Running physics simulation (60 steps at 1/60s)...")
      (println "")

      (dotimes [i 60]
        (step! world (/ 1.0 60.0))
        (when (zero? (mod i 10))
          (let [pos (get-position world sphere-id)
                vel (get-velocity world sphere-id)]
            (println (str "Step " i ": pos=" pos " vel=" vel)))))

      (println "")
      (println "Final position:" (get-position world sphere-id))
      (println "Final velocity:" (get-velocity world sphere-id))
      (println "Is active:" (active? world sphere-id))
      (println "")
      (println "Total bodies:" (num-bodies world))
      (println "Active bodies:" (num-active-bodies world)))

    (println "")
    (println "Demo complete!")
    (destroy-world! world)))

(-main)
