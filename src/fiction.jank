(ns fiction
  "Disco Elysium-style narrative game.

   Standalone Vulkan application with text rendering for
   dialogue and choices."
  (:refer-clojure :exclude [run!])
  (:require
   [fiction.parser :as parser]
   [fiction.state :as state]
   [fiction.render :as text-render]
   [vybe.flecs :as vf]
   ["fiction_gfx/fiction_gfx.hpp" :as engine :scope "fiction_engine"]
   ;; TODO: Re-enable for native builds (not supported in WASM)
   #_[jank.nrepl-server.server :as server]))

;; =============================================================================
;; Story Loading
;; =============================================================================

;; Path to the story file
(def ^:private story-path "stories/la_voiture.md")

;; Background image path
(def ^:private bg-image-path "resources/fiction/bg-1.png")

;; =============================================================================
;; File Watching (atom-based, ECS system registered separately)
;; =============================================================================

;; Simple atom-based file watcher (reliable fallback)
(defonce ^:private *last-mod-time (atom 0))

(defn- file-modified?
  "Check if the story file has been modified since last check."
  []
  (let [current-time (engine/get_file_mod_time story-path)
        last-time @*last-mod-time]
    (reset! *last-mod-time current-time)
    (and (not= last-time 0)
         (not= current-time last-time))))

(defn load-story!
  "Load the story from file."
  []
  (state/load-story-from-file! story-path)
  (println "Story loaded:" (:title (state/get-metadata))))

;; =============================================================================
;; Event Handling (Polling-based)
;; =============================================================================

;; SDL Scancodes for reference
(def ^:private SCANCODE_1 30)
(def ^:private SCANCODE_9 38)
(def ^:private SCANCODE_UP 82)
(def ^:private SCANCODE_DOWN 81)

(defn process-key-event!
  "Process a key down event."
  [scancode]
  (cond
    ;; Number keys 1-9 for choice selection (scancodes 30-38)
    (and (>= scancode SCANCODE_1) (<= scancode SCANCODE_9))
    (let [choice-idx (- scancode SCANCODE_1)]
      (when (< choice-idx (count (state/get-available-choices)))
        (println "Selected choice:" (inc choice-idx))
        (state/select-choice! choice-idx)
        (text-render/scroll-to-bottom!)))

    ;; Up arrow - scroll up
    (= scancode SCANCODE_UP)
    (text-render/scroll! -30.0)

    ;; Down arrow - scroll down
    (= scancode SCANCODE_DOWN)
    (text-render/scroll! 30.0)

    :else nil))

(defn process-scroll-event!
  "Process a scroll event."
  [delta-y]
  (text-render/scroll! (* delta-y -30.0)))

(defn process-mouse-motion!
  "Process mouse motion for hover detection."
  [x y]
  (let [scale (engine/get_pixel_scale)]
    (text-render/update-mouse-position! (* x scale) (* y scale))))

(defn process-mouse-click!
  "Process mouse click to select hovered choice."
  [x y button]
  ;; Only handle left click (button 1)
  (when (= button 1)
    (let [clicked-choice (text-render/get-clicked-choice)]
      (when (>= clicked-choice 0)
        (println "Selected choice:" (inc clicked-choice))
        (state/select-choice! clicked-choice)
        (text-render/scroll-to-bottom!)))))

(defn process-events!
  "Process all pending input events."
  []
  (let [event-count (engine/get_event_count)]
    (dotimes [i event-count]
      (let [event-type (engine/get_event_type (cpp/int. i))]
        (cond
          ;; Key down (type 1)
          (= event-type 1)
          (process-key-event! (engine/get_event_scancode (cpp/int. i)))

          ;; Scroll (type 3)
          (= event-type 3)
          (process-scroll-event! (engine/get_event_scroll_y (cpp/int. i)))

          ;; Mouse motion (type 4)
          (= event-type 4)
          (process-mouse-motion! (engine/get_event_mouse_x (cpp/int. i))
                                  (engine/get_event_mouse_y (cpp/int. i)))

          ;; Mouse button down (type 5)
          (= event-type 5)
          (process-mouse-click! (engine/get_event_mouse_x (cpp/int. i))
                                 (engine/get_event_mouse_y (cpp/int. i))
                                 (engine/get_event_mouse_button (cpp/int. i)))

          ;; Key up (type 2), mouse up (type 6) - ignore for now
          :else nil)))))

;; =============================================================================
;; Initialization
;; =============================================================================

(defn init!
  "Initialize the fiction game."
  []
  (println "")
  (println "============================================")
  (println "   LA VOITURE - Interactive Fiction")
  (println "============================================")
  (println "")
  (println "Controls:")
  (println "  1-9      = Select choice")
  (println "  Mouse    = Hover/click choice")
  (println "  Up/Down  = Scroll dialogue")
  (println "  ESC      = Quit")
  (println "")

  ;; Initialize Vulkan engine
  (when-not (engine/init "La Voiture")
    (println "ERROR: Failed to initialize Vulkan")
    false)

  ;; Initialize text renderer (uses fiction_engine handles internally)
  (let [width (engine/get_screen_width)
        height (engine/get_screen_height)]
    (text-render/init! width height "vulkan_fiction"))

  ;; Load background image
  (println "About to load background...")
  (text-render/init-background! bg-image-path "vulkan_fiction")
  (println "Background loaded.")

  ;; Load story from file
  (load-story!)

  ;; Initialize file watcher timestamp
  (reset! *last-mod-time (engine/get_file_mod_time story-path))

  ;; No panel background - let bg-1.png show through directly
  (text-render/set-panel-colors! 0.0 0.0 0.0 0.0)

  ;; Position panel over the core black bar of bg-1.png (X: 60%-90%)
  (text-render/set-panel-position! 0.61 0.26)

  (println "")
  (println "Ready. Make your choice...")
  (println "")
  true)

;; =============================================================================
;; Main Loop
;; =============================================================================

(defn run!
  "Run the fiction game."
  []
  (when (init!)
    (loop []
      (when-not (engine/should_close)
        ;; Poll SDL events (populates event queue)
        (engine/poll_events)

        ;; Process events from queue (jank-side)
        (process-events!)

        ;; Check for story file changes (hot-reload, preserves state)
        (when (file-modified?)
          (println "Story file changed, reloading...")
          (state/reload-story-from-file! story-path))

        ;; Build text vertices and draw frame
        (text-render/build-dialogue-vertices!)
        (engine/draw_frame)

        (recur)))

    ;; Cleanup
    (text-render/cleanup!)
    (engine/cleanup)
    (println "")
    (println "Au revoir.")))

(defn -main [& args]
  ;; TODO: Re-enable for native builds (not supported in WASM)
  #_(server/start-server {:port 5700})
  (run!))
