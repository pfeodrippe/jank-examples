(ns my-integrated-demo
  (:require
   ;; Raylib with global scope (C functions)
   ["raylib.h" :as rl :scope ""]
   ;; rlgl for low-level OpenGL functions (rlUnloadTexture, etc.)
   ["rlgl.h" :as rlgl :scope ""]
   ;; ImGui with ImGui:: scope
   ["imgui.h" :as imgui :scope "ImGui"]
   ["imgui.h" :as imgui-h :scope ""]
   ;; Flecs C API with global scope
   ["flecs.h" :as fl :scope ""]
   ;; Jolt C API with global scope
   ["jolt_c.h" :as jolt :scope ""]
   [jank.nrepl-server.server :as server]
   [clojure.string :as str]
   [vybe.util :as u :refer [->*]]))

;; Integrated demo: Raylib + ImGui + JoltPhysics + Flecs
;; Uses header requires for cleaner code

;; =============================================================================
;; C++ bridging layer (minimal - only what can't be done via header requires)
;; =============================================================================

(cpp/raw "
#include <cstdio>
#include <cstdint>
#include <cstring>
#include <raylib.h>
#include <rlgl.h>
#include <imgui.h>
#include <flecs.h>
#include <jank/runtime/obj/opaque_box.hpp>

// =============================================================================
// JIT stubs (required for JIT linking)
// =============================================================================

extern \"C\" {
    struct __emutls_control {
        size_t size; size_t align;
        union { size_t offset; void *ptr; } object;
        void *templ;
    };
    void* __emutls_get_address(__emutls_control* control) {
        if (!control->object.ptr) {
            control->object.ptr = malloc(control->size);
            if (control->templ) memcpy(control->object.ptr, control->templ, control->size);
            else memset(control->object.ptr, 0, control->size);
        }
        return control->object.ptr;
    }
}

namespace JPH {
    using AssertFailedFunction = bool(*)(const char*, const char*, const char*, unsigned int);
    AssertFailedFunction AssertFailed = [](const char* e, const char* m, const char* f, unsigned int l) -> bool {
        printf(\"[JOLT] %s:%u: %s\\n\", f, l, m ? m : e);
        return false;
    };
}

// Jolt C API now comes from header require: [\"jolt_c.h\" :as jolt :scope \"\"]
#include <jolt_c.h>

// =============================================================================
// Entity storage (ODR-safe vector + Flecs entity IDs)
// =============================================================================

struct Entity {
    uint64_t flecs_id;  // Flecs entity ID
    uint32_t jolt_id;   // Jolt body ID
    float radius;
    uint8_t r, g, b;
};

static std::vector<Entity>* g_entities_ptr = nullptr;

inline std::vector<Entity>& get_entities() {
    if (!g_entities_ptr) g_entities_ptr = new std::vector<Entity>();
    return *g_entities_ptr;
}

// =============================================================================
// Global state with heap-pointer pattern (ODR-safe)
// =============================================================================

static void* g_jolt_world = nullptr;
static float* g_time_scale_ptr = nullptr;
static int* g_spawn_count_ptr = nullptr;
static float* g_view_scale_ptr = nullptr;
static float* g_view_offset_x_ptr = nullptr;
static float* g_view_offset_y_ptr = nullptr;
static unsigned int* g_font_tex_ptr = nullptr;

inline float& get_time_scale() {
    if (!g_time_scale_ptr) g_time_scale_ptr = new float(1.0f);
    return *g_time_scale_ptr;
}

inline int& get_spawn_count() {
    if (!g_spawn_count_ptr) g_spawn_count_ptr = new int(5);
    return *g_spawn_count_ptr;
}

inline float& get_view_scale() {
    if (!g_view_scale_ptr) g_view_scale_ptr = new float(15.0f);
    return *g_view_scale_ptr;
}

inline float& get_view_offset_x() {
    if (!g_view_offset_x_ptr) g_view_offset_x_ptr = new float(640.0f);
    return *g_view_offset_x_ptr;
}

inline float& get_view_offset_y() {
    if (!g_view_offset_y_ptr) g_view_offset_y_ptr = new float(500.0f);
    return *g_view_offset_y_ptr;
}

inline unsigned int& get_font_tex() {
    if (!g_font_tex_ptr) g_font_tex_ptr = new unsigned int(0);
    return *g_font_tex_ptr;
}

// =============================================================================
// Jolt wrapper functions
// =============================================================================

inline jank::runtime::object_ref jolt_create_world() {
    g_jolt_world = jolt_world_create();
    return jank::runtime::make_box<jank::runtime::obj::opaque_box>(g_jolt_world, \"JoltWorld\");
}

inline void jolt_destroy_world(jank::runtime::object_ref w) {
    auto o = jank::runtime::expect_object<jank::runtime::obj::opaque_box>(w);
    jolt_world_destroy(o->data.data);
    g_jolt_world = nullptr;
}

inline int64_t jolt_create_sphere(jank::runtime::object_ref w, double x, double y, double z, double r) {
    auto o = jank::runtime::expect_object<jank::runtime::obj::opaque_box>(w);
    return jolt_body_create_sphere(o->data.data, (float)x, (float)y, (float)z, (float)r, true, true);
}

inline int64_t jolt_create_floor(jank::runtime::object_ref w) {
    auto o = jank::runtime::expect_object<jank::runtime::obj::opaque_box>(w);
    return jolt_body_create_box(o->data.data, 0, -0.5f, 0, 50, 0.5f, 50, false, false);
}

// =============================================================================
// Flecs helpers - minimal wrappers for opaque_box handling
// Uses fl/ecs_mini for init (called from jank), wrappers for opaque_box ops
// =============================================================================

// Wrapper needed: ecs_fini needs raw pointer from opaque_box
inline void flecs_fini_world(jank::runtime::object_ref flecs_world_box) {
    auto o = jank::runtime::expect_object<jank::runtime::obj::opaque_box>(flecs_world_box);
    ecs_fini(static_cast<ecs_world_t*>(o->data.data));
}

inline void flecs_add_entity(jank::runtime::object_ref flecs_world_box, int64_t jolt_id, double radius, int64_t r, int64_t g, int64_t b) {
    // Extract world from opaque_box and create entity
    auto o = jank::runtime::expect_object<jank::runtime::obj::opaque_box>(flecs_world_box);
    ecs_world_t* world = static_cast<ecs_world_t*>(o->data.data);
    uint64_t flecs_id = ecs_new(world);

    // Store in vector for iteration (avoids JIT template issues with Flecs queries)
    Entity e;
    e.flecs_id = flecs_id;
    e.jolt_id = (uint32_t)jolt_id;
    e.radius = (float)radius;
    e.r = (uint8_t)r;
    e.g = (uint8_t)g;
    e.b = (uint8_t)b;
    get_entities().push_back(e);
}

// flecs_entity_count and flecs_clear_entities are now in pure jank!
// Using cpp/.size and cpp/.clear on get_entities() vector directly

// Get entity position from Jolt - returns Vector3-like struct
// Uses out parameters converted to a simple struct for jank access
struct EntityPos { float x, y, z; };
static EntityPos* g_entity_pos_ptr = nullptr;
inline EntityPos& get_entity_pos_result() {
    if (!g_entity_pos_ptr) g_entity_pos_ptr = new EntityPos{0,0,0};
    return *g_entity_pos_ptr;
}
inline void entity_get_position(jank::runtime::object_ref world_box, int64_t jolt_id) {
    auto o = jank::runtime::expect_object<jank::runtime::obj::opaque_box>(world_box);
    EntityPos& pos = get_entity_pos_result();
    jolt_body_get_position(o->data.data, (uint32_t)jolt_id, &pos.x, &pos.y, &pos.z);
}
inline float entity_pos_x() { return get_entity_pos_result().x; }
inline float entity_pos_y() { return get_entity_pos_result().y; }
inline float entity_pos_z() { return get_entity_pos_result().z; }

// Draw height label helper - needed because jank can't easily do sprintf formatting
inline void draw_height_label(int64_t x, int64_t y, int64_t height) {
    char buf[16];
    char fmt[] = { 37, 'd', 0 };  // 37 is ASCII for percent, avoids jank parser issues
    snprintf(buf, sizeof(buf), fmt, (int)height);
    DrawText(buf, (int)x - 10, (int)y - 5, 10, BLACK);
}

// =============================================================================
// ImGui renderer
// =============================================================================

inline void imgui_init() {
    ImGui::CreateContext();
    ImGuiIO& io = ImGui::GetIO();
    io.ConfigFlags |= ImGuiConfigFlags_NavEnableKeyboard;
    ImGui::StyleColorsDark();
    io.DisplaySize = ImVec2((float)GetScreenWidth(), (float)GetScreenHeight());
    unsigned char* pixels; int w, h;
    io.Fonts->GetTexDataAsRGBA32(&pixels, &w, &h);
    Image img = { pixels, w, h, 1, PIXELFORMAT_UNCOMPRESSED_R8G8B8A8 };
    get_font_tex() = LoadTextureFromImage(img).id;
    io.Fonts->SetTexID((ImTextureID)(intptr_t)get_font_tex());
}

inline void imgui_update_input() {
    ImGuiIO& io = ImGui::GetIO();
    io.DisplaySize = ImVec2((float)GetScreenWidth(), (float)GetScreenHeight());
    io.DeltaTime = GetFrameTime();
    Vector2 m = GetMousePosition();
    io.AddMousePosEvent(m.x, m.y);
    io.AddMouseButtonEvent(0, IsMouseButtonDown(MOUSE_LEFT_BUTTON));
    io.AddMouseButtonEvent(1, IsMouseButtonDown(MOUSE_RIGHT_BUTTON));
    Vector2 wh = GetMouseWheelMoveV();
    io.AddMouseWheelEvent(wh.x, wh.y);
    io.AddKeyEvent(ImGuiMod_Ctrl, IsKeyDown(KEY_LEFT_CONTROL) || IsKeyDown(KEY_RIGHT_CONTROL));
    io.AddKeyEvent(ImGuiMod_Shift, IsKeyDown(KEY_LEFT_SHIFT) || IsKeyDown(KEY_RIGHT_SHIFT));
    int c = GetCharPressed();
    while (c > 0) { io.AddInputCharacter(c); c = GetCharPressed(); }
}

// =============================================================================
// Rendering functions - NOW MOSTLY IN PURE JANK!
// See jank section below for: draw-grid!, physics-to-screen, draw-entities!
// =============================================================================
")

;; get_view_offset_x() = 640.0f;
#_(jc/native-source '


   (cpp/= (cpp/get_view_offset_x) (cpp/float. 640.0)))

#_(cpp/get_view_offset_x)

(cpp/raw
 "// =============================================================================
// opaque_box helper - extracts void* from any opaque_box (minimal cpp/raw)
// =============================================================================

inline void* opaque_box_ptr(jank::runtime::object_ref box) {
    auto o = jank::runtime::expect_object<jank::runtime::obj::opaque_box>(box);
    return o->data.data;
}
")

;; =============================================================================
;; UI State
;; =============================================================================

(defonce is-paused (u/v->p false))

;; =============================================================================
;; Jolt wrapper functions
;; =============================================================================

(defn create-world [] (cpp/jolt_create_world))

(defn destroy-world! [w] (cpp/jolt_destroy_world w))

(defn create-sphere [w x y z r] (cpp/jolt_create_sphere w x y z r))

(defn create-floor [w] (cpp/jolt_create_floor w))

(defn set-velocity! [w id vx vy vz]
  (jolt/jolt_body_set_velocity (cpp/opaque_box_ptr w) (cpp/uint32_t. id) (cpp/float. vx) (cpp/float. vy) (cpp/float. vz)))

(defn step! [w dt] (jolt/jolt_world_step (cpp/opaque_box_ptr w) (cpp/float. dt) 1))

(defn optimize! [w] (jolt/jolt_world_optimize_broad_phase (cpp/opaque_box_ptr w)))

(defn num-bodies [w] (jolt/jolt_world_get_num_bodies (cpp/opaque_box_ptr w)))

(defn num-active [w] (jolt/jolt_world_get_num_active_bodies (cpp/opaque_box_ptr w)))

;; =============================================================================
;; Flecs - using header require directly!
;; =============================================================================

(defn flecs-create-world "Create a Flecs world via C API and wrap in opaque_box." []
  (println "[flecs] ECS world created via fl/ecs_mini")
  (cpp/box (fl/ecs_mini)))

(defn flecs-destroy-world! "Destroy a Flecs world."
  [flecs-world]
  (cpp/flecs_fini_world flecs-world))

(defn add-entity! "Add entity to Flecs world and entity storage."
  [flecs-world jolt-id r cr cg cb]
  (cpp/flecs_add_entity flecs-world jolt-id r cr cg cb))

(defn entity-count
  "Get entity count using cpp/.size on the entities vector."
  []
  (cpp/.size (cpp/get_entities)))

(defn clear-entities!
  "Clear entities using cpp/.clear on the entities vector."
  []
  (cpp/.clear (cpp/get_entities)))

;; =============================================================================
;; State accessors (read-only from jank - ImGui panel handles mutation)
;; =============================================================================

(defn paused? [] (u/p->v is-paused))

(defn time-scale [] (cpp/get_time_scale))

(defn spawn-count [] (cpp/get_spawn_count))

(defn view-scale [] (cpp/get_view_scale))

;; =============================================================================
;; Raylib - using header requires directly!
;; =============================================================================

(defn raylib-init! []
  ;; Direct raylib calls via header require - no cpp wrapper needed!
  ;; Enum values accessible directly: rl/FLAG_WINDOW_RESIZABLE, rl/KEY_SPACE, etc.
  (rl/SetConfigFlags (bit-or rl/FLAG_WINDOW_RESIZABLE rl/FLAG_MSAA_4X_HINT))
  (rl/InitWindow 1280 720 "jank: Raylib + ImGui + Jolt + Flecs")
  (rl/SetTargetFPS 60))


(defn raylib-shutdown! [] (rl/CloseWindow))

(defn raylib-should-close? [] (rl/WindowShouldClose))

(defn get-dt [] (rl/GetFrameTime))

(defn get-fps [] (rl/GetFPS))

(defn begin-frame! []
  (rl/BeginDrawing)
  (rl/ClearBackground (rl/RAYWHITE)))

(defn end-frame! [] (rl/EndDrawing))

(defn draw-title! []
  (rl/DrawText "Raylib + ImGui + Jolt + Flecs" 10 10 20 (rl/DARKGRAY))
  (rl/DrawText "Top-Down 2D View (numbers show Y height)" 10 35 16 (rl/GRAY)))

;; =============================================================================
;; View manipulation helpers
;; =============================================================================

(defn scale-view!
  "Scale view by factor, clamped between 5.0 and 50.0. Pure jank."
  [factor]
  (let* [s (* (cpp/get_view_scale) factor)
         clamped (min 50.0 (max 5.0 s))]
    (cpp/= (cpp/get_view_scale) (cpp/float. clamped))
    nil))

(defn add-view-offset!
  "Add to view offset. Pure jank using cpp/= with read-modify-write."
  [dx dy]
  (let* [new-x (+ (cpp/get_view_offset_x) dx)
         new-y (+ (cpp/get_view_offset_y) dy)]
    (cpp/= (cpp/get_view_offset_x) (cpp/float. new-x))
    (cpp/= (cpp/get_view_offset_y) (cpp/float. new-y))
    nil))

(defn set-view-offset!
  "Set view offset directly. Pure jank using cpp/=."
  [x y]
  (cpp/= (cpp/get_view_offset_x) (cpp/float. x))
  (cpp/= (cpp/get_view_offset_y) (cpp/float. y))
  nil)

;; =============================================================================
;; ImGui - complex rendering stays in cpp, simple calls use header requires
;; =============================================================================

(defn imgui-init! [] (cpp/imgui_init))

(defn imgui-update! [] (cpp/imgui_update_input))

(defn imgui-new-frame! [] (imgui/NewFrame))  ;; Direct header require!

(defn imgui-render! [] (imgui/Render))       ;; Direct header require!

;; imgui-draw! defined after imgui-render-draw-data! below (function order matters)

;; =============================================================================
;; ImGui draw - uses C++ helper for nested loops (native types can't be captured in closures)
;; =============================================================================

(comment

  (binding [*allow-native-return* true]
    cpp/g_entities_ptr)

  (cpp/raw "std::vector<int> V {1,2,3}")

  (binding [*allow-native-return* true]
    cpp/V)

   (cpp/raw "namespace my_ns {
    inline std::vector<int>& V() {
      static std::vector<int> v{1,2,3};
      return v;
    }
  }")

  (binding [*allow-native-return* true]
    (cpp/my_ns.V))

  ())

#_(require '[jank.compiler :as jc])

(comment

  (let* [n 5
         m 10
         x 3.14
         y 2.0
         ;; Integer arithmetic
         _ (assert (= 15 (cpp/+ n m)))
         ;; Real arithmetic
         _ (assert (< 5.0 (cpp/+ x y)))
         ;; Mixed with explicit cpp/ type
         _ (assert (= 8 (cpp/+ n (cpp/int. 3))))]
    ss)

  (let [n 5
        m 10]
    ;; n and m should now be C++ ints that can be used with cpp/ operators directly
    (assert (= 15 (cpp/+ n m)))
    (assert (= 5 (cpp/- m n))))

  (let [dd (imgui/GetDrawData)]
    (dotimes [n (cpp/.-CmdListsCount dd)]
      (cpp/aget (cpp/.-CmdLists dd) n)))

  ())

(defn render-draw-data
  []
  (let [dd (imgui/GetDrawData)]
    (when (and (not (cpp/! dd))
               (not= (->* dd * .-CmdListsCount) 0))
      (rlgl/rlDrawRenderBatchActive)
      (rlgl/rlDisableBackfaceCulling)

      (dotimes [n (->* dd * .-CmdListsCount)]
        (let [cl (->* dd * .-CmdLists (aget n))
              vb (->* cl * .-VtxBuffer .-Data)
              ib (->* cl * .-IdxBuffer .-Data)]
          (dotimes [i (->* cl * .-CmdBuffer .-Size)]
            (let [pc (->* cl * .-CmdBuffer (aget i) &)]
              (if (cpp/! (->* pc * .-UserCallback))
                (let [p (->* dd * .-DisplayPos)
                      cr (->* pc * .-ClipRect)]
                  ;; BeginScissorMode expects int args - must cast from float
                  (rl/BeginScissorMode (int (- (->* cr .-x) (->* p .-x)))
                                       (int (- (->* cr .-y) (->* p .-y)))
                                       (int (- (->* cr .-z) (->* cr .-x)))
                                       (int (- (->* cr .-w) (->* cr .-y))))
                  (rlgl/rlSetTexture (->* pc * .GetTexID))
                  (rlgl/rlBegin rlgl/RL_TRIANGLES)

                  (loop [j 0]
                    (when (< j (->* pc * .-ElemCount))
                      (dotimes [k 3]
                        (let [idx (->* ib (aget (cpp/int (+ (->* pc * .-IdxOffset)
                                                            j
                                                            k))))
                              v (->* vb (aget idx) &)  ;; &vb[idx] - use index to get correct vertex
                              col (->* v * .-col)]
                          (rlgl/rlColor4ub (bit-and col 0xFF)
                                           (bit-and (bit-shift-right col 8) 0xFF)
                                           (bit-and (bit-shift-right col 16) 0xFF)
                                           (bit-and (bit-shift-right col 24) 0xFF))
                          (rlgl/rlTexCoord2f (->* v * .-uv .-x)
                                             (->* v * .-uv .-y))
                          (rlgl/rlVertex2f (->* v * .-pos .-x)
                                           (->* v * .-pos .-y))
                          nil))
                      (recur (+ j 3))))

                  (rlgl/rlEnd)
                  (rlgl/rlSetTexture 0)
                  (rl/EndScissorMode)
                  nil)
                ((->* pc * .-UserCallback) cl pc))))))

      (rlgl/rlEnableBackfaceCulling))))

(defn imgui-draw!
  "Draw ImGui. Pure jank implementation using loop* to avoid closure capture issues.
   Uses render-draw-data which handles the nested loops with native types."
  []
  #_(cpp/imgui_render_draw_data)
  (render-draw-data))

(defn imgui-wants-input?
  "Check if ImGui wants mouse/keyboard input. Pure jank via header require."
  []
  (or (boolean (cpp/.-WantCaptureMouse (imgui/GetIO)))
      (boolean (cpp/.-WantCaptureKeyboard (imgui/GetIO)))))

(defn imgui-shutdown!
  "Shutdown ImGui. Pure jank using rlgl header require."
  []
  (let [tex (cpp/get_font_tex)]
    (when (not= tex 0)
      (rlgl/rlUnloadTexture tex)
      (cpp/= (cpp/get_font_tex) (cpp/uint. 0))))
  (imgui/DestroyContext))

(defn imgui-reset-view!
  "Reset view to default position and scale. Pure jank using cpp/= for assignment."
  []
  (cpp/= (cpp/get_view_offset_x) (cpp/float. 640.0))
  (cpp/= (cpp/get_view_offset_y) (cpp/float. 500.0))
  (cpp/= (cpp/get_view_scale) (cpp/float. 15.0))
  nil)

;; =============================================================================
;; Input handling - pure jank with cpp/ prefix!
;; Uses let* with _ binding for void returns
;; =============================================================================

(defn handle-input!
  "Handle pan/zoom input. Returns true if space was pressed (spawn request)."
  []
  (if (imgui-wants-input?)
    false
    (let* [mouse-down (rl/IsMouseButtonDown rl/MOUSE_BUTTON_LEFT)]
      (when mouse-down
        (let* [delta (rl/GetMouseDelta)
               dx (cpp/.-x delta)
               dy (cpp/.-y delta)]
          (add-view-offset! dx dy)))
      (let* [wheel (rl/GetMouseWheelMove)]
        (when (not= wheel 0.0)
          (scale-view! (if (> wheel 0) 1.1 0.9))))
      (rl/IsKeyPressed rl/KEY_SPACE))))

;; =============================================================================
;; Drawing - pure jank with raylib header requires!
;; =============================================================================

(defn physics-to-screen
  "Convert physics coords (x,z) to screen coords. Returns [screen-x screen-y]."
  [px pz]
  [(+ (cpp/get_view_offset_x) (* px (cpp/get_view_scale)))
   (- (cpp/get_view_offset_y) (* pz (cpp/get_view_scale)))])

(defn draw-grid-line!
  "Draw a single grid line. Helper to avoid capturing Color in closure."
  [x1 y1 x2 y2]
  (rl/DrawLineV (rl/Vector2. (cpp/float. x1) (cpp/float. y1))
                (rl/Vector2. (cpp/float. x2) (cpp/float. y2))
                (rl/Fade (rl/LIGHTGRAY) (cpp/float. 0.3))))

(defn draw-grid!
  "Draw grid lines. Pure jank using raylib header requires."
  []
  (doseq [i (range -50 51 5)]
    ;; Vertical line
    (let [[x1 y1] (physics-to-screen i -50.0)
          [x2 y2] (physics-to-screen i 50.0)]
      (draw-grid-line! x1 y1 x2 y2))
    ;; Horizontal line
    (let [[x1 y1] (physics-to-screen -50.0 i)
          [x2 y2] (physics-to-screen 50.0 i)]
      (draw-grid-line! x1 y1 x2 y2)))
  nil)

(defn get-entity-position
  "Get entity position from Jolt. Returns [x y z]."
  [jolt-world jolt-id]
  (cpp/entity_get_position jolt-world jolt-id)
  [(cpp/entity_pos_x) (cpp/entity_pos_y) (cpp/entity_pos_z)])

(defn get-entity-color
  "Get entity color. Returns [r g b]. Using .at() for direct vector access!"
  [idx]
  (let [entity (cpp/.at (cpp/get_entities) (cpp/size_t. idx))]
    [(cpp/.-r entity) (cpp/.-g entity) (cpp/.-b entity)]))

(defn draw-entity!
  "Draw a single entity at index idx. Pure jank using cpp/.at for direct vector access!"
  [jolt-world idx]
  (let [entity (cpp/.at (cpp/get_entities) (cpp/size_t. idx))
        jolt-id (cpp/.-jolt_id entity)
        radius (cpp/.-radius entity)
        [er eg eb] (get-entity-color idx)
        [px py pz] (get-entity-position jolt-world jolt-id)
        [screen-x screen-y] (physics-to-screen px pz)
        view-scale (cpp/get_view_scale)
        sr (* radius view-scale)
        ;; Brightness based on height
        h-factor (min 1.0 (max 0.0 (/ (+ py 5.0) 50.0)))
        brightness (+ 0.5 (* 0.5 h-factor))
        ;; Color components with brightness
        col-r (int (* er brightness))
        col-g (int (* eg brightness))
        col-b (int (* eb brightness))
        ;; Shadow position
        shadow-x (int (+ screen-x (* py 0.5)))
        shadow-y (int (+ screen-y (* py 0.5)))
        ;; Ball position
        ball-x (int screen-x)
        ball-y (int screen-y)]
    ;; Draw shadow
    (rl/DrawCircle shadow-x shadow-y (cpp/float. (* sr 0.8)) (rl/Fade (rl/BLACK) (cpp/float. 0.2)))
    ;; Draw ball (inline Color creation to avoid boxing issues)
    (rl/DrawCircle ball-x ball-y (cpp/float. sr)
                   (rl/Color. (cpp/uint8_t. col-r) (cpp/uint8_t. col-g) (cpp/uint8_t. col-b) (cpp/uint8_t. 255)))
    ;; Draw outline
    (rl/DrawCircleLines ball-x ball-y (cpp/float. sr) (rl/BLACK))
    ;; Height label
    (cpp/draw_height_label ball-x ball-y (int py))
    nil))

(defn draw-entities!
  "Draw all entities. Pure jank - iterates over entity storage."
  [world]
  (let [count (entity-count)]
    (dotimes [i count]
      (draw-entity! world i))
    nil))

(defmacro with-panel
  [title & body]
  `(try
     (imgui/Begin ~title)
     ~@body
     (finally (imgui/End))))

;; TODO FLECS
(defonce *per-frame-state (atom {}))

(defn draw-imgui-panel!
  [w]
  ;; TODO FLECS
  (reset! *per-frame-state {})

  (imgui/SetNextWindowPos (imgui-h/ImVec2 900.0 40.0))

  (with-panel "Physics Debug"

    ;; Stats section
    (imgui/Text #cpp "FPS: %d" (rl/GetFPS))
    (imgui/Separator)
    (imgui/Text #cpp "Jolt Bodies: %d" (jolt/jolt_world_get_num_bodies (cpp/opaque_box_ptr w)))
    (imgui/Text #cpp "Active: %d" (jolt/jolt_world_get_num_active_bodies (cpp/opaque_box_ptr w)))
    (imgui/Text #cpp "Flecs Entities: %d" (cpp/int. (entity-count)))
    (imgui/Separator)

    (imgui/Checkbox "Paused" (cpp/unbox is-paused))
    (imgui/SliderFloat "Time Scale" (cpp/& (cpp/get_time_scale)) 0.1 3.0)
    (imgui/SliderInt "Spawn Count" (cpp/& (cpp/get_spawn_count)) 1 20)
    (imgui/Separator)

    (when (imgui/Button "Reset Simulation") (swap! *per-frame-state assoc ::reset-simulation true))
    (imgui/SameLine)
    (when (imgui/Button "Reset View") (imgui-reset-view!))

    ;; View info
    (imgui/Text #cpp "View: (%.0f, %.0f) scale: %.1f"
                (cpp/get_view_offset_x)
                (cpp/get_view_offset_y)
                (cpp/get_view_scale))
    (imgui/Separator)

    ;; Help text
    (imgui/Text "Controls:")
    (imgui/BulletText "Drag to pan")
    (imgui/BulletText "Scroll to zoom")
    (imgui/BulletText "Space to spawn")))

(defn reset-simulation!
  "Reset the simulation - destroy old world, clear entities, create new world with floor.
   Pure jank implementation!"
  [world]
  (destroy-world! world)
  (clear-entities!)
  (doto (create-world)
    create-floor))

;; =============================================================================
;; Game logic (in jank)
;; =============================================================================

(defn rand-range [min max]
  (+ min (* (rand) (- max min))))

(defn spawn-ball! [jolt-world flecs-world]
  (let [x (rand-range -20 20)
        y (rand-range 15 40)
        z (rand-range -20 20)
        r (rand-range 0.5 1.5)
        cr (int (rand-range 50 255))
        cg (int (rand-range 50 255))
        cb (int (rand-range 50 255))
        id (create-sphere jolt-world x y z r)
        vx (rand-range -10 10)
        vz (rand-range -10 10)]
    (set-velocity! jolt-world id vx 0.0 vz)
    (add-entity! flecs-world id r cr cg cb)))

(defn spawn-balls! [jolt-world flecs-world n]
  (dotimes [_ n]
    (spawn-ball! jolt-world flecs-world)))

(defn spawn-initial-balls! [jolt-world flecs-world]
  (dotimes [_ 200]
    (spawn-ball! jolt-world flecs-world)))

(defn draw
  [flecs-world jolt-world]
  ;; Continue running
  (let [dt (get-dt)]

    ;; Update ImGui
    (imgui-update!)
    (imgui-new-frame!)

    ;; Handle input
    (when (handle-input!)
      (spawn-balls! jolt-world flecs-world (spawn-count)))

    ;; Physics step
    (when-not (paused?)
      (step! jolt-world (* dt (time-scale))))

    ;; Draw ImGui UI
    (draw-imgui-panel! jolt-world)
    (imgui-render!)

    ;; Render
    (begin-frame!)
    (draw-grid!)
    (draw-entities! jolt-world)
    (draw-title!)
    (imgui-draw!)
    (end-frame!)

    ;; Check for reset and recur with possibly new jolt-world
    (if (::reset-simulation @*per-frame-state)
      (let [new-jolt-world (reset-simulation! jolt-world)]
        (spawn-initial-balls! new-jolt-world flecs-world)
        (optimize! new-jolt-world)
        new-jolt-world)
      jolt-world)))

;; =============================================================================
;; Main function
;; =============================================================================

(defn -main [& args]
  #?(:jank (server/start-server {:port 5557}))

  (println "Starting integrated demo: Raylib + ImGui + Jolt + Flecs")
  (println "Using jank header requires + static linking!")
  (println "")

  ;; Initialize raylib
  (raylib-init!)

  ;; Initialize Flecs ECS via header require!
  (println "Initializing Flecs ECS...")
  (let [flecs-world (flecs-create-world)]

    ;; Initialize Jolt
    (println "Creating physics world...")
    (let [initial-jolt-world (create-world)]
      (create-floor initial-jolt-world)
      (spawn-initial-balls! initial-jolt-world flecs-world)
      (optimize! initial-jolt-world)

      ;; Initialize ImGui
      (imgui-init!)

      (println "Demo initialized! Press ESC to exit.")

      ;; Main loop with jolt-world as loop parameter (allows reset)
      (loop [jolt-world initial-jolt-world]
        (if (raylib-should-close?)
          ;; Cleanup and exit
          (do
            (imgui-shutdown!)
            (destroy-world! jolt-world)
            (flecs-destroy-world! flecs-world)
            (raylib-shutdown!)
            (println "Done!"))
          (recur (draw flecs-world jolt-world)))))))
