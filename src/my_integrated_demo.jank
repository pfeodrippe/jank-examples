(ns my-integrated-demo
  (:require
   ;; Raylib with global scope (C functions)
   ["raylib.h" :as rl :scope ""]
   ;; rlgl for low-level OpenGL functions (rlUnloadTexture, etc.)
   ["rlgl.h" :as rlgl :scope ""]
   ;; ImGui with ImGui:: scope
   ["imgui.h" :as imgui :scope "ImGui"]
   ["imgui.h" :as imgui-h :scope ""]
   ;; Flecs C API with global scope
   ["flecs.h" :as fl :scope ""]
   ;; Jolt C API with global scope
   ["jolt_c.h" :as jolt :scope ""]
   [jank.nrepl-server.server :as server]
   [clojure.string :as str]
   [vybe.util :as u :refer [->*]]))

;; Integrated demo: Raylib + ImGui + JoltPhysics + Flecs
;; Uses header requires for cleaner code

;; =============================================================================
;; C++ bridging layer (minimal - only what can't be done via header requires)
;; =============================================================================

(cpp/raw "
#include <cstdio>
#include <cstdint>
#include <cstring>
#include <raylib.h>
#include <rlgl.h>
#include <imgui.h>
#include <flecs.h>
#include <jank/runtime/obj/opaque_box.hpp>

// =============================================================================
// JIT stubs (required for JIT linking)
// =============================================================================

extern \"C\" {
    struct __emutls_control {
        size_t size; size_t align;
        union { size_t offset; void *ptr; } object;
        void *templ;
    };
    void* __emutls_get_address(__emutls_control* control) {
        if (!control->object.ptr) {
            control->object.ptr = malloc(control->size);
            if (control->templ) memcpy(control->object.ptr, control->templ, control->size);
            else memset(control->object.ptr, 0, control->size);
        }
        return control->object.ptr;
    }
}

namespace JPH {
    using AssertFailedFunction = bool(*)(const char*, const char*, const char*, unsigned int);
    AssertFailedFunction AssertFailed = [](const char* e, const char* m, const char* f, unsigned int l) -> bool {
        printf(\"[JOLT] %s:%u: %s\\n\", f, l, m ? m : e);
        return false;
    };
}

// Jolt C API now comes from header require: [\"jolt_c.h\" :as jolt :scope \"\"]
#include <jolt_c.h>

// =============================================================================
// Entity storage (ODR-safe vector + Flecs entity IDs)
// =============================================================================

struct Entity {
    uint64_t flecs_id;  // Flecs entity ID
    uint32_t jolt_id;   // Jolt body ID
    float radius;
    uint8_t r, g, b;
};

static std::vector<Entity>* g_entities_ptr = nullptr;

inline std::vector<Entity>& get_entities() {
    if (!g_entities_ptr) g_entities_ptr = new std::vector<Entity>();
    return *g_entities_ptr;
}

// =============================================================================
// Global state with heap-pointer pattern (ODR-safe)
// =============================================================================

static void* g_jolt_world = nullptr;
static float* g_time_scale_ptr = nullptr;
static int* g_spawn_count_ptr = nullptr;
static float* g_view_scale_ptr = nullptr;
static float* g_view_offset_x_ptr = nullptr;
static float* g_view_offset_y_ptr = nullptr;
static unsigned int* g_font_tex_ptr = nullptr;

inline float& get_time_scale() {
    if (!g_time_scale_ptr) g_time_scale_ptr = new float(1.0f);
    return *g_time_scale_ptr;
}

inline int& get_spawn_count() {
    if (!g_spawn_count_ptr) g_spawn_count_ptr = new int(5);
    return *g_spawn_count_ptr;
}

inline float& get_view_scale() {
    if (!g_view_scale_ptr) g_view_scale_ptr = new float(15.0f);
    return *g_view_scale_ptr;
}

inline float& get_view_offset_x() {
    if (!g_view_offset_x_ptr) g_view_offset_x_ptr = new float(640.0f);
    return *g_view_offset_x_ptr;
}

inline float& get_view_offset_y() {
    if (!g_view_offset_y_ptr) g_view_offset_y_ptr = new float(500.0f);
    return *g_view_offset_y_ptr;
}

inline unsigned int& get_font_tex() {
    if (!g_font_tex_ptr) g_font_tex_ptr = new unsigned int(0);
    return *g_font_tex_ptr;
}

// =============================================================================
// Jolt wrapper functions
// =============================================================================

inline jank::runtime::object_ref jolt_create_world() {
    g_jolt_world = jolt_world_create();
    return jank::runtime::make_box<jank::runtime::obj::opaque_box>(g_jolt_world, \"JoltWorld\");
}

inline void jolt_destroy_world(jank::runtime::object_ref w) {
    auto o = jank::runtime::expect_object<jank::runtime::obj::opaque_box>(w);
    jolt_world_destroy(o->data.data);
    g_jolt_world = nullptr;
}

inline int64_t jolt_create_sphere(jank::runtime::object_ref w, double x, double y, double z, double r) {
    auto o = jank::runtime::expect_object<jank::runtime::obj::opaque_box>(w);
    return jolt_body_create_sphere(o->data.data, (float)x, (float)y, (float)z, (float)r, true, true);
}

inline int64_t jolt_create_floor(jank::runtime::object_ref w) {
    auto o = jank::runtime::expect_object<jank::runtime::obj::opaque_box>(w);
    return jolt_body_create_box(o->data.data, 0, -0.5f, 0, 50, 0.5f, 50, false, false);
}

// =============================================================================
// Flecs helpers - minimal wrappers for opaque_box handling
// Uses fl/ecs_mini for init (called from jank), wrappers for opaque_box ops
// =============================================================================

// Wrapper needed: ecs_fini needs raw pointer from opaque_box
inline void flecs_fini_world(jank::runtime::object_ref flecs_world_box) {
    auto o = jank::runtime::expect_object<jank::runtime::obj::opaque_box>(flecs_world_box);
    ecs_fini(static_cast<ecs_world_t*>(o->data.data));
}

inline void flecs_add_entity(jank::runtime::object_ref flecs_world_box, int64_t jolt_id, double radius, int64_t r, int64_t g, int64_t b) {
    // Extract world from opaque_box and create entity
    auto o = jank::runtime::expect_object<jank::runtime::obj::opaque_box>(flecs_world_box);
    ecs_world_t* world = static_cast<ecs_world_t*>(o->data.data);
    uint64_t flecs_id = ecs_new(world);

    // Store in vector for iteration (avoids JIT template issues with Flecs queries)
    Entity e;
    e.flecs_id = flecs_id;
    e.jolt_id = (uint32_t)jolt_id;
    e.radius = (float)radius;
    e.r = (uint8_t)r;
    e.g = (uint8_t)g;
    e.b = (uint8_t)b;
    get_entities().push_back(e);
}

// flecs_entity_count and flecs_clear_entities are now in pure jank!
// Using cpp/.size and cpp/.clear on get_entities() vector directly

// Entity position and height label now in pure jank!
// See: get-entity-position, draw-entity! (uses rl/TextFormat)

// =============================================================================
// Rendering functions - NOW MOSTLY IN PURE JANK!
// ImGui init/update/render now in jank (see imgui-init!, imgui-update-input!)
// See jank section below for: draw-grid!, physics-to-screen, draw-entities!
// =============================================================================
")

;; get_view_offset_x() = 640.0f;
#_(jc/native-source '


   (cpp/= (cpp/get_view_offset_x) (cpp/float. 640.0)))

#_(cpp/get_view_offset_x)

(cpp/raw
 "// =============================================================================
// opaque_box helper - extracts void* from any opaque_box (minimal cpp/raw)
// =============================================================================

inline void* opaque_box_ptr(jank::runtime::object_ref box) {
    auto o = jank::runtime::expect_object<jank::runtime::obj::opaque_box>(box);
    return o->data.data;
}
")

;; =============================================================================
;; UI State
;; =============================================================================

(defonce is-paused (u/v->p false))

;; =============================================================================
;; Jolt wrapper functions
;; =============================================================================

(defn create-world [] (cpp/jolt_create_world))

(defn destroy-world! [w] (cpp/jolt_destroy_world w))

(defn create-sphere [w x y z r] (cpp/jolt_create_sphere w x y z r))

(defn create-floor [w] (cpp/jolt_create_floor w))

(defn set-velocity! [w id vx vy vz]
  (jolt/jolt_body_set_velocity (cpp/opaque_box_ptr w) (cpp/uint32_t. id) (cpp/float. vx) (cpp/float. vy) (cpp/float. vz)))

(defn step! [w dt] (jolt/jolt_world_step (cpp/opaque_box_ptr w) (cpp/float. dt) 1))

(defn optimize! [w] (jolt/jolt_world_optimize_broad_phase (cpp/opaque_box_ptr w)))

(defn num-bodies [w] (jolt/jolt_world_get_num_bodies (cpp/opaque_box_ptr w)))

(defn num-active [w] (jolt/jolt_world_get_num_active_bodies (cpp/opaque_box_ptr w)))

;; =============================================================================
;; Flecs - using header require directly!
;; =============================================================================

(defn flecs-create-world "Create a Flecs world via C API and wrap in opaque_box." []
  (println "[flecs] ECS world created via fl/ecs_mini")
  (cpp/box (fl/ecs_mini)))

(defn flecs-destroy-world! "Destroy a Flecs world."
  [flecs-world]
  (cpp/flecs_fini_world flecs-world))

(defn add-entity! "Add entity to Flecs world and entity storage."
  [flecs-world jolt-id r cr cg cb]
  (cpp/flecs_add_entity flecs-world jolt-id r cr cg cb))

(defn entity-count
  "Get entity count using cpp/.size on the entities vector."
  []
  (cpp/.size (cpp/get_entities)))

(defn clear-entities!
  "Clear entities using cpp/.clear on the entities vector."
  []
  (cpp/.clear (cpp/get_entities)))

;; =============================================================================
;; State accessors (read-only from jank - ImGui panel handles mutation)
;; =============================================================================

(defn paused? [] (u/p->v is-paused))

(defn time-scale [] (cpp/get_time_scale))

(defn spawn-count [] (cpp/get_spawn_count))

(defn view-scale [] (cpp/get_view_scale))

;; =============================================================================
;; Raylib - using header requires directly!
;; =============================================================================

(defn raylib-init! []
  ;; Direct raylib calls via header require - no cpp wrapper needed!
  ;; Enum values accessible directly: rl/FLAG_WINDOW_RESIZABLE, rl/KEY_SPACE, etc.
  (rl/SetConfigFlags (bit-or rl/FLAG_WINDOW_RESIZABLE rl/FLAG_MSAA_4X_HINT))
  (rl/InitWindow 1280 720 "jank: Raylib + ImGui + Jolt + Flecs")
  (rl/SetTargetFPS 60))


(defn raylib-shutdown! [] (rl/CloseWindow))

(defn raylib-should-close? [] (rl/WindowShouldClose))

(defn get-dt [] (rl/GetFrameTime))

(defn get-fps [] (rl/GetFPS))

(defn begin-frame! []
  (rl/BeginDrawing)
  (rl/ClearBackground (rl/RAYWHITE)))

(defn end-frame! [] (rl/EndDrawing))

(defn draw-title! []
  (rl/DrawText "Raylib + ImGui + Jolt + Flecs" 10 10 20 (rl/DARKGRAY))
  (rl/DrawText "Top-Down 2D View (numbers show Y height)" 10 35 16 (rl/GRAY)))

;; =============================================================================
;; View manipulation helpers
;; =============================================================================

(defn scale-view!
  "Scale view by factor, clamped between 5.0 and 50.0. Pure jank."
  [factor]
  (let [s (* (cpp/get_view_scale) factor)
        clamped (min 50.0 (max 5.0 s))]
    (cpp/= (cpp/get_view_scale) (cpp/float. clamped))
    nil))

(defn add-view-offset!
  "Add to view offset. Pure jank using cpp/= with read-modify-write."
  [dx dy]
  (let [new-x (+ (cpp/get_view_offset_x) dx)
        new-y (+ (cpp/get_view_offset_y) dy)]
    (cpp/= (cpp/get_view_offset_x) (cpp/float. new-x))
    (cpp/= (cpp/get_view_offset_y) (cpp/float. new-y))
    nil))

(defn set-view-offset!
  "Set view offset directly. Pure jank using cpp/=."
  [x y]
  (cpp/= (cpp/get_view_offset_x) (cpp/float. x))
  (cpp/= (cpp/get_view_offset_y) (cpp/float. y))
  nil)

;; =============================================================================
;; ImGui
;; =============================================================================

(defn imgui-load-font-texture!
  "Load ImGui font texture. Pure jank with out-param handling."
  []
  ;; Allocate out-param variables on heap
  (let [pixels_ptr (cpp/new (cpp/type "unsigned char*") (cpp/value "nullptr"))
        w_ptr (cpp/new cpp/int 0)
        h_ptr (cpp/new cpp/int 0)
        io (imgui/GetIO)
        fonts (cpp/.-Fonts io)
        ;; Get font texture data (fills out params) - fonts is pointer, dereference first
        _ (cpp/.GetTexDataAsRGBA32 (cpp/* fonts) pixels_ptr w_ptr h_ptr)
        ;; Create Image struct using constructor
        img (rl/Image. (cpp/* pixels_ptr) ;; data
                       (cpp/* w_ptr)      ;; width
                       (cpp/* h_ptr)      ;; height
                       (cpp/int. 1)       ;; mipmaps
                       rl/PIXELFORMAT_UNCOMPRESSED_R8G8B8A8)
        tex (rl/LoadTextureFromImage img)
        tex_id (cpp/.-id tex)
        ;; Store texture ID
        ]
    (cpp/= (cpp/get_font_tex) tex_id)
    ;; Set texture ID in ImGui fonts
    (cpp/.SetTexID (cpp/* fonts) (cpp/cast (cpp/type "ImTextureID")
                                             (cpp/cast cpp/intptr_t tex_id)))
    nil))

(defn imgui-init!
  "Initialize ImGui. Pure jank."
  []
  (imgui/CreateContext)
  (let [io (imgui/GetIO)
        flags (->* io .-ConfigFlags)]
    (cpp/= flags (cpp/int (bit-or flags imgui-h/ImGuiConfigFlags_NavEnableKeyboard)))
    (imgui/StyleColorsDark)
    (cpp/= (->* io .-DisplaySize)
           (imgui-h/ImVec2. (cpp/float. (rl/GetScreenWidth))
                            (cpp/float. (rl/GetScreenHeight))))
    (imgui-load-font-texture!)))

(defn imgui-update-input!
  "Update ImGui input from raylib. Pure jank implementation."
  []
  (let [io (imgui/GetIO)
        _ (do (cpp/= (cpp/.-DisplaySize io)
                     (imgui-h/ImVec2. (cpp/float. (rl/GetScreenWidth)) (cpp/float. (rl/GetScreenHeight))))
              (cpp/= (cpp/.-DeltaTime io) (rl/GetFrameTime)))
        m (rl/GetMousePosition)
        _ (do (cpp/.AddMousePosEvent io (cpp/.-x m) (cpp/.-y m))
              (cpp/.AddMouseButtonEvent io 0 (rl/IsMouseButtonDown rl/MOUSE_BUTTON_LEFT))
              (cpp/.AddMouseButtonEvent io 1 (rl/IsMouseButtonDown rl/MOUSE_BUTTON_RIGHT)))
        wh (rl/GetMouseWheelMoveV)]
    (cpp/.AddMouseWheelEvent io (cpp/.-x wh) (cpp/.-y wh))
    ;; Keyboard modifiers
    (cpp/.AddKeyEvent io imgui-h/ImGuiMod_Ctrl (or (rl/IsKeyDown rl/KEY_LEFT_CONTROL)
                                                   (rl/IsKeyDown rl/KEY_RIGHT_CONTROL)))
    (cpp/.AddKeyEvent io imgui-h/ImGuiMod_Shift (or (rl/IsKeyDown rl/KEY_LEFT_SHIFT)
                                                    (rl/IsKeyDown rl/KEY_RIGHT_SHIFT)))
    ;; Character input - use cpp/raw for while loop with native int
    (cpp/raw "{
ImGuiIO& io = ImGui::GetIO();
int c = GetCharPressed();
while (c > 0) { io.AddInputCharacter(c); c = GetCharPressed(); }
 }"))
  nil)

(defn imgui-update! [] (imgui-update-input!))

(defn imgui-new-frame! [] (imgui/NewFrame))  ;; Direct header require!

(defn imgui-render! [] (imgui/Render))       ;; Direct header require!

;; imgui-draw! defined after imgui-render-draw-data! below (function order matters)

;; =============================================================================
;; ImGui draw - uses C++ helper for nested loops (native types can't be captured in closures)
;; =============================================================================

(comment

  (binding [*allow-native-return* true]
    cpp/g_entities_ptr)

  (cpp/raw "std::vector<int> V {1,2,3}")

  (binding [*allow-native-return* true]
    cpp/V)

   (cpp/raw "namespace my_ns {
    inline std::vector<int>& V() {
      static std::vector<int> v{1,2,3};
      return v;
    }
  }")

  (binding [*allow-native-return* true]
    (cpp/my_ns.V))

  ())

#_(require '[jank.compiler :as jc])

(comment

  (let* [n 5
         m 10
         x 3.14
         y 2.0
         ;; Integer arithmetic
         _ (assert (= 15 (cpp/+ n m)))
         ;; Real arithmetic
         _ (assert (< 5.0 (cpp/+ x y)))
         ;; Mixed with explicit cpp/ type
         _ (assert (= 8 (cpp/+ n (cpp/int. 3))))]
    ss)

  (let [n 5
        m 10]
    ;; n and m should now be C++ ints that can be used with cpp/ operators directly
    (assert (= 15 (cpp/+ n m)))
    (assert (= 5 (cpp/- m n))))

  (let [dd (imgui/GetDrawData)]
    (dotimes [n (cpp/.-CmdListsCount dd)]
      (cpp/aget (cpp/.-CmdLists dd) n)))

  ())

(defn imgui-draw!
  []
  (let [dd (imgui/GetDrawData)]
    (when (and (not (cpp/! dd))
               (not= (->* dd * .-CmdListsCount) 0))
      (rlgl/rlDrawRenderBatchActive)
      (rlgl/rlDisableBackfaceCulling)

      (dotimes [n (->* dd * .-CmdListsCount)]
        (let [cl (->* dd * .-CmdLists (aget n))
              vb (->* cl * .-VtxBuffer .-Data)
              ib (->* cl * .-IdxBuffer .-Data)]
          (dotimes [i (->* cl * .-CmdBuffer .-Size)]
            (let [pc (->* cl * .-CmdBuffer (aget i) &)]
              (if (cpp/! (->* pc * .-UserCallback))
                (let [p (->* dd * .-DisplayPos)
                      cr (->* pc * .-ClipRect)]
                  (rl/BeginScissorMode (int (- (->* cr .-x) (->* p .-x)))
                                       (int (- (->* cr .-y) (->* p .-y)))
                                       (int (- (->* cr .-z) (->* cr .-x)))
                                       (int (- (->* cr .-w) (->* cr .-y))))
                  (rlgl/rlSetTexture (->* pc * .GetTexID))
                  (rlgl/rlBegin rlgl/RL_TRIANGLES)

                  (loop [j 0]
                    (when (< j (->* pc * .-ElemCount))
                      (dotimes [k 3]
                        (let [idx (->* ib (aget (cpp/int (+ (->* pc * .-IdxOffset)
                                                            j
                                                            k))))
                              v (->* vb (aget idx) &)
                              col (->* v * .-col)]
                          (rlgl/rlColor4ub (bit-and col 0xFF)
                                           (bit-and (bit-shift-right col 8) 0xFF)
                                           (bit-and (bit-shift-right col 16) 0xFF)
                                           (bit-and (bit-shift-right col 24) 0xFF))
                          (rlgl/rlTexCoord2f (->* v * .-uv .-x)
                                             (->* v * .-uv .-y))
                          (rlgl/rlVertex2f (->* v * .-pos .-x)
                                           (->* v * .-pos .-y))
                          nil))
                      (recur (+ j 3))))

                  (rlgl/rlEnd)
                  (rlgl/rlSetTexture 0)
                  (rl/EndScissorMode)
                  nil)
                ((->* pc * .-UserCallback) cl pc))))))

      (rlgl/rlEnableBackfaceCulling))))

(defn imgui-wants-input?
  "Check if ImGui wants mouse/keyboard input. Pure jank via header require."
  []
  (or (boolean (cpp/.-WantCaptureMouse (imgui/GetIO)))
      (boolean (cpp/.-WantCaptureKeyboard (imgui/GetIO)))))

(defn imgui-shutdown!
  "Shutdown ImGui. Pure jank using rlgl header require."
  []
  (let [tex (cpp/get_font_tex)]
    (when (not= tex 0)
      (rlgl/rlUnloadTexture tex)
      (cpp/= (cpp/get_font_tex) (cpp/uint. 0))))
  (imgui/DestroyContext))

(defn imgui-reset-view!
  "Reset view to default position and scale. Pure jank using cpp/= for assignment."
  []
  (cpp/= (cpp/get_view_offset_x) (cpp/float. 640.0))
  (cpp/= (cpp/get_view_offset_y) (cpp/float. 500.0))
  (cpp/= (cpp/get_view_scale) (cpp/float. 15.0))
  nil)

;; =============================================================================
;; Input handling
;; =============================================================================

(defn handle-input!
  "Handle pan/zoom input. Returns true if space was pressed (spawn request)."
  []
  (if (imgui-wants-input?)
    false
    (let [mouse-down (rl/IsMouseButtonDown rl/MOUSE_BUTTON_LEFT)]
      (when mouse-down
        (let [delta (rl/GetMouseDelta)
              dx (cpp/.-x delta)
              dy (cpp/.-y delta)]
          (add-view-offset! dx dy)))
      (let [wheel (rl/GetMouseWheelMove)]
        (when (not= wheel 0.0)
          (scale-view! (if (> wheel 0) 1.1 0.9))))
      (rl/IsKeyPressed rl/KEY_SPACE))))

;; =============================================================================
;; Drawing - pure jank with raylib header requires!
;; =============================================================================

(defn physics-to-screen
  "Convert physics coords (x,z) to screen coords. Returns [screen-x screen-y] as jank numbers."
  [px pz]
  ;; Convert native floats to jank numbers for consistent arithmetic
  (let [offset-x (double (cpp/get_view_offset_x))
        offset-y (double (cpp/get_view_offset_y))
        scale (double (cpp/get_view_scale))]
    [(+ offset-x (* px scale))
     (- offset-y (* pz scale))]))

(defn draw-grid-line!
  "Draw a single grid line. Helper to avoid capturing Color in closure."
  [x1 y1 x2 y2]
  (rl/DrawLineV (rl/Vector2. (cpp/float. x1) (cpp/float. y1))
                (rl/Vector2. (cpp/float. x2) (cpp/float. y2))
                (rl/Fade (rl/LIGHTGRAY) (cpp/float. 0.3))))

(defn draw-grid!
  "Draw grid lines. Pure jank using raylib header requires."
  []
  (doseq [i (range -50 51 5)]
    ;; Vertical line
    (let [[x1 y1] (physics-to-screen i -50.0)
          [x2 y2] (physics-to-screen i 50.0)]
      (draw-grid-line! x1 y1 x2 y2))
    ;; Horizontal line
    (let [[x1 y1] (physics-to-screen -50.0 i)
          [x2 y2] (physics-to-screen 50.0 i)]
      (draw-grid-line! x1 y1 x2 y2)))
  nil)

;; Stores for caching position values (avoids boxing in hot path)
(def ^:private *pos-x (atom 0.0))
(def ^:private *pos-y (atom 0.0))
(def ^:private *pos-z (atom 0.0))

(defn get-entity-position!
  "Get entity position from Jolt. Stores in atoms to avoid boxing. Returns nil."
  [jolt-world jolt-id]
  (let [x_ptr (cpp/new cpp/float 0.0)
        y_ptr (cpp/new cpp/float 0.0)
        z_ptr (cpp/new cpp/float 0.0)
        world_ptr (cpp/opaque_box_ptr jolt-world)]
    (jolt/jolt_body_get_position world_ptr (cpp/uint32_t. jolt-id) x_ptr y_ptr z_ptr)
    (reset! *pos-x (double (cpp/* x_ptr)))
    (reset! *pos-y (double (cpp/* y_ptr)))
    (reset! *pos-z (double (cpp/* z_ptr)))
    nil))

(defn entity-pos-x [] @*pos-x)
(defn entity-pos-y [] @*pos-y)
(defn entity-pos-z [] @*pos-z)

(defn get-entity-color
  "Get entity color. Returns [r g b] as jank integers."
  [idx]
  (let [entity (cpp/.at (cpp/get_entities) (cpp/size_t. idx))]
    ;; Convert native unsigned chars to jank integers for arithmetic
    [(int (cpp/.-r entity)) (int (cpp/.-g entity)) (int (cpp/.-b entity))]))

(defn draw-entity!
  "Draw a single entity at index idx. Pure jank using cpp/.at for direct vector access!"
  [jolt-world idx]
  (let [entity (cpp/.at (cpp/get_entities) (cpp/size_t. idx))
        jolt-id (cpp/.-jolt_id entity)
        radius (cpp/.-radius entity)
        [er eg eb] (get-entity-color idx)
        _ (get-entity-position! jolt-world jolt-id)
        px (entity-pos-x)
        py (entity-pos-y)
        pz (entity-pos-z)
        [screen-x screen-y] (physics-to-screen px pz)
        view-scale (double (cpp/get_view_scale))
        sr (* (double radius) view-scale)
        ;; Brightness based on height
        h-factor (min 1.0 (max 0.0 (/ (+ py 5.0) 50.0)))
        brightness (+ 0.5 (* 0.5 h-factor))
        ;; Color components with brightness
        col-r (int (* er brightness))
        col-g (int (* eg brightness))
        col-b (int (* eb brightness))
        ;; Shadow position
        shadow-x (int (+ screen-x (* py 0.5)))
        shadow-y (int (+ screen-y (* py 0.5)))
        ;; Ball position
        ball-x (int screen-x)
        ball-y (int screen-y)]
    ;; Draw shadow
    (rl/DrawCircle shadow-x shadow-y (cpp/float. (* sr 0.8)) (rl/Fade (rl/BLACK) (cpp/float. 0.2)))
    ;; Draw ball (inline Color creation to avoid boxing issues)
    (rl/DrawCircle ball-x ball-y (cpp/float. sr)
                   (rl/Color. (cpp/uint8_t. col-r) (cpp/uint8_t. col-g) (cpp/uint8_t. col-b) (cpp/uint8_t. 255)))
    ;; Draw outline
    (rl/DrawCircleLines ball-x ball-y (cpp/float. sr) (rl/BLACK))
    ;; Height label - use TextFormat for sprintf-like formatting
    (rl/DrawText (rl/TextFormat #cpp "%d" (cpp/int. (int py))) (int (- ball-x 10)) (int (- ball-y 5)) 10 rl/BLACK)
    nil))

(defn draw-entities!
  "Draw all entities. Pure jank - iterates over entity storage."
  [world]
  (let [count (entity-count)]
    (dotimes [i count]
      (draw-entity! world i))
    nil))

(defmacro with-panel
  [title & body]
  `(try
     (imgui/Begin ~title)
     ~@body
     (finally (imgui/End))))

;; TODO FLECS
(defonce *per-frame-state (atom {}))

(defn draw-imgui-panel!
  [w]
  ;; TODO FLECS
  (reset! *per-frame-state {})

  (imgui/SetNextWindowPos (imgui-h/ImVec2 900.0 40.0))

  (with-panel "Physics Debug"

    ;; Stats section
    (imgui/Text #cpp "FPS: %d" (rl/GetFPS))
    (imgui/Separator)
    (imgui/Text #cpp "Jolt Bodies: %d" (jolt/jolt_world_get_num_bodies (cpp/opaque_box_ptr w)))
    (imgui/Text #cpp "Active: %d" (jolt/jolt_world_get_num_active_bodies (cpp/opaque_box_ptr w)))
    (imgui/Text #cpp "Flecs Entities: %d" (cpp/int. (entity-count)))
    (imgui/Separator)

    (imgui/Checkbox "Paused" (cpp/unbox is-paused))
    (imgui/SliderFloat "Time Scale" (cpp/& (cpp/get_time_scale)) 0.1 3.0)
    (imgui/SliderInt "Spawn Count" (cpp/& (cpp/get_spawn_count)) 1 20)
    (imgui/Separator)

    (when (imgui/Button "Reset Simulation") (swap! *per-frame-state assoc ::reset-simulation true))
    (imgui/SameLine)
    (when (imgui/Button "Reset View") (imgui-reset-view!))

    ;; View info
    (imgui/Text #cpp "View: (%.0f, %.0f) scale: %.1f"
                (cpp/get_view_offset_x)
                (cpp/get_view_offset_y)
                (cpp/get_view_scale))
    (imgui/Separator)

    ;; Help text
    (imgui/Text "Controls:")
    (imgui/BulletText "Drag to pan")
    (imgui/BulletText "Scroll to zoom")
    (imgui/BulletText "Space to spawn")))

(defn reset-simulation!
  "Reset the simulation - destroy old world, clear entities, create new world with floor.
   Pure jank implementation!"
  [world]
  (destroy-world! world)
  (clear-entities!)
  (doto (create-world)
    create-floor))

;; =============================================================================
;; Game logic (in jank)
;; =============================================================================

(defn rand-range [min max]
  (+ min (* (rand) (- max min))))

(defn spawn-ball! [jolt-world flecs-world]
  (let [x (rand-range -20 20)
        y (rand-range 15 40)
        z (rand-range -20 20)
        r (rand-range 0.5 1.5)
        cr (int (rand-range 50 255))
        cg (int (rand-range 50 255))
        cb (int (rand-range 50 255))
        id (create-sphere jolt-world x y z r)
        vx (rand-range -10 10)
        vz (rand-range -10 10)]
    (set-velocity! jolt-world id vx 0.0 vz)
    (add-entity! flecs-world id r cr cg cb)))

(defn spawn-balls! [jolt-world flecs-world n]
  (dotimes [_ n]
    (spawn-ball! jolt-world flecs-world)))

(defn spawn-initial-balls! [jolt-world flecs-world]
  (dotimes [_ 200]
    (spawn-ball! jolt-world flecs-world)))

(defn draw
  [flecs-world jolt-world]
  ;; Continue running
  (let [dt (get-dt)]

    ;; Update ImGui
    (imgui-update!)
    (imgui-new-frame!)

    ;; Handle input
    (when (handle-input!)
      (spawn-balls! jolt-world flecs-world (spawn-count)))

    ;; Physics step
    (when-not (paused?)
      (step! jolt-world (* dt (time-scale))))

    ;; Draw ImGui UI
    (draw-imgui-panel! jolt-world)
    (imgui-render!)

    ;; Render
    (begin-frame!)
    (draw-grid!)
    (draw-entities! jolt-world)
    (draw-title!)
    (imgui-draw!)
    (end-frame!)

    ;; Check for reset and recur with possibly new jolt-world
    (if (::reset-simulation @*per-frame-state)
      (let [new-jolt-world (reset-simulation! jolt-world)]
        (spawn-initial-balls! new-jolt-world flecs-world)
        (optimize! new-jolt-world)
        new-jolt-world)
      jolt-world)))

;; =============================================================================
;; Main function
;; =============================================================================

(defn -main [& args]
  #?(:jank (server/start-server {:port 5557}))

  (println "Starting integrated demo: Raylib + ImGui + Jolt + Flecs")
  (println "Using jank header requires + static linking!")
  (println "")

  ;; Initialize raylib
  (raylib-init!)

  ;; Initialize Flecs ECS via header require!
  (println "Initializing Flecs ECS...")
  (let [flecs-world (flecs-create-world)]

    ;; Initialize Jolt
    (println "Creating physics world...")
    (let [initial-jolt-world (create-world)]
      (create-floor initial-jolt-world)
      (spawn-initial-balls! initial-jolt-world flecs-world)
      (optimize! initial-jolt-world)

      ;; Initialize ImGui
      (imgui-init!)

      (println "Demo initialized! Press ESC to exit.")

      ;; Main loop with jolt-world as loop parameter (allows reset)
      (loop [jolt-world initial-jolt-world]
        (if (raylib-should-close?)
          ;; Cleanup and exit
          (do
            (imgui-shutdown!)
            (destroy-world! jolt-world)
            (flecs-destroy-world! flecs-world)
            (raylib-shutdown!)
            (println "Done!"))
          (recur (draw flecs-world jolt-world)))))))
