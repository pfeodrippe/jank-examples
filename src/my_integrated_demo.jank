(ns my-integrated-demo
  (:require
   ;; Raylib with global scope (C functions)
   ["raylib.h" :as rl :scope ""]
   ;; ImGui with ImGui:: scope
   ["imgui.h" :as imgui :scope "ImGui"]
   ;; Flecs C API with global scope
   ["flecs.h" :as fl :scope ""]
   [jank.nrepl-server.server :as server]))

;; Integrated demo: Raylib + ImGui + JoltPhysics + Flecs
;; Uses header requires for cleaner code

;; =============================================================================
;; C++ bridging layer (minimal - only what can't be done via header requires)
;; =============================================================================

(cpp/raw "
#include <cstdio>
#include <cstdint>
#include <cstring>
#include <raylib.h>
#include <rlgl.h>
#include <imgui.h>
#include <flecs.h>
#include <jank/runtime/obj/opaque_box.hpp>

// =============================================================================
// JIT stubs (required for JIT linking)
// =============================================================================

extern \"C\" {
    struct __emutls_control {
        size_t size; size_t align;
        union { size_t offset; void *ptr; } object;
        void *templ;
    };
    void* __emutls_get_address(__emutls_control* control) {
        if (!control->object.ptr) {
            control->object.ptr = malloc(control->size);
            if (control->templ) memcpy(control->object.ptr, control->templ, control->size);
            else memset(control->object.ptr, 0, control->size);
        }
        return control->object.ptr;
    }
}

namespace JPH {
    using AssertFailedFunction = bool(*)(const char*, const char*, const char*, unsigned int);
    AssertFailedFunction AssertFailed = [](const char* e, const char* m, const char* f, unsigned int l) -> bool {
        printf(\"[JOLT] %s:%u: %s\\n\", f, l, m ? m : e);
        return false;
    };
}

// =============================================================================
// Jolt C API (extern - implemented in jolt_wrapper.cpp)
// =============================================================================

extern \"C\" {
    void* jolt_world_create();
    void jolt_world_destroy(void* w);
    uint32_t jolt_body_create_sphere(void* w, float x, float y, float z, float r, bool dyn, bool act);
    uint32_t jolt_body_create_box(void* w, float x, float y, float z, float hx, float hy, float hz, bool dyn, bool act);
    void jolt_body_get_position(void* w, uint32_t id, float* x, float* y, float* z);
    void jolt_body_set_velocity(void* w, uint32_t id, float vx, float vy, float vz);
    void jolt_world_step(void* w, float dt, int steps);
    void jolt_world_optimize_broad_phase(void* w);
    int jolt_world_get_num_bodies(void* w);
    int jolt_world_get_num_active_bodies(void* w);
}

// =============================================================================
// Entity storage (ODR-safe vector + Flecs entity IDs)
// =============================================================================

struct Entity {
    uint64_t flecs_id;  // Flecs entity ID
    uint32_t jolt_id;   // Jolt body ID
    float radius;
    uint8_t r, g, b;
};

static std::vector<Entity>* g_entities_ptr = nullptr;

inline std::vector<Entity>& get_entities() {
    if (!g_entities_ptr) g_entities_ptr = new std::vector<Entity>();
    return *g_entities_ptr;
}

// =============================================================================
// Global state with heap-pointer pattern (ODR-safe)
// =============================================================================

static void* g_jolt_world = nullptr;
static bool* g_paused_ptr = nullptr;
static float* g_time_scale_ptr = nullptr;
static int* g_spawn_count_ptr = nullptr;
static float* g_view_scale_ptr = nullptr;
static float* g_view_offset_x_ptr = nullptr;
static float* g_view_offset_y_ptr = nullptr;
static unsigned int* g_font_tex_ptr = nullptr;
static bool* g_reset_requested_ptr = nullptr;

inline bool& get_paused() {
    if (!g_paused_ptr) g_paused_ptr = new bool(false);
    return *g_paused_ptr;
}

inline float& get_time_scale() {
    if (!g_time_scale_ptr) g_time_scale_ptr = new float(1.0f);
    return *g_time_scale_ptr;
}

inline int& get_spawn_count() {
    if (!g_spawn_count_ptr) g_spawn_count_ptr = new int(5);
    return *g_spawn_count_ptr;
}

inline float& get_view_scale() {
    if (!g_view_scale_ptr) g_view_scale_ptr = new float(15.0f);
    return *g_view_scale_ptr;
}

inline float& get_view_offset_x() {
    if (!g_view_offset_x_ptr) g_view_offset_x_ptr = new float(640.0f);
    return *g_view_offset_x_ptr;
}

inline float& get_view_offset_y() {
    if (!g_view_offset_y_ptr) g_view_offset_y_ptr = new float(500.0f);
    return *g_view_offset_y_ptr;
}

inline unsigned int& get_font_tex() {
    if (!g_font_tex_ptr) g_font_tex_ptr = new unsigned int(0);
    return *g_font_tex_ptr;
}

inline bool& get_reset_requested() {
    if (!g_reset_requested_ptr) g_reset_requested_ptr = new bool(false);
    return *g_reset_requested_ptr;
}

// =============================================================================
// Jolt wrapper functions
// =============================================================================

inline jank::runtime::object_ref jolt_create_world() {
    g_jolt_world = jolt_world_create();
    return jank::runtime::make_box<jank::runtime::obj::opaque_box>(g_jolt_world, \"JoltWorld\");
}

inline void jolt_destroy_world(jank::runtime::object_ref w) {
    auto o = jank::runtime::expect_object<jank::runtime::obj::opaque_box>(w);
    jolt_world_destroy(o->data.data);
    g_jolt_world = nullptr;
}

inline int64_t jolt_create_sphere(jank::runtime::object_ref w, double x, double y, double z, double r) {
    auto o = jank::runtime::expect_object<jank::runtime::obj::opaque_box>(w);
    return jolt_body_create_sphere(o->data.data, (float)x, (float)y, (float)z, (float)r, true, true);
}

inline int64_t jolt_create_floor(jank::runtime::object_ref w) {
    auto o = jank::runtime::expect_object<jank::runtime::obj::opaque_box>(w);
    return jolt_body_create_box(o->data.data, 0, -0.5f, 0, 50, 0.5f, 50, false, false);
}

inline void jolt_set_vel(jank::runtime::object_ref w, int64_t id, double vx, double vy, double vz) {
    auto o = jank::runtime::expect_object<jank::runtime::obj::opaque_box>(w);
    jolt_body_set_velocity(o->data.data, (uint32_t)id, (float)vx, (float)vy, (float)vz);
}

inline void jolt_step(jank::runtime::object_ref w, double dt) {
    auto o = jank::runtime::expect_object<jank::runtime::obj::opaque_box>(w);
    jolt_world_step(o->data.data, (float)dt, 1);
}

inline void jolt_optimize(jank::runtime::object_ref w) {
    auto o = jank::runtime::expect_object<jank::runtime::obj::opaque_box>(w);
    jolt_world_optimize_broad_phase(o->data.data);
}

inline int64_t jolt_num_bodies(jank::runtime::object_ref w) {
    auto o = jank::runtime::expect_object<jank::runtime::obj::opaque_box>(w);
    return jolt_world_get_num_bodies(o->data.data);
}

inline int64_t jolt_num_active(jank::runtime::object_ref w) {
    auto o = jank::runtime::expect_object<jank::runtime::obj::opaque_box>(w);
    return jolt_world_get_num_active_bodies(o->data.data);
}

// =============================================================================
// opaque_box helper - extracts void* from any opaque_box (minimal cpp/raw)
// =============================================================================

inline void* opaque_box_ptr(jank::runtime::object_ref box) {
    auto o = jank::runtime::expect_object<jank::runtime::obj::opaque_box>(box);
    return o->data.data;
}

// =============================================================================
// Flecs helpers - minimal wrappers for opaque_box handling
// Uses fl/ecs_mini for init (called from jank), wrappers for opaque_box ops
// =============================================================================

// Wrapper needed: ecs_fini needs raw pointer from opaque_box
inline void flecs_fini_world(jank::runtime::object_ref flecs_world_box) {
    auto o = jank::runtime::expect_object<jank::runtime::obj::opaque_box>(flecs_world_box);
    ecs_fini(static_cast<ecs_world_t*>(o->data.data));
}

inline void flecs_add_entity(jank::runtime::object_ref flecs_world_box, int64_t jolt_id, double radius, int64_t r, int64_t g, int64_t b) {
    // Extract world from opaque_box and create entity
    auto o = jank::runtime::expect_object<jank::runtime::obj::opaque_box>(flecs_world_box);
    ecs_world_t* world = static_cast<ecs_world_t*>(o->data.data);
    uint64_t flecs_id = ecs_new(world);

    // Store in vector for iteration (avoids JIT template issues with Flecs queries)
    Entity e;
    e.flecs_id = flecs_id;
    e.jolt_id = (uint32_t)jolt_id;
    e.radius = (float)radius;
    e.r = (uint8_t)r;
    e.g = (uint8_t)g;
    e.b = (uint8_t)b;
    get_entities().push_back(e);
}

inline int64_t flecs_entity_count() {
    return (int64_t)get_entities().size();
}

inline void flecs_clear_entities() {
    get_entities().clear();
}

// =============================================================================
// View state accessors (minimal - only what jank can't do directly)
// Note: These exist because jank can't mutate C++ references directly
// =============================================================================

inline bool native_get_paused() { return get_paused(); }
inline double native_get_time_scale() { return get_time_scale(); }
inline int64_t native_get_spawn_count() { return get_spawn_count(); }
inline double native_get_view_scale() { return get_view_scale(); }
inline double native_get_view_offset_x() { return get_view_offset_x(); }
inline double native_get_view_offset_y() { return get_view_offset_y(); }
inline void native_set_view_offset(double x, double y) {
    get_view_offset_x() = (float)x;
    get_view_offset_y() = (float)y;
}
inline void native_add_view_offset(double dx, double dy) {
    get_view_offset_x() += (float)dx;
    get_view_offset_y() += (float)dy;
}
inline void native_scale_view(double factor) {
    float s = get_view_scale() * (float)factor;
    get_view_scale() = fminf(50.0f, fmaxf(5.0f, s));
}

// =============================================================================
// ImGui renderer
// =============================================================================

inline void imgui_init() {
    ImGui::CreateContext();
    ImGuiIO& io = ImGui::GetIO();
    io.ConfigFlags |= ImGuiConfigFlags_NavEnableKeyboard;
    ImGui::StyleColorsDark();
    io.DisplaySize = ImVec2((float)GetScreenWidth(), (float)GetScreenHeight());
    unsigned char* pixels; int w, h;
    io.Fonts->GetTexDataAsRGBA32(&pixels, &w, &h);
    Image img = { pixels, w, h, 1, PIXELFORMAT_UNCOMPRESSED_R8G8B8A8 };
    get_font_tex() = LoadTextureFromImage(img).id;
    io.Fonts->SetTexID((ImTextureID)(intptr_t)get_font_tex());
}

inline void imgui_update_input() {
    ImGuiIO& io = ImGui::GetIO();
    io.DisplaySize = ImVec2((float)GetScreenWidth(), (float)GetScreenHeight());
    io.DeltaTime = GetFrameTime();
    Vector2 m = GetMousePosition();
    io.AddMousePosEvent(m.x, m.y);
    io.AddMouseButtonEvent(0, IsMouseButtonDown(MOUSE_LEFT_BUTTON));
    io.AddMouseButtonEvent(1, IsMouseButtonDown(MOUSE_RIGHT_BUTTON));
    Vector2 wh = GetMouseWheelMoveV();
    io.AddMouseWheelEvent(wh.x, wh.y);
    io.AddKeyEvent(ImGuiMod_Ctrl, IsKeyDown(KEY_LEFT_CONTROL) || IsKeyDown(KEY_RIGHT_CONTROL));
    io.AddKeyEvent(ImGuiMod_Shift, IsKeyDown(KEY_LEFT_SHIFT) || IsKeyDown(KEY_RIGHT_SHIFT));
    int c = GetCharPressed();
    while (c > 0) { io.AddInputCharacter(c); c = GetCharPressed(); }
}

inline bool imgui_wants_input() {
    return ImGui::GetIO().WantCaptureMouse || ImGui::GetIO().WantCaptureKeyboard;
}

inline void imgui_render_draw_data() {
    ImDrawData* dd = ImGui::GetDrawData();
    if (!dd || dd->CmdListsCount == 0) return;
    rlDrawRenderBatchActive();
    rlDisableBackfaceCulling();
    for (int n = 0; n < dd->CmdListsCount; n++) {
        const ImDrawList* cl = dd->CmdLists[n];
        const ImDrawVert* vb = cl->VtxBuffer.Data;
        const ImDrawIdx* ib = cl->IdxBuffer.Data;
        for (int i = 0; i < cl->CmdBuffer.Size; i++) {
            const ImDrawCmd* pc = &cl->CmdBuffer[i];
            if (pc->UserCallback) { pc->UserCallback(cl, pc); continue; }
            ImVec2 p = dd->DisplayPos;
            ImVec4 cr = pc->ClipRect;
            BeginScissorMode((int)(cr.x-p.x), (int)(cr.y-p.y), (int)(cr.z-cr.x), (int)(cr.w-cr.y));
            rlSetTexture((unsigned int)(intptr_t)pc->GetTexID());
            rlBegin(RL_TRIANGLES);
            for (unsigned int j = 0; j < pc->ElemCount; j += 3) {
                for (int k = 0; k < 3; k++) {
                    const ImDrawVert* v = &vb[ib[pc->IdxOffset + j + k]];
                    rlColor4ub((v->col>>0)&0xFF,(v->col>>8)&0xFF,(v->col>>16)&0xFF,(v->col>>24)&0xFF);
                    rlTexCoord2f(v->uv.x, v->uv.y);
                    rlVertex2f(v->pos.x, v->pos.y);
                }
            }
            rlEnd();
            rlSetTexture(0);
            EndScissorMode();
        }
    }
    rlEnableBackfaceCulling();
}

inline void imgui_shutdown() {
    if (get_font_tex()) { rlUnloadTexture(get_font_tex()); get_font_tex() = 0; }
    ImGui::DestroyContext();
}

// =============================================================================
// Rendering functions (only complex ones that need C++ loops)
// =============================================================================

inline Vector2 physics_to_screen(float px, float pz) {
    return {
        get_view_offset_x() + px * get_view_scale(),
        get_view_offset_y() - pz * get_view_scale()
    };
}

// Grid needs C++ loop for performance
inline void draw_grid() {
    Color grid_color = Fade(LIGHTGRAY, 0.3f);
    for (int i = -50; i <= 50; i += 5) {
        Vector2 p1 = physics_to_screen((float)i, -50.0f);
        Vector2 p2 = physics_to_screen((float)i, 50.0f);
        DrawLineV(p1, p2, grid_color);
        p1 = physics_to_screen(-50.0f, (float)i);
        p2 = physics_to_screen(50.0f, (float)i);
        DrawLineV(p1, p2, grid_color);
    }
}

inline void draw_entities(void* jolt_world) {
    if (!jolt_world) return;

    // Iterate over our vector (avoids JIT template issues with Flecs each<>)
    for (const Entity& e : get_entities()) {
        float px, py, pz;
        jolt_body_get_position(jolt_world, e.jolt_id, &px, &py, &pz);
        Vector2 screen = physics_to_screen(px, pz);
        float sr = e.radius * get_view_scale();
        float h_factor = fminf(1.0f, fmaxf(0.0f, (py + 5.0f) / 50.0f));
        float brightness = 0.5f + 0.5f * h_factor;
        Color col = {
            (unsigned char)(e.r * brightness),
            (unsigned char)(e.g * brightness),
            (unsigned char)(e.b * brightness),
            255
        };
        // Shadow
        DrawCircle((int)(screen.x + py * 0.5f), (int)(screen.y + py * 0.5f),
                   sr * 0.8f, Fade(BLACK, 0.2f));
        // Ball
        DrawCircle((int)screen.x, (int)screen.y, sr, col);
        DrawCircleLines((int)screen.x, (int)screen.y, sr, BLACK);
        // Height label
        char buf[16];
        snprintf(buf, sizeof(buf), \"%d\", (int)py);
        DrawText(buf, (int)screen.x - 10, (int)screen.y - 5, 10, BLACK);
    }
}

// =============================================================================
// ImGui helpers - only for mutable references and formatted text
// =============================================================================

// Mutable reference widgets (can't do from jank directly)
inline bool imgui_checkbox_paused() {
    return ImGui::Checkbox(\"Paused\", &get_paused());
}
inline bool imgui_slider_time_scale() {
    return ImGui::SliderFloat(\"Time Scale\", &get_time_scale(), 0.1f, 3.0f);
}
inline bool imgui_slider_spawn_count() {
    return ImGui::SliderInt(\"Spawn Count\", &get_spawn_count(), 1, 20);
}

// Assignments (can't mutate C++ globals from jank directly)
inline void imgui_set_reset_requested() {
    get_reset_requested() = true;
}
inline void imgui_reset_view() {
    get_view_offset_x() = 640.0f;
    get_view_offset_y() = 500.0f;
    get_view_scale() = 15.0f;
}

// Formatted text helpers (variadic functions are tricky from jank)
inline void imgui_text_fps() {
    ImGui::Text(\"FPS: %d\", GetFPS());
}
inline void imgui_text_jolt_stats(void* w) {
    ImGui::Text(\"Jolt Bodies: %d\", w ? jolt_world_get_num_bodies(w) : 0);
    ImGui::Text(\"Active: %d\", w ? jolt_world_get_num_active_bodies(w) : 0);
}
inline void imgui_text_flecs_stats() {
    ImGui::Text(\"Flecs Entities: %d\", (int)flecs_entity_count());
}
inline void imgui_text_view_stats() {
    ImGui::Text(\"View: (%.0f, %.0f) scale: %.1f\", get_view_offset_x(), get_view_offset_y(), get_view_scale());
}

// Simple text helpers (variadic Text/BulletText can't be called from jank)
inline void imgui_text_controls() {
    ImGui::Text(\"Controls:\");
}
inline void imgui_bullet_pan() {
    ImGui::BulletText(\"Drag to pan\");
}
inline void imgui_bullet_zoom() {
    ImGui::BulletText(\"Scroll to zoom\");
}
inline void imgui_bullet_spawn() {
    ImGui::BulletText(\"Space to spawn\");
}

// Additional helpers to avoid jank->imgui header issues
inline void imgui_begin_physics_debug() {
    ImGui::Begin(\"Physics Debug\");
}
inline void imgui_separator() {
    ImGui::Separator();
}
inline void imgui_same_line() {
    ImGui::SameLine();
}
inline bool imgui_button_reset_sim() {
    return ImGui::Button(\"Reset Simulation\");
}
inline bool imgui_button_reset_view() {
    return ImGui::Button(\"Reset View\");
}
inline jank::runtime::object_ref imgui_end() {
    ImGui::End();
    return jank::runtime::jank_nil;
}

inline bool native_check_reset() {
    bool val = get_reset_requested();
    get_reset_requested() = false;
    return val;
}

inline jank::runtime::object_ref native_reset_simulation(jank::runtime::object_ref old_world) {
    auto o = jank::runtime::expect_object<jank::runtime::obj::opaque_box>(old_world);
    if (o->data.data) {
        jolt_world_destroy(o->data.data);
    }
    flecs_clear_entities();
    void* new_world = jolt_world_create();
    g_jolt_world = new_world;
    jolt_body_create_box(new_world, 0, -0.5f, 0, 50, 0.5f, 50, false, false);
    return jank::runtime::make_box<jank::runtime::obj::opaque_box>(new_world, \"JoltWorld\");
}

inline void native_draw_entities(jank::runtime::object_ref world_box) {
    auto o = jank::runtime::expect_object<jank::runtime::obj::opaque_box>(world_box);
    draw_entities(o->data.data);
}
")

;; ImGui::Text(\"FPS: %d\", GetFPS());
#_ (require '[jank.compiler :as jc])
#_ (jc/native-source (imgui/Text "FPS: %d" (rl/GetFPS)))

(defn native-draw-imgui-panel
  "Draw ImGui debug panel - jank controls the flow, cpp helpers for ImGui calls"
  [w]
  (let* [world-ptr (cpp/opaque_box_ptr w)]
    ;; Begin panel
    (cpp/imgui_begin_physics_debug)

    ;; Stats section
    (cpp/imgui_text_fps)
    (cpp/imgui_separator)
    (cpp/imgui_text_jolt_stats world-ptr)
    (cpp/imgui_text_flecs_stats)
    (cpp/imgui_separator)

    ;; Controls (mutable refs need cpp helpers)
    (cpp/imgui_checkbox_paused)
    (cpp/imgui_slider_time_scale)
    (cpp/imgui_slider_spawn_count)
    (cpp/imgui_separator)

    ;; Buttons - jank controls the logic!
    (when (cpp/imgui_button_reset_sim)
      (cpp/imgui_set_reset_requested))
    (cpp/imgui_same_line)
    (when (cpp/imgui_button_reset_view)
      (cpp/imgui_reset_view))

    ;; View info
    (cpp/imgui_text_view_stats)
    (cpp/imgui_separator)

    ;; Help text
    (cpp/imgui_text_controls)
    (cpp/imgui_bullet_pan)
    (cpp/imgui_bullet_zoom)
    (cpp/imgui_bullet_spawn)

    ;; End panel
    (cpp/imgui_end)))

;; =============================================================================
;; Jolt wrapper functions
;; =============================================================================

(defn create-world [] (cpp/jolt_create_world))
(defn destroy-world! [w] (cpp/jolt_destroy_world w))
(defn create-sphere [w x y z r] (cpp/jolt_create_sphere w x y z r))
(defn create-floor [w] (cpp/jolt_create_floor w))
(defn set-velocity! [w id vx vy vz] (cpp/jolt_set_vel w id vx vy vz))
(defn step! [w dt] (cpp/jolt_step w dt))
(defn optimize! [w] (cpp/jolt_optimize w))
(defn num-bodies [w] (cpp/jolt_num_bodies w))
(defn num-active [w] (cpp/jolt_num_active w))

;; =============================================================================
;; Flecs - using header require directly!
;; =============================================================================

(defn flecs-create-world []
  "Create a Flecs world via C API and wrap in opaque_box."
  (println "[flecs] ECS world created via fl/ecs_mini")
  (cpp/box (fl/ecs_mini)))

(defn flecs-destroy-world! [flecs-world]
  "Destroy a Flecs world."
  (cpp/flecs_fini_world flecs-world))

(defn add-entity! [flecs-world jolt-id r cr cg cb]
  "Add entity to Flecs world and entity storage."
  (cpp/flecs_add_entity flecs-world jolt-id r cr cg cb))

(defn entity-count [] (cpp/flecs_entity_count))
(defn clear-entities! [] (cpp/flecs_clear_entities))

;; =============================================================================
;; State accessors (read-only from jank - ImGui panel handles mutation)
;; =============================================================================

(defn paused? [] (cpp/native_get_paused))
(defn time-scale [] (cpp/native_get_time_scale))
(defn spawn-count [] (cpp/native_get_spawn_count))
(defn view-scale [] (cpp/native_get_view_scale))
(defn view-offset-x [] (cpp/native_get_view_offset_x))
(defn view-offset-y [] (cpp/native_get_view_offset_y))

;; =============================================================================
;; Raylib - using header requires directly!
;; =============================================================================

(defn raylib-init! []
  ;; Direct raylib calls via header require - no cpp wrapper needed!
  ;; Enum values accessible directly: rl/FLAG_WINDOW_RESIZABLE, rl/KEY_SPACE, etc.
  (rl/SetConfigFlags (bit-or rl/FLAG_WINDOW_RESIZABLE rl/FLAG_MSAA_4X_HINT))
  (rl/InitWindow 1280 720 "jank: Raylib + ImGui + Jolt + Flecs")
  (rl/SetTargetFPS 60))

(defn raylib-shutdown! [] (rl/CloseWindow))
(defn raylib-should-close? [] (rl/WindowShouldClose))
(defn get-dt [] (rl/GetFrameTime))
(defn get-fps [] (rl/GetFPS))

(defn begin-frame! []
  (rl/BeginDrawing)
  (rl/ClearBackground (rl/RAYWHITE)))

(defn end-frame! [] (rl/EndDrawing))

(defn draw-title! []
  (rl/DrawText "Raylib + ImGui + Jolt + Flecs" 10 10 20 (rl/DARKGRAY))
  (rl/DrawText "Top-Down 2D View (numbers show Y height)" 10 35 16 (rl/GRAY)))

;; =============================================================================
;; Input handling - pure jank with cpp/ prefix!
;; Uses let* with _ binding for void returns
;; =============================================================================

(defn handle-input!
  "Handle pan/zoom input. Returns true if space was pressed (spawn request)."
  []
  (if (cpp/imgui_wants_input)
    false
    (let* [mouse-down (rl/IsMouseButtonDown rl/MOUSE_BUTTON_LEFT)]
      (when mouse-down
        (let* [delta (rl/GetMouseDelta)
               dx (cpp/.-x delta)
               dy (cpp/.-y delta)
               _ (cpp/native_add_view_offset dx dy)]
          nil))
      (let* [wheel (rl/GetMouseWheelMove)]
        (when (not= wheel 0.0)
          (let* [_ (cpp/native_scale_view (if (> wheel 0) 1.1 0.9))]
            nil)))
      (rl/IsKeyPressed rl/KEY_SPACE))))

;; =============================================================================
;; ImGui - complex rendering stays in cpp, simple calls use header requires
;; =============================================================================

(defn imgui-init! [] (cpp/imgui_init))
(defn imgui-update! [] (cpp/imgui_update_input))
(defn imgui-new-frame! [] (imgui/NewFrame))  ;; Direct header require!
(defn imgui-render! [] (imgui/Render))       ;; Direct header require!
(defn imgui-draw! [] (cpp/imgui_render_draw_data))
(defn imgui-shutdown! [] (cpp/imgui_shutdown))

;; =============================================================================
;; Drawing - complex loops stay in cpp
;; =============================================================================

(defn draw-grid! [] (cpp/draw_grid))
(defn draw-entities! [world] (cpp/native_draw_entities world))
(defn draw-imgui-panel! [world] (native-draw-imgui-panel world))
(defn reset-requested? [] (cpp/native_check_reset))
(defn reset-simulation! [world] (cpp/native_reset_simulation world))

;; =============================================================================
;; Game logic (in jank)
;; =============================================================================

(defn rand-range [min max]
  (+ min (* (rand) (- max min))))

(defn spawn-ball! [jolt-world flecs-world]
  (let [x (rand-range -20 20)
        y (rand-range 15 40)
        z (rand-range -20 20)
        r (rand-range 0.5 1.5)
        cr (int (rand-range 50 255))
        cg (int (rand-range 50 255))
        cb (int (rand-range 50 255))
        id (create-sphere jolt-world x y z r)
        vx (rand-range -10 10)
        vz (rand-range -10 10)]
    (set-velocity! jolt-world id vx 0.0 vz)
    (add-entity! flecs-world id r cr cg cb)))

(defn spawn-balls! [jolt-world flecs-world n]
  (dotimes [_ n]
    (spawn-ball! jolt-world flecs-world)))

(defn spawn-initial-balls! [jolt-world flecs-world]
  (dotimes [_ 200]
    (spawn-ball! jolt-world flecs-world)))

(defn draw
  [flecs-world jolt-world]
  ;; Continue running
  (let [dt (get-dt)]

    ;; Update ImGui
    (imgui-update!)
    (imgui-new-frame!)

    ;; Handle input
    (when (handle-input!)
      (spawn-balls! jolt-world flecs-world (spawn-count)))

    ;; Physics step
    (when-not (paused?)
      (step! jolt-world (* dt (time-scale))))

    ;; Draw ImGui UI
    (draw-imgui-panel! jolt-world)
    (imgui-render!)

    ;; Render
    (begin-frame!)
    (draw-grid!)
    (draw-entities! jolt-world)
    (draw-title!)
    (imgui-draw!)
    (end-frame!)

    ;; Check for reset and recur with possibly new jolt-world
    (if (reset-requested?)
      (let [new-jolt-world (reset-simulation! jolt-world)]
        (spawn-initial-balls! new-jolt-world flecs-world)
        (optimize! new-jolt-world)
        new-jolt-world)
      jolt-world)))

;; =============================================================================
;; Main function
;; =============================================================================

(defn -main [& args]
  #?(:jank (server/start-server {:port 5557}))

  (println "Starting integrated demo: Raylib + ImGui + Jolt + Flecs")
  (println "Using jank header requires + static linking!")
  (println "")

  ;; Initialize raylib
  (raylib-init!)

  ;; Initialize Flecs ECS via header require!
  (println "Initializing Flecs ECS...")
  (let [flecs-world (flecs-create-world)]

    ;; Initialize Jolt
    (println "Creating physics world...")
    (let [initial-jolt-world (create-world)]
      (create-floor initial-jolt-world)
      (spawn-initial-balls! initial-jolt-world flecs-world)
      (optimize! initial-jolt-world)

      ;; Initialize ImGui
      (imgui-init!)

      (println "Demo initialized! Press ESC to exit.")

      ;; Main loop with jolt-world as loop parameter (allows reset)
      (loop [jolt-world initial-jolt-world]
        (if (raylib-should-close?)
          ;; Cleanup and exit
          (do
            (imgui-shutdown!)
            (destroy-world! jolt-world)
            (flecs-destroy-world! flecs-world)
            (raylib-shutdown!)
            (println "Done!"))
          (recur (draw flecs-world jolt-world)))))))
