(ns my-integrated-demo)

;; Integrated demo: Raylib + ImGui + JoltPhysics
;; Pattern: cpp/raw for C++ bridging, jank for logic and state

;; =============================================================================
;; C++ bridging layer
;; =============================================================================

(cpp/raw "
#include <cstdio>
#include <cstdint>
#include <cstring>
#include <vector>
#include <raylib.h>
#include <rlgl.h>
#include <imgui.h>
#include <jank/runtime/obj/opaque_box.hpp>
#include <jank/runtime/obj/persistent_vector.hpp>

// TLS stub for JIT
extern \"C\" {
    struct __emutls_control {
        size_t size; size_t align;
        union { size_t offset; void *ptr; } object;
        void *templ;
    };
    void* __emutls_get_address(__emutls_control* control) {
        if (!control->object.ptr) {
            control->object.ptr = malloc(control->size);
            if (control->templ) memcpy(control->object.ptr, control->templ, control->size);
            else memset(control->object.ptr, 0, control->size);
        }
        return control->object.ptr;
    }
}

// Jolt AssertFailed stub
namespace JPH {
    using AssertFailedFunction = bool(*)(const char*, const char*, const char*, unsigned int);
    AssertFailedFunction AssertFailed = [](const char* e, const char* m, const char* f, unsigned int l) -> bool {
        printf(\"[JOLT] %s:%u: %s\\n\", f, l, m ? m : e);
        return false;
    };
}

// Jolt wrapper extern declarations
extern \"C\" {
    void* jolt_world_create();
    void jolt_world_destroy(void* w);
    uint32_t jolt_body_create_sphere(void* w, float x, float y, float z, float r, bool dyn, bool act);
    uint32_t jolt_body_create_box(void* w, float x, float y, float z, float hx, float hy, float hz, bool dyn, bool act);
    void jolt_body_get_position(void* w, uint32_t id, float* x, float* y, float* z);
    void jolt_body_set_velocity(void* w, uint32_t id, float vx, float vy, float vz);
    void jolt_world_step(void* w, float dt, int steps);
    void jolt_world_optimize_broad_phase(void* w);
    int jolt_world_get_num_bodies(void* w);
    int jolt_world_get_num_active_bodies(void* w);
}

// =============================================================================
// Global state (managed from jank)
// =============================================================================

struct Entity {
    uint32_t id;
    float radius;
    uint8_t r, g, b;
};

static void* g_world = nullptr;
static std::vector<Entity>* g_entities_ptr = nullptr;
static bool* g_paused_ptr = nullptr;
static float* g_time_scale_ptr = nullptr;
static int* g_spawn_count_ptr = nullptr;
static float* g_view_scale_ptr = nullptr;
static float* g_view_offset_x_ptr = nullptr;
static float* g_view_offset_y_ptr = nullptr;
static unsigned int* g_font_tex_ptr = nullptr;

inline bool& get_paused() {
    if (!g_paused_ptr) g_paused_ptr = new bool(false);
    return *g_paused_ptr;
}

inline std::vector<Entity>& get_entities() {
    if (!g_entities_ptr) g_entities_ptr = new std::vector<Entity>();
    return *g_entities_ptr;
}

inline float& get_time_scale() {
    if (!g_time_scale_ptr) g_time_scale_ptr = new float(1.0f);
    return *g_time_scale_ptr;
}

inline int& get_spawn_count() {
    if (!g_spawn_count_ptr) g_spawn_count_ptr = new int(5);
    return *g_spawn_count_ptr;
}

inline float& get_view_scale() {
    if (!g_view_scale_ptr) g_view_scale_ptr = new float(15.0f);
    return *g_view_scale_ptr;
}

inline float& get_view_offset_x() {
    if (!g_view_offset_x_ptr) g_view_offset_x_ptr = new float(640.0f);
    return *g_view_offset_x_ptr;
}

inline float& get_view_offset_y() {
    if (!g_view_offset_y_ptr) g_view_offset_y_ptr = new float(500.0f);
    return *g_view_offset_y_ptr;
}

inline unsigned int& get_font_tex() {
    if (!g_font_tex_ptr) g_font_tex_ptr = new unsigned int(0);
    return *g_font_tex_ptr;
}

// =============================================================================
// Jolt wrapper functions
// =============================================================================

inline jank::runtime::object_ref jolt_create_world() {
    g_world = jolt_world_create();
    return jank::runtime::make_box<jank::runtime::obj::opaque_box>(g_world, \"JoltWorld\");
}

inline void jolt_destroy_world(jank::runtime::object_ref w) {
    auto o = jank::runtime::expect_object<jank::runtime::obj::opaque_box>(w);
    jolt_world_destroy(o->data.data);
    g_world = nullptr;
}

inline int64_t jolt_create_sphere(jank::runtime::object_ref w, double x, double y, double z, double r) {
    auto o = jank::runtime::expect_object<jank::runtime::obj::opaque_box>(w);
    return jolt_body_create_sphere(o->data.data, (float)x, (float)y, (float)z, (float)r, true, true);
}

inline int64_t jolt_create_floor(jank::runtime::object_ref w) {
    auto o = jank::runtime::expect_object<jank::runtime::obj::opaque_box>(w);
    return jolt_body_create_box(o->data.data, 0, -0.5f, 0, 50, 0.5f, 50, false, false);
}

inline jank::runtime::object_ref jolt_get_pos(jank::runtime::object_ref w, int64_t id) {
    auto o = jank::runtime::expect_object<jank::runtime::obj::opaque_box>(w);
    float x, y, z;
    jolt_body_get_position(o->data.data, (uint32_t)id, &x, &y, &z);
    return jank::runtime::make_box<jank::runtime::obj::persistent_vector>(
        std::in_place,
        jank::runtime::make_box((double)x),
        jank::runtime::make_box((double)y),
        jank::runtime::make_box((double)z));
}

inline void jolt_set_vel(jank::runtime::object_ref w, int64_t id, double vx, double vy, double vz) {
    auto o = jank::runtime::expect_object<jank::runtime::obj::opaque_box>(w);
    jolt_body_set_velocity(o->data.data, (uint32_t)id, (float)vx, (float)vy, (float)vz);
}

static int g_step_count = 0;
inline void jolt_step(jank::runtime::object_ref w, double dt) {
    auto o = jank::runtime::expect_object<jank::runtime::obj::opaque_box>(w);
    jolt_world_step(o->data.data, (float)dt, 1);
    if (++g_step_count % 60 == 0) {
        printf(\"jolt_step: dt=%.4f, steps=%d\\n\", dt, g_step_count);
    }
}

inline void jolt_optimize(jank::runtime::object_ref w) {
    auto o = jank::runtime::expect_object<jank::runtime::obj::opaque_box>(w);
    jolt_world_optimize_broad_phase(o->data.data);
}

inline int64_t jolt_num_bodies(jank::runtime::object_ref w) {
    auto o = jank::runtime::expect_object<jank::runtime::obj::opaque_box>(w);
    return jolt_world_get_num_bodies(o->data.data);
}

inline int64_t jolt_num_active(jank::runtime::object_ref w) {
    auto o = jank::runtime::expect_object<jank::runtime::obj::opaque_box>(w);
    return jolt_world_get_num_active_bodies(o->data.data);
}

// =============================================================================
// Entity management
// =============================================================================

inline void native_add_entity(int64_t id, double r, int64_t cr, int64_t cg, int64_t cb) {
    get_entities().push_back({(uint32_t)id, (float)r, (uint8_t)cr, (uint8_t)cg, (uint8_t)cb});
}

inline int64_t native_entity_count() { return (int64_t)get_entities().size(); }
inline void native_clear_entities() { get_entities().clear(); }

// =============================================================================
// View state accessors
// =============================================================================

inline void native_set_paused(bool v) { get_paused() = v; }
inline bool native_get_paused() { return get_paused(); }
inline void native_set_time_scale(double v) { get_time_scale() = (float)v; }
inline double native_get_time_scale() { return get_time_scale(); }
inline void native_set_spawn_count(int64_t v) { get_spawn_count() = (int)v; }
inline int64_t native_get_spawn_count() { return get_spawn_count(); }
inline void native_set_view_scale(double v) { get_view_scale() = (float)v; }
inline double native_get_view_scale() { return get_view_scale(); }
inline void native_set_view_offset(double x, double y) { get_view_offset_x() = (float)x; get_view_offset_y() = (float)y; }
inline double native_get_view_offset_x() { return get_view_offset_x(); }
inline double native_get_view_offset_y() { return get_view_offset_y(); }

// =============================================================================
// ImGui renderer
// =============================================================================

inline void imgui_init() {
    ImGui::CreateContext();
    ImGuiIO& io = ImGui::GetIO();
    io.ConfigFlags |= ImGuiConfigFlags_NavEnableKeyboard;
    ImGui::StyleColorsDark();
    io.DisplaySize = ImVec2((float)GetScreenWidth(), (float)GetScreenHeight());
    unsigned char* pixels; int w, h;
    io.Fonts->GetTexDataAsRGBA32(&pixels, &w, &h);
    Image img = { pixels, w, h, 1, PIXELFORMAT_UNCOMPRESSED_R8G8B8A8 };
    get_font_tex() = LoadTextureFromImage(img).id;
    io.Fonts->SetTexID((ImTextureID)(intptr_t)get_font_tex());
}

inline void imgui_update_input() {
    ImGuiIO& io = ImGui::GetIO();
    io.DisplaySize = ImVec2((float)GetScreenWidth(), (float)GetScreenHeight());
    io.DeltaTime = GetFrameTime();
    Vector2 m = GetMousePosition();
    io.AddMousePosEvent(m.x, m.y);
    io.AddMouseButtonEvent(0, IsMouseButtonDown(MOUSE_LEFT_BUTTON));
    io.AddMouseButtonEvent(1, IsMouseButtonDown(MOUSE_RIGHT_BUTTON));
    Vector2 wh = GetMouseWheelMoveV();
    io.AddMouseWheelEvent(wh.x, wh.y);
    io.AddKeyEvent(ImGuiMod_Ctrl, IsKeyDown(KEY_LEFT_CONTROL) || IsKeyDown(KEY_RIGHT_CONTROL));
    io.AddKeyEvent(ImGuiMod_Shift, IsKeyDown(KEY_LEFT_SHIFT) || IsKeyDown(KEY_RIGHT_SHIFT));
    int c = GetCharPressed();
    while (c > 0) { io.AddInputCharacter(c); c = GetCharPressed(); }
}

inline bool imgui_wants_input() {
    return ImGui::GetIO().WantCaptureMouse || ImGui::GetIO().WantCaptureKeyboard;
}

inline void imgui_render_draw_data() {
    ImDrawData* dd = ImGui::GetDrawData();
    if (!dd || dd->CmdListsCount == 0) return;
    rlDrawRenderBatchActive();
    rlDisableBackfaceCulling();
    for (int n = 0; n < dd->CmdListsCount; n++) {
        const ImDrawList* cl = dd->CmdLists[n];
        const ImDrawVert* vb = cl->VtxBuffer.Data;
        const ImDrawIdx* ib = cl->IdxBuffer.Data;
        for (int i = 0; i < cl->CmdBuffer.Size; i++) {
            const ImDrawCmd* pc = &cl->CmdBuffer[i];
            if (pc->UserCallback) { pc->UserCallback(cl, pc); continue; }
            ImVec2 p = dd->DisplayPos;
            ImVec4 cr = pc->ClipRect;
            BeginScissorMode((int)(cr.x-p.x), (int)(cr.y-p.y), (int)(cr.z-cr.x), (int)(cr.w-cr.y));
            rlSetTexture((unsigned int)(intptr_t)pc->GetTexID());
            rlBegin(RL_TRIANGLES);
            for (unsigned int j = 0; j < pc->ElemCount; j += 3) {
                for (int k = 0; k < 3; k++) {
                    const ImDrawVert* v = &vb[ib[pc->IdxOffset + j + k]];
                    rlColor4ub((v->col>>0)&0xFF,(v->col>>8)&0xFF,(v->col>>16)&0xFF,(v->col>>24)&0xFF);
                    rlTexCoord2f(v->uv.x, v->uv.y);
                    rlVertex2f(v->pos.x, v->pos.y);
                }
            }
            rlEnd();
            rlSetTexture(0);
            EndScissorMode();
        }
    }
    rlEnableBackfaceCulling();
}

inline void imgui_shutdown() {
    if (get_font_tex()) { rlUnloadTexture(get_font_tex()); get_font_tex() = 0; }
    ImGui::DestroyContext();
}

inline void native_imgui_new_frame() { ImGui::NewFrame(); }
inline void native_imgui_render() { ImGui::Render(); }

// =============================================================================
// Rendering functions (called from jank)
// =============================================================================

inline void raylib_init() {
    SetConfigFlags(FLAG_WINDOW_RESIZABLE | FLAG_MSAA_4X_HINT);
    InitWindow(1280, 720, \"jank: Raylib + ImGui + JoltPhysics\");
    SetTargetFPS(60);
}

inline void raylib_shutdown() {
    CloseWindow();
}

inline bool raylib_should_close() {
    return WindowShouldClose();
}

inline double raylib_get_dt() {
    return GetFrameTime();
}

inline void begin_frame() {
    BeginDrawing();
    ClearBackground(RAYWHITE);
}

inline void end_frame() {
    EndDrawing();
}

inline Vector2 physics_to_screen(float px, float pz) {
    return {
        get_view_offset_x() + px * get_view_scale(),
        get_view_offset_y() - pz * get_view_scale()
    };
}

inline void draw_grid() {
    Color grid_color = Fade(LIGHTGRAY, 0.3f);
    for (int i = -50; i <= 50; i += 5) {
        Vector2 p1 = physics_to_screen((float)i, -50.0f);
        Vector2 p2 = physics_to_screen((float)i, 50.0f);
        DrawLineV(p1, p2, grid_color);
        p1 = physics_to_screen(-50.0f, (float)i);
        p2 = physics_to_screen(50.0f, (float)i);
        DrawLineV(p1, p2, grid_color);
    }
}

inline void draw_entities(void* world) {
    if (!world) return;
    auto& entities = get_entities();
    if (entities.empty()) return;
    for (const auto& e : entities) {
        float px, py, pz;
        jolt_body_get_position(world, e.id, &px, &py, &pz);
        Vector2 screen = physics_to_screen(px, pz);
        float sr = e.radius * get_view_scale();
        float h_factor = fminf(1.0f, fmaxf(0.0f, (py + 5.0f) / 50.0f));
        float brightness = 0.5f + 0.5f * h_factor;
        Color col = {
            (unsigned char)(e.r * brightness),
            (unsigned char)(e.g * brightness),
            (unsigned char)(e.b * brightness),
            255
        };
        // Shadow
        DrawCircle((int)(screen.x + py * 0.5f), (int)(screen.y + py * 0.5f),
                   sr * 0.8f, Fade(BLACK, 0.2f));
        // Ball
        DrawCircle((int)screen.x, (int)screen.y, sr, col);
        DrawCircleLines((int)screen.x, (int)screen.y, sr, BLACK);
        // Height label
        char buf[16];
        snprintf(buf, sizeof(buf), \"%d\", (int)py);
        DrawText(buf, (int)screen.x - 10, (int)screen.y - 5, 10, BLACK);
    }
}

inline void draw_title() {
    DrawText(\"Raylib + ImGui + JoltPhysics\", 10, 10, 20, DARKGRAY);
    DrawText(\"Top-Down 2D View (numbers show Y height)\", 10, 35, 16, GRAY);
}

inline bool handle_input_for_view() {
    if (imgui_wants_input()) return false;
    // Pan with mouse drag
    if (IsMouseButtonDown(MOUSE_LEFT_BUTTON)) {
        Vector2 delta = GetMouseDelta();
        get_view_offset_x() += delta.x;
        get_view_offset_y() += delta.y;
    }
    // Zoom with scroll
    float wheel = GetMouseWheelMove();
    if (wheel != 0.0f) {
        float factor = (wheel > 0) ? 1.1f : 0.9f;
        get_view_scale() = fminf(50.0f, fmaxf(5.0f, get_view_scale() * factor));
    }
    // Space to spawn
    return IsKeyPressed(KEY_SPACE);
}

static bool* g_reset_requested_ptr = nullptr;
inline bool& get_reset_requested() {
    if (!g_reset_requested_ptr) g_reset_requested_ptr = new bool(false);
    return *g_reset_requested_ptr;
}

inline void draw_imgui_panel(void* world) {
    ImGui::Begin(\"Physics Debug\");
    ImGui::Text(\"FPS: %d\", GetFPS());
    ImGui::Separator();
    ImGui::Text(\"Jolt Bodies: %d\", world ? jolt_world_get_num_bodies(world) : 0);
    ImGui::Text(\"Active: %d\", world ? jolt_world_get_num_active_bodies(world) : 0);
    ImGui::Text(\"Entities: %d\", (int)get_entities().size());
    ImGui::Separator();
    ImGui::Checkbox(\"Paused\", &get_paused());
    ImGui::SliderFloat(\"Time Scale\", &get_time_scale(), 0.1f, 3.0f);
    ImGui::SliderInt(\"Spawn Count\", &get_spawn_count(), 1, 20);
    ImGui::Separator();
    if (ImGui::Button(\"Reset Simulation\")) {
        get_reset_requested() = true;
    }
    ImGui::SameLine();
    if (ImGui::Button(\"Reset View\")) {
        get_view_offset_x() = 640.0f;
        get_view_offset_y() = 500.0f;
        get_view_scale() = 15.0f;
    }
    ImGui::Text(\"View: (%.0f, %.0f) scale: %.1f\", get_view_offset_x(), get_view_offset_y(), get_view_scale());
    ImGui::Separator();
    ImGui::Text(\"Controls:\");
    ImGui::BulletText(\"Drag to pan\");
    ImGui::BulletText(\"Scroll to zoom\");
    ImGui::BulletText(\"Space to spawn\");
    ImGui::End();
}

inline bool native_check_reset() {
    bool val = get_reset_requested();
    get_reset_requested() = false;
    return val;
}

// Reset simulation - destroy world, create new one, clear entities
static void** g_world_ptr = nullptr;
inline void*& get_world_ref() {
    if (!g_world_ptr) g_world_ptr = new void*(nullptr);
    return *g_world_ptr;
}

inline jank::runtime::object_ref native_reset_simulation(jank::runtime::object_ref old_world) {
    // Destroy old world
    auto o = jank::runtime::expect_object<jank::runtime::obj::opaque_box>(old_world);
    if (o->data.data) {
        jolt_world_destroy(o->data.data);
    }

    // Clear entities
    get_entities().clear();

    // Create new world
    void* new_world = jolt_world_create();
    get_world_ref() = new_world;

    // Create floor
    jolt_body_create_box(new_world, 0, -0.5f, 0, 50, 0.5f, 50, false, false);

    return jank::runtime::make_box<jank::runtime::obj::opaque_box>(new_world, \"JoltWorld\");
}

// =============================================================================
// Wrapper functions that take world as jank object
// =============================================================================

inline void native_draw_entities(jank::runtime::object_ref world_box) {
    auto o = jank::runtime::expect_object<jank::runtime::obj::opaque_box>(world_box);
    draw_entities(o->data.data);
}

inline void native_draw_imgui_panel(jank::runtime::object_ref world_box) {
    auto o = jank::runtime::expect_object<jank::runtime::obj::opaque_box>(world_box);
    draw_imgui_panel(o->data.data);
}
")

;; =============================================================================
;; Jolt wrapper functions
;; =============================================================================

(defn create-world [] (cpp/jolt_create_world))
(defn destroy-world! [w] (cpp/jolt_destroy_world w))
(defn create-sphere [w x y z r] (cpp/jolt_create_sphere w x y z r))
(defn create-floor [w] (cpp/jolt_create_floor w))
(defn get-position [w id] (cpp/jolt_get_pos w id))
(defn set-velocity! [w id vx vy vz] (cpp/jolt_set_vel w id vx vy vz))
(defn step! [w dt] (cpp/jolt_step w dt))
(defn optimize! [w] (cpp/jolt_optimize w))
(defn num-bodies [w] (cpp/jolt_num_bodies w))
(defn num-active [w] (cpp/jolt_num_active w))

;; =============================================================================
;; Entity/State wrappers
;; =============================================================================

(defn add-entity! [id r cr cg cb] (cpp/native_add_entity id r cr cg cb))
(defn entity-count [] (cpp/native_entity_count))
(defn clear-entities! [] (cpp/native_clear_entities))

(defn paused? [] (cpp/native_get_paused))
(defn set-paused! [v] (cpp/native_set_paused v))
(defn time-scale [] (cpp/native_get_time_scale))
(defn set-time-scale! [v] (cpp/native_set_time_scale v))
(defn spawn-count [] (cpp/native_get_spawn_count))
(defn set-spawn-count! [v] (cpp/native_set_spawn_count v))
(defn view-scale [] (cpp/native_get_view_scale))
(defn set-view-scale! [v] (cpp/native_set_view_scale v))
(defn view-offset [] [(cpp/native_get_view_offset_x) (cpp/native_get_view_offset_y)])
(defn set-view-offset! [x y] (cpp/native_set_view_offset x y))

;; =============================================================================
;; Raylib/ImGui wrappers
;; =============================================================================

(defn raylib-init! [] (cpp/raylib_init))
(defn raylib-shutdown! [] (cpp/raylib_shutdown))
(defn raylib-should-close? [] (cpp/raylib_should_close))
(defn get-dt [] (cpp/raylib_get_dt))

(defn imgui-init! [] (cpp/imgui_init))
(defn imgui-update! [] (cpp/imgui_update_input))
(defn imgui-new-frame! [] (cpp/native_imgui_new_frame))
(defn imgui-render! [] (cpp/native_imgui_render))
(defn imgui-draw! [] (cpp/imgui_render_draw_data))
(defn imgui-shutdown! [] (cpp/imgui_shutdown))

(defn begin-frame! [] (cpp/begin_frame))
(defn end-frame! [] (cpp/end_frame))
(defn draw-grid! [] (cpp/draw_grid))
(defn draw-entities! [world] (cpp/native_draw_entities world))
(defn draw-title! [] (cpp/draw_title))
(defn draw-imgui-panel! [world] (cpp/native_draw_imgui_panel world))
(defn handle-input! [] (cpp/handle_input_for_view))
(defn reset-requested? [] (cpp/native_check_reset))
(defn reset-simulation! [world] (cpp/native_reset_simulation world))

;; =============================================================================
;; Game logic (in jank)
;; =============================================================================

(defn rand-range [min max]
  (+ min (* (rand) (- max min))))

(defn spawn-ball! [world]
  (let [x (rand-range -20 20)
        y (rand-range 15 40)
        z (rand-range -20 20)
        r (rand-range 0.5 1.5)
        cr (int (rand-range 50 255))
        cg (int (rand-range 50 255))
        cb (int (rand-range 50 255))
        id (create-sphere world x y z r)
        ;; Random horizontal velocity
        vx (rand-range -10 10)
        vz (rand-range -10 10)]
    (set-velocity! world id vx 0.0 vz)
    (add-entity! id r cr cg cb)))

(defn spawn-balls! [world n]
  (dotimes [_ n]
    (spawn-ball! world)))

(defn spawn-initial-balls! [world]
  ;; Spawn 200 balls with random positions and velocities
  (dotimes [_ 200]
    (spawn-ball! world)))

;; =============================================================================
;; Main function
;; =============================================================================

(defn -main [& args]
  (println "Starting integrated demo: Raylib + ImGui + JoltPhysics")
  (println "Using jank-style code with static linking!")
  (println "")

  ;; Initialize raylib
  (raylib-init!)

  ;; Initialize Jolt
  (println "Creating physics world...")
  (let [initial-world (create-world)]
    (create-floor initial-world)
    (spawn-initial-balls! initial-world)
    (optimize! initial-world)

    ;; Initialize ImGui
    (imgui-init!)

    (println "Demo initialized! Press ESC to exit.")

    ;; Main loop with world as loop parameter (allows reset)
    (loop [world initial-world]
      (if (raylib-should-close?)
        ;; Cleanup and exit
        (do
          (imgui-shutdown!)
          (destroy-world! world)
          (raylib-shutdown!)
          (println "Done!"))
        ;; Continue running
        (let [dt (get-dt)]

          ;; Update ImGui
          (imgui-update!)
          (imgui-new-frame!)

          ;; Handle input
          (when (handle-input!)
            (spawn-balls! world (spawn-count)))

          ;; Physics step
          (when-not (paused?)
            (step! world (* dt (time-scale))))

          ;; Draw ImGui UI
          (draw-imgui-panel! world)
          (imgui-render!)

          ;; Render
          (begin-frame!)
          (draw-grid!)
          (draw-entities! world)
          (draw-title!)
          (imgui-draw!)
          (end-frame!)

          ;; Check for reset and recur with possibly new world
          (if (reset-requested?)
            (let [new-world (reset-simulation! world)]
              (spawn-initial-balls! new-world)
              (optimize! new-world)
              (recur new-world))
            (recur world)))))))
