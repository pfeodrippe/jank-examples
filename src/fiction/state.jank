(ns fiction.state
  "Flecs ECS-based state management for the interactive fiction dialogue system.

   Uses vybe.flecs for state management with:
   - Entities for dialogue history entries and available choices
   - Components for entry data (type, speaker, text, order)
   - Tags for categorization (:fiction/history, :fiction/choice, :fiction/selected)
   - vf/defsystem for frame-level state updates

   Manages:
   - Dialogue history (what has been displayed)
   - Current position in the story tree
   - Selected choices
   - Available choices"
  (:require
   [fiction.parser :as parser]
   [vybe.flecs :as vf]
   [vybe.type :as vt]))

;; =============================================================================
;; ECS Components
;; =============================================================================

;; Entry order in history (for maintaining display order)
(vt/defcomp EntryOrder
  [[:index :i32]])

;; Entry type: 0=dialogue, 1=narration, 2=choice, 3=choice-selected
(vt/defcomp EntryType
  [[:value :i32]])

;; File watcher state - tracks last modification time for hot-reload
(vt/defcomp FileWatchState
  [[:last-mod-time :i64]
   [:dirty :i32]])

;; =============================================================================
;; ECS World
;; =============================================================================

(defonce ^:private *world (atom nil))

(defn get-world
  "Get the ECS world, creating if needed."
  []
  (when-not @*world
    (reset! *world (vf/make-world)))
  @*world)

(defn reset-world!
  "Reset the ECS world."
  []
  (when @*world
    (vf/destroy-world! @*world))
  (reset! *world (vf/make-world))
  @*world)

;; =============================================================================
;; Story Data (complex nested data stays in atoms)
;; =============================================================================

;; Story tree and navigation state - complex nested structures
;; that don't map well to flat ECS components
(defonce ^:private *story-data
  (atom {:story-tree nil
         :metadata {}
         :current-node nil
         :choice-path []
         :node-stack []
         :selected-ids #{}}))

;; =============================================================================
;; History & Choices (ECS-backed with jank map caches for rendering)
;; =============================================================================

;; We store history/choices as both ECS entities AND cached vectors.
;; ECS entities are the source of truth for what exists.
;; The cached vectors provide fast ordered access for rendering.

(defonce ^:private *history-cache (atom []))
(defonce ^:private *choices-cache (atom []))
(defonce ^:private *next-history-idx (atom 0))

;; =============================================================================
;; Entity Management
;; =============================================================================

(defn- add-history-entity!
  "Create an ECS entity for a history entry."
  [entry]
  ;; For now, just cache the entry (skip ECS entity creation until tested)
  (swap! *next-history-idx inc)
  (swap! *history-cache conj entry))

(defn- clear-choice-entities!
  "Remove all choice entities from the world."
  []
  (reset! *choices-cache []))

(defn- set-choice-entities!
  "Create ECS entities for the current available choices."
  [choices]
  (clear-choice-entities!)
  (reset! *choices-cache choices))

;; =============================================================================
;; State Accessors
;; =============================================================================

(defn get-history
  "Get the dialogue history."
  []
  @*history-cache)

(defn get-current-node
  "Get the current story node."
  []
  (:current-node @*story-data))

(defn get-story-tree
  "Get the full story tree."
  []
  (:story-tree @*story-data))

(defn get-metadata
  "Get story metadata."
  []
  (:metadata @*story-data))

(defn get-available-choices
  "Get currently available choices."
  []
  @*choices-cache)

(defn get-choice-path
  "Get the path of choices taken."
  []
  (:choice-path @*story-data))

(defn get-selected-ids
  "Get the set of already-selected choice IDs."
  []
  (:selected-ids @*story-data))

;; =============================================================================
;; ECS Query Helpers
;; =============================================================================

(defn history-count
  "Get the number of history entries from ECS."
  []
  (let [w (get-world)
        results (vf/with-query w [o EntryOrder
                                   _ :fiction/history
                                   e :vf/entity]
                  1)]
    (count results)))

(defn choice-count
  "Get the number of choice entities from ECS."
  []
  (let [w (get-world)
        results (vf/with-query w [o EntryOrder
                                   _ :fiction/choice
                                   e :vf/entity]
                  1)]
    (count results)))

;; =============================================================================
;; Content Revelation
;; =============================================================================

(defn- node->history-entry
  "Convert a tree node to a history entry map."
  ([node]
   (node->history-entry node false))
  ([node selected?]
   (hash-map :type (:type node)
             :speaker (:speaker node)
             :text (:text node)
             :id (:id node)
             :selected? (or selected? false))))

(defn- add-node-to-history!
  "Add a node's content to history as an ECS entity."
  ([node]
   (add-node-to-history! node false))
  ([node selected?]
   (when (and node (not (empty? (:text node))))
     (add-history-entity! (node->history-entry node selected?)))))

(defn- reveal-content!
  "Reveal non-choice content from a node's children."
  [node]
  (doseq [child (:children node)]
    (when (not= (:type child) :choice)
      (add-node-to-history! child)
      (reveal-content! child))))

(defn- update-available-choices!
  "Update the ECS choice entities based on current node."
  []
  (let [current (:current-node @*story-data)
        ;; Local fn to collect choices - must be local due to jank bug
        ;; with top-level defn- and lazy seqs/vec across boundaries
        collect-choices (fn collect [node]
                          (let [direct-choices (filter #(= (:type %) :choice) (:children node))
                                nested (mapcat collect
                                               (filter #(not= (:type %) :choice) (:children node)))]
                            (concat direct-choices nested)))]
    (when current
      (reset! *choices-cache (vec (collect-choices current))))))

;; =============================================================================
;; Story Loading
;; =============================================================================

(defn load-story!
  "Load a parsed story into state. Resets all state and creates fresh ECS entities."
  [{:keys [metadata tree]}]
  ;; Initialize ECS world
  (let [w (get-world)]
    (reset! *choices-cache []))
  (reset! *history-cache [])
  (reset! *next-history-idx 0)
  (reset! *story-data
          {:story-tree tree
           :metadata metadata
           :current-node tree
           :choice-path []
           :node-stack []
           :selected-ids #{}})
  ;; Reveal initial content
  (reveal-content! tree)
  ;; Update available choices
  (update-available-choices!)
  (println "Story loaded:" (:title metadata)))

(defn- find-choice-by-text
  "Find a choice node by its text in a node's children."
  [node text]
  (first (filter #(and (= (:type %) :choice) (= (:text %) text)) (:children node))))

(defn reload-story!
  "Reload story from parsed data while preserving current state.
   Re-parses the tree, replays the choice path to find current position,
   and updates available choices without losing history."
  [{:keys [metadata tree]}]
  (let [old-data @*story-data
        old-history @*history-cache
        old-choice-texts (mapv (fn [choice-id]
                                 (let [entry (first (filter #(= (:id %) choice-id) old-history))]
                                   (:text entry)))
                               (:choice-path old-data))
        ;; Walk the new tree following the same choices by text
        replay-result (loop [node tree
                             texts old-choice-texts
                             new-path []
                             new-selected #{}
                             new-stack []]
                        (if (empty? texts)
                          {:node node :path new-path :selected new-selected :stack new-stack}
                          (let [choice-text (first texts)
                                matched (find-choice-by-text node choice-text)]
                            (if matched
                              (let [has-nested? (some #(= (:type %) :choice) (:children matched))]
                                (if has-nested?
                                  (recur matched
                                         (rest texts)
                                         (conj new-path (:id matched))
                                         (conj new-selected (:id matched))
                                         (conj new-stack node))
                                  {:node node
                                   :path (conj new-path (:id matched))
                                   :selected (conj new-selected (:id matched))
                                   :stack new-stack}))
                              {:node node :path new-path :selected new-selected :stack new-stack}))))]
    ;; Update story data with new tree but replayed position
    (reset! *story-data
            {:story-tree tree
             :metadata metadata
             :current-node (:node replay-result)
             :choice-path (:path replay-result)
             :node-stack (:stack replay-result)
             :selected-ids (:selected replay-result)})
    ;; Keep existing history ECS entities, just refresh choice entities
    (update-available-choices!)
    (println "Story reloaded (state preserved):" (:title metadata))))

(defn load-story-from-file!
  "Parse and load a story from a file path."
  [filepath]
  (let [parsed (parser/parse-story-file filepath)]
    (load-story! parsed)))

(defn reload-story-from-file!
  "Parse and reload a story from a file path, preserving state."
  [filepath]
  (let [parsed (parser/parse-story-file filepath)]
    (reload-story! parsed)))

;; =============================================================================
;; Choice Selection
;; =============================================================================

(defn select-choice!
  "Select a choice by index.
   - Adds choice text to history as ECS entity
   - Reveals content under that choice
   - Only navigates deeper if the choice has nested choices"
  [choice-idx]
  (let [choices @*choices-cache]
    (when (and (>= choice-idx 0) (< choice-idx (count choices)))
      (let [choice (nth choices choice-idx)
            has-nested-choices? (some #(= (:type %) :choice) (:children choice))]
        ;; Add choice to history as ECS entity
        (add-node-to-history! choice true)
        ;; Reveal content under choice as ECS entities
        (reveal-content! choice)
        ;; Track selection
        (swap! *story-data update :selected-ids conj (:id choice))
        (swap! *story-data update :choice-path conj (:id choice))
        ;; Navigate deeper if needed, update choice entities
        (when has-nested-choices?
          (let [current-node (:current-node @*story-data)]
            (swap! *story-data update :node-stack conj current-node)
            (swap! *story-data assoc :current-node choice)))
        (update-available-choices!)))))

(defn select-choice-by-id!
  "Select a choice by its node ID."
  [choice-id]
  (let [choices @*choices-cache
        idx (first (keep-indexed (fn [i c] (when (= (:id c) choice-id) i)) choices))]
    (when idx
      (select-choice! idx))))

;; =============================================================================
;; Story State Queries
;; =============================================================================

(defn has-choices?
  "Check if there are currently available choices."
  []
  (not (empty? @*choices-cache)))

(defn story-loaded?
  "Check if a story is currently loaded."
  []
  (some? (:story-tree @*story-data)))

(defn at-end?
  "Check if we've reached an end."
  []
  (and (story-loaded?)
       (not (has-choices?))))

;; =============================================================================
;; Debug
;; =============================================================================

(defn debug-state
  "Print current state for debugging."
  []
  (println "=== Fiction State (ECS) ===")
  (println "History entries (cache):" (count @*history-cache))
  (println "History entities (ECS):" (history-count))
  (println "Choice entities (ECS):" (choice-count))
  (println "Available choices (cache):" (count @*choices-cache))
  (println "Choice path:" (:choice-path @*story-data))
  (println "Current node type:" (:type (:current-node @*story-data)))
  (println "=========================="))
