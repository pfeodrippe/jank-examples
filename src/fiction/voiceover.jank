(ns fiction.voiceover
  "Voice-over playback for fiction dialogue.

   Shared gameplay-level module (backend-agnostic): triggers VO when new
   dialogue history entries appear, independent from Vulkan/WebGPU renderers."
  (:require
   [fiction.state :as state]
   [vybe.audio :as audio]
   ["fiction_gfx/fiction_gfx.hpp" :as engine :scope "fiction_engine"]))

;; Root folder for dialogue voice assets.
(def ^:private voice-root "resources/fiction/voice")
(def ^:private fallback-locale "fr")
(def ^:private mock-voice-path (str voice-root "/_mock/default.wav"))

;; Runtime module state.
(defonce ^:private *enabled (atom false))
(defonce ^:private *last-history-count (atom 0))
;; Avoid repeating the same warning spam when assets are missing.
(defonce ^:private *missing-warned (atom #{}))
;; Entries waiting for playback (used for wasm unlock / transient failures).
(defonce ^:private *pending (atom []))
;; Currently playing managed sound (single-active policy).
(defonce ^:private *current-sound (atom false))
;; Current voice context for hot-reload polling.
(defonce ^:private *current-entry (atom false))
(defonce ^:private *current-candidates (atom []))
(defonce ^:private *current-candidate-mod-times (atom {}))

(defn- clear-current-watch!
  "Clear tracked voice context used by hot-reload polling."
  []
  (reset! *current-entry false)
  (reset! *current-candidates [])
  (reset! *current-candidate-mod-times {}))

(defn- stop-current-sound!
  "Stop and destroy currently playing sound, if any."
  []
  (let [snd @*current-sound]
    (when snd
      (audio/sound-stop! snd)
      (audio/sound-destroy! snd)
      (reset! *current-sound false))))

(defn- snapshot-mod-times
  "Snapshot file modification times for candidate paths."
  [paths]
  (loop [remaining paths
         out {}]
    (if (empty? remaining)
      out
      (let [path (first remaining)
            mtime (engine/get_file_mod_time path)]
        (recur (rest remaining) (assoc out path mtime))))))

(defn- current-candidates-changed?
  "Check whether any tracked candidate file changed on disk."
  []
  (let [entry @*current-entry
        paths @*current-candidates]
    (if (or (not entry) (empty? paths))
      false
      (let [old-snapshot @*current-candidate-mod-times
            new-snapshot (snapshot-mod-times paths)]
        (if (not= old-snapshot new-snapshot)
          (do
            (reset! *current-candidate-mod-times new-snapshot)
            true)
          false)))))

(defn- normalized-locale
  "Resolve locale from metadata, falling back to default."
  []
  (let [raw (:locale (state/get-metadata))]
    (if (and (string? raw) (not (empty? raw)))
      raw
      fallback-locale)))

(defn- candidate-paths
  "Ordered candidate VO files for a dialogue entry."
  [entry]
  (let [locale (normalized-locale)
        entry-id (:id entry)
        speaker-id (:speaker entry)
        locale-entry (when entry-id
                       (str voice-root "/" locale "/" entry-id ".wav"))
        locale-speaker (when speaker-id
                         (str voice-root "/" locale "/speaker-" speaker-id ".wav"))
        fallback-entry (when entry-id
                         (str voice-root "/" fallback-locale "/" entry-id ".wav"))
        fallback-speaker (when speaker-id
                           (str voice-root "/" fallback-locale "/speaker-" speaker-id ".wav"))]
    (vec (distinct (remove nil?
                           [locale-entry
                            locale-speaker
                            fallback-entry
                            fallback-speaker
                            mock-voice-path])))))

(defn- play-entry!
  "Play voice for a dialogue entry, trying fallbacks in order.
   Single-active policy: stop previous clip before starting a new one."
  [entry]
  (let [paths (candidate-paths entry)]
    ;; New entry always interrupts the currently playing clip.
    (stop-current-sound!)
    (loop [remaining paths]
      (if (empty? remaining)
        (let [warn-key (or (:id entry) (str "speaker-" (:speaker entry)) "unknown")]
          (when-not (contains? @*missing-warned warn-key)
            (swap! *missing-warned conj warn-key)
            (println "[voiceover] no playable asset for entry id="
                     (or (:id entry) "<nil>")
                     "speaker=" (or (:speaker entry) "<nil>")))
          (clear-current-watch!)
          false)
        (let [path (first remaining)
              snd (audio/sound-stream path)]
          (if snd
            (if (audio/sound-start! snd)
              (do
                (reset! *current-sound snd)
                (reset! *current-entry entry)
                (reset! *current-candidates paths)
                (reset! *current-candidate-mod-times (snapshot-mod-times paths))
                (println "[voiceover] playing:" path)
                true)
              (do
                (audio/sound-destroy! snd)
                (recur (rest remaining))))
            (recur (rest remaining))))))))

(defn- speakable-entry?
  [entry]
  ;; VO trigger policy:
  ;; - dialogue always trigger
  ;; - choice entries are never voiced
  ;; - narration triggers only when it has explicit [id:...] in story
  ;;   (plain continuation narration should not start a new clip)
  (or (= :dialogue (:type entry))
      (and (= :narration (:type entry))
           (:explicit-id? entry))))

(defn- pick-entry-to-play
  "Pick one entry from a batch of fresh speakable entries.
   Keep only the newest to avoid backlog."
  [fresh]
  (last fresh))

(defn init!
  "Initialize voice-over playback engine."
  []
  ;; Ignore already-revealed startup history to avoid autoplay-policy failures
  ;; on first frame and to start VO from interactive progression.
  (reset! *last-history-count (count (state/get-history)))
  (reset! *missing-warned #{})
  (reset! *pending [])
  (reset! *current-sound false)
  (clear-current-watch!)
  (if (audio/init!)
    (do
      (audio/set-volume! 1.0)
      (reset! *enabled true)
      (println "Voiceover enabled.")
      true)
    (do
      (reset! *enabled false)
      (println "WARN: Voiceover disabled (audio init failed).")
      false)))

(defn shutdown!
  "Shutdown voice-over playback engine."
  []
  (stop-current-sound!)
  (when (audio/initialized?)
    (audio/uninit!))
  (reset! *enabled false)
  (reset! *last-history-count 0)
  (reset! *pending [])
  (reset! *current-sound false)
  (clear-current-watch!))

(defn update!
  "Process newly appended history entries and trigger VO.

   If multiple entries were appended in one frame, keep only the newest
   speakable entry. This prevents backlog/overlap when advancing quickly."
  []
  (let [history (state/get-history)
        total (count history)
        old-count @*last-history-count]
    ;; Story reset/reload case.
    (when (> old-count total)
      (reset! *last-history-count 0))
    (let [start @*last-history-count]
      (when (< start total)
        (reset! *last-history-count total)
        (let [fresh (loop [i start
                           out []]
                      (if (>= i total)
                        out
                        (let [entry (nth history i)]
                          (if (speakable-entry? entry)
                            (recur (inc i) (conj out entry))
                            (recur (inc i) out)))))]
          (when (not (empty? fresh))
            (reset! *pending [(pick-entry-to-play fresh)])))))
    ;; Hot-reload watcher: detect changed candidate files, but do not auto-play.
    ;; New content is picked up on the next normal line trigger.
    (when (and @*enabled
               (current-candidates-changed?)
               @*current-entry)
      (println "[voiceover] hot reload detected for id="
               (or (:id @*current-entry) "<nil>")
               "(waiting for next trigger)"))
    ;; Attempt one pending playback per frame; retry on failure.
    (when (and @*enabled (not (empty? @*pending)))
      (let [entry (first @*pending)]
        (when (play-entry! entry)
          (reset! *pending []))))))
