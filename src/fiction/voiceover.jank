(ns fiction.voiceover
  "Voice-over playback for fiction dialogue.

   Shared gameplay-level module (backend-agnostic): triggers VO when new
   dialogue history entries appear, independent from Vulkan/WebGPU renderers."
  (:require
   [fiction.state :as state]
   [vybe.audio :as audio]))

;; Root folder for dialogue voice assets.
(def ^:private voice-root "resources/fiction/voice")
(def ^:private fallback-locale "fr")
(def ^:private mock-voice-path (str voice-root "/_mock/default.wav"))

;; Runtime module state.
(defonce ^:private *enabled (atom false))
(defonce ^:private *last-history-count (atom 0))
;; Avoid repeating the same warning spam when assets are missing.
(defonce ^:private *missing-warned (atom #{}))
;; Entries waiting for playback (used for wasm unlock / transient failures).
(defonce ^:private *pending (atom []))

(defn- normalized-locale
  "Resolve locale from metadata, falling back to default."
  []
  (let [raw (:locale (state/get-metadata))]
    (if (and (string? raw) (not (empty? raw)))
      raw
      fallback-locale)))

(defn- candidate-paths
  "Ordered candidate VO files for a dialogue entry."
  [entry]
  (let [locale (normalized-locale)
        entry-id (:id entry)
        speaker-id (:speaker entry)
        locale-entry (when entry-id
                       (str voice-root "/" locale "/" entry-id ".wav"))
        locale-speaker (when speaker-id
                         (str voice-root "/" locale "/speaker-" speaker-id ".wav"))
        fallback-entry (when entry-id
                         (str voice-root "/" fallback-locale "/" entry-id ".wav"))
        fallback-speaker (when speaker-id
                           (str voice-root "/" fallback-locale "/speaker-" speaker-id ".wav"))]
    (vec (distinct (remove nil?
                           [locale-entry
                            locale-speaker
                            fallback-entry
                            fallback-speaker
                            mock-voice-path])))))

(defn- play-entry!
  "Play voice for a dialogue entry, trying fallbacks in order."
  [entry]
  (let [paths (candidate-paths entry)]
    (loop [remaining paths]
      (if (empty? remaining)
        (let [warn-key (or (:id entry) (str "speaker-" (:speaker entry)) "unknown")]
          (when-not (contains? @*missing-warned warn-key)
            (swap! *missing-warned conj warn-key)
            (println "[voiceover] no playable asset for entry id="
                     (or (:id entry) "<nil>")
                     "speaker=" (or (:speaker entry) "<nil>")))
          false)
        (let [path (first remaining)]
          (if (audio/play! path)
            (do
              (println "[voiceover] playing:" path)
              true)
            (recur (rest remaining))))))))

(defn- speakable-entry?
  [entry]
  (contains? #{:dialogue :narration :choice} (:type entry)))

(defn init!
  "Initialize voice-over playback engine."
  []
  ;; Ignore already-revealed startup history to avoid autoplay-policy failures
  ;; on first frame and to start VO from interactive progression.
  (reset! *last-history-count (count (state/get-history)))
  (reset! *missing-warned #{})
  (reset! *pending [])
  (if (audio/init!)
    (do
      (audio/set-volume! 1.0)
      (reset! *enabled true)
      (println "Voiceover enabled.")
      true)
    (do
      (reset! *enabled false)
      (println "WARN: Voiceover disabled (audio init failed).")
      false)))

(defn shutdown!
  "Shutdown voice-over playback engine."
  []
  (when (audio/initialized?)
    (audio/uninit!))
  (reset! *enabled false)
  (reset! *last-history-count 0)
  (reset! *pending []))

(defn update!
  "Process newly appended history entries and trigger VO once per update.

   If multiple entries were appended in one frame, the newest dialogue entry
   is used to avoid overlapping one-shot clips."
  []
  (let [history (state/get-history)
        total (count history)
        old-count @*last-history-count]
    ;; Story reset/reload case.
    (when (> old-count total)
      (reset! *last-history-count 0))
    (let [start @*last-history-count]
      (when (< start total)
        (reset! *last-history-count total)
        (let [fresh (loop [i start
                           out []]
                      (if (>= i total)
                        out
                        (let [entry (nth history i)]
                          (if (speakable-entry? entry)
                            (recur (inc i) (conj out entry))
                            (recur (inc i) out)))))]
          (when (not (empty? fresh))
            (swap! *pending into fresh)))))
    ;; Attempt one pending playback per frame; retry on failure.
    (when (and @*enabled (not (empty? @*pending)))
      (let [entry (first @*pending)]
        (when (play-entry! entry)
          (swap! *pending subvec 1))))))
