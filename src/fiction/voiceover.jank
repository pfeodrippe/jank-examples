(ns fiction.voiceover
  "Voice-over playback for fiction dialogue.

   Shared gameplay-level module (backend-agnostic): triggers VO when new
   dialogue history entries appear, independent from Vulkan/WebGPU renderers."
  (:require
   [fiction.state :as state]
   [vybe.audio :as audio]
   ["fiction_gfx/fiction_gfx.hpp" :as engine :scope "fiction_engine"]))

;; Root folder for dialogue voice assets.
(def ^:private voice-root "resources/fiction/voice")
(def ^:private fallback-locale "fr")
(def ^:private mock-voice-path (str voice-root "/_mock/default.wav"))
(def ^:private mock-voice-path-mp3 (str voice-root "/_mock/default.mp3"))
(def ^:private supported-extensions [".wav" ".mp3"])

;; Runtime module state.
(defonce ^:private *enabled (atom false))
(defonce ^:private *last-history-count (atom 0))
;; Avoid repeating the same warning spam when assets are missing.
(defonce ^:private *missing-warned (atom #{}))
;; Entries waiting for playback (used for wasm unlock / transient failures).
(defonce ^:private *pending (atom []))
;; Currently playing managed sound (single-active policy).
(defonce ^:private *current-sound (atom false))
;; Current voice context for hot-reload polling.
(defonce ^:private *current-entry (atom false))
(defonce ^:private *current-candidates (atom []))
(defonce ^:private *current-candidate-mod-times (atom {}))

(defn- clear-current-watch!
  "Clear tracked voice context used by hot-reload polling."
  []
  (reset! *current-entry false)
  (reset! *current-candidates [])
  (reset! *current-candidate-mod-times {}))

(defn- stop-current-sound!
  "Stop and destroy currently playing sound, if any."
  []
  (let [snd @*current-sound]
    (when snd
      (audio/sound-stop! snd)
      (audio/sound-destroy! snd)
      (reset! *current-sound false))))

(defn- snapshot-mod-times
  "Snapshot file modification times for candidate paths."
  [paths]
  (loop [remaining paths
         out {}]
    (if (empty? remaining)
      out
      (let [path (first remaining)
            mtime (engine/get_file_mod_time path)]
        (recur (rest remaining) (assoc out path mtime))))))

(defn- current-candidates-changed?
  "Check whether any tracked candidate file changed on disk."
  []
  (let [entry @*current-entry
        paths @*current-candidates]
    (if (or (not entry) (empty? paths))
      false
      (let [old-snapshot @*current-candidate-mod-times
            new-snapshot (snapshot-mod-times paths)]
        (if (not= old-snapshot new-snapshot)
          (do
            (reset! *current-candidate-mod-times new-snapshot)
            true)
          false)))))

(defn- normalized-locale
  "Resolve locale from metadata, falling back to default."
  []
  (let [raw (:locale (state/get-metadata))]
    (if (and (string? raw) (not (empty? raw)))
      raw
      fallback-locale)))

(defn- normalize-prefixed-assets!
  "Rename Bitwig-style prefixed files (e.g. `02 id.wav`) to canonical `id.wav`."
  [locale entry-id]
  (when (and locale entry-id)
    (let [dir (str voice-root "/" locale)]
      (loop [remaining supported-extensions]
        (when (not (empty? remaining))
          (let [ext (first remaining)
                renamed? (engine/normalize_voice_prefixed_file dir entry-id ext)]
            (when (= renamed? 1)
              (println "[voiceover] normalized filename:"
                       dir "/" entry-id ext))
            (recur (rest remaining))))))))

(defn- normalize-prefixed-assets-for-entry!
  "Normalize prefixed assets for an entry id in active locale and fallback locale."
  [entry-id]
  (when entry-id
    (let [locale (normalized-locale)]
      (normalize-prefixed-assets! locale entry-id)
      (when (not= locale fallback-locale)
        (normalize-prefixed-assets! fallback-locale entry-id)))))

(defn- normalize-prefixed-assets-in-locale!
  "Normalize any Bitwig prefixed files in active/fallback locale dirs."
  []
  (let [locale (normalized-locale)
        locale-dir (str voice-root "/" locale)
        fallback-dir (str voice-root "/" fallback-locale)
        locale-count (engine/normalize_voice_prefixed_files locale-dir)
        fallback-count (if (not= locale fallback-locale)
                         (engine/normalize_voice_prefixed_files fallback-dir)
                         0)
        total (+ locale-count fallback-count)]
    (when (> total 0)
      (println "[voiceover] normalized prefixed files:" total))))

(defn- candidate-paths
  "Ordered candidate VO files for a dialogue entry."
  [entry]
  (let [locale (normalized-locale)
        entry-id (:id entry)
        speaker-id (:speaker entry)
        _ (normalize-prefixed-assets-for-entry! entry-id)
        with-exts (fn [base]
                    (when base
                      (loop [remaining supported-extensions
                             out []]
                        (if (empty? remaining)
                          out
                          (recur (rest remaining)
                                 (conj out (str base (first remaining))))))))
        locale-entry (with-exts (when entry-id
                                  (str voice-root "/" locale "/" entry-id)))
        locale-speaker (with-exts (when speaker-id
                                    (str voice-root "/" locale "/speaker-" speaker-id)))
        fallback-entry (with-exts (when entry-id
                                    (str voice-root "/" fallback-locale "/" entry-id)))
        fallback-speaker (with-exts (when speaker-id
                                      (str voice-root "/" fallback-locale "/speaker-" speaker-id)))]
    (->> (concat locale-entry
                 locale-speaker
                 fallback-entry
                 fallback-speaker
                 [mock-voice-path
                  mock-voice-path-mp3])
         (remove nil?)
         distinct
         vec)))

(defn- play-entry!
  "Play voice for a dialogue entry, trying fallbacks in order.
   Single-active policy: stop previous clip before starting a new one."
  [entry]
  (let [paths (candidate-paths entry)]
    ;; New entry always interrupts the currently playing clip.
    (stop-current-sound!)
    (loop [remaining paths]
      (if (empty? remaining)
        (let [warn-key (or (:id entry) (str "speaker-" (:speaker entry)) "unknown")]
          (when-not (contains? @*missing-warned warn-key)
            (swap! *missing-warned conj warn-key)
            (println "[voiceover] no playable asset for entry id="
                     (or (:id entry) "<nil>")
                     "speaker=" (or (:speaker entry) "<nil>")))
          (clear-current-watch!)
          false)
        (let [path (first remaining)
              snd (audio/sound-stream path)]
          (if snd
            (if (audio/sound-start! snd)
              (do
                (reset! *current-sound snd)
                (reset! *current-entry entry)
                (reset! *current-candidates paths)
                (reset! *current-candidate-mod-times (snapshot-mod-times paths))
                (println "[voiceover] playing:" path)
                true)
              (do
                (audio/sound-destroy! snd)
                (recur (rest remaining))))
            (recur (rest remaining))))))))

(defn- speakable-entry?
  [entry]
  ;; VO trigger policy:
  ;; - dialogue always trigger
  ;; - choice entries are never voiced
  ;; - narration triggers only when it has explicit [id:...] in story
  ;;   (plain continuation narration should not start a new clip)
  (or (= :dialogue (:type entry))
      (and (= :narration (:type entry))
           (:explicit-id? entry))))

(defn- pick-entry-to-play
  "Pick one entry from a batch of fresh speakable entries.
   Keep only the newest to avoid backlog."
  [fresh]
  (last fresh))

(defn init!
  "Initialize voice-over playback engine."
  []
  (let [history (state/get-history)
        history-count (count history)]
    ;; Mark all current history as seen to avoid re-triggering on future updates.
    (reset! *last-history-count history-count)
    (reset! *missing-warned #{})
    (reset! *pending [])
    (reset! *current-sound false)
    (clear-current-watch!)
    (if (audio/init!)
      (do
        (audio/set-volume! 1.0)
        (reset! *enabled true)
        (println "Voiceover enabled.")
        ;; Queue the last speakable entry from initial history for playback.
        ;; This ensures the first dialogue plays after user interaction unlocks audio.
        (when (> history-count 0)
          (let [speakable (loop [i (dec history-count)]
                           (if (< i 0)
                             nil
                             (let [entry (nth history i)]
                               (if (speakable-entry? entry)
                                 entry
                                 (recur (dec i))))))]
            (when speakable
              (reset! *pending [speakable]))))
        true)
      (do
        (reset! *enabled false)
        (println "WARN: Voiceover disabled (audio init failed).")
        false))))

(defn shutdown!
  "Shutdown voice-over playback engine."
  []
  (stop-current-sound!)
  (when (audio/initialized?)
    (audio/uninit!))
  (reset! *enabled false)
  (reset! *last-history-count 0)
  (reset! *pending [])
  (reset! *current-sound false)
  (clear-current-watch!))

(defn update!
  "Process newly appended history entries and trigger VO.

   If multiple entries were appended in one frame, keep only the newest
   speakable entry. This prevents backlog/overlap when advancing quickly."
  []
  (let [history (state/get-history)
        total (count history)
        old-count @*last-history-count]
    ;; Always normalize new Bitwig exports like "03 id.wav" -> "id.wav".
    ;; This keeps desktop hot-reload working without manual renames.
    (normalize-prefixed-assets-in-locale!)
    ;; Story reset/reload case.
    (when (> old-count total)
      (reset! *last-history-count 0))
    (let [start @*last-history-count]
      (when (< start total)
        (reset! *last-history-count total)
        (let [fresh (loop [i start
                           out []]
                      (if (>= i total)
                        out
                        (let [entry (nth history i)]
                          (if (speakable-entry? entry)
                            (recur (inc i) (conj out entry))
                            (recur (inc i) out)))))]
          (when (not (empty? fresh))
            (reset! *pending [(pick-entry-to-play fresh)])))))
    ;; If a currently relevant file was exported with Bitwig numeric prefix,
    ;; normalize it to canonical id filename first.
    (when-let [entry @*current-entry]
      (normalize-prefixed-assets-for-entry! (:id entry)))
    ;; Hot-reload watcher: detect changed candidate files, but do not auto-play.
    ;; New content is picked up on the next normal line trigger.
    (when (and @*enabled
               (current-candidates-changed?)
               @*current-entry)
      (println "[voiceover] hot reload detected for id="
               (or (:id @*current-entry) "<nil>")
               "(waiting for next trigger)"))
    ;; Attempt one pending playback per frame; retry on failure.
    (when (and @*enabled (not (empty? @*pending)))
      (let [entry (first @*pending)]
        (when (play-entry! entry)
          (reset! *pending []))))))
