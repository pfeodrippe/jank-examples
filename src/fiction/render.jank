(ns fiction.render
  "Jank wrapper for Vulkan fiction text renderer.
   Bridges the C++ fiction_text.hpp with jank state."
  (:require
   [fiction.state :as state]
   [clojure.string :as str]
   ;; fiction_engine must be loaded first to set up Vulkan/SDL includes
   ["fiction_gfx/fiction_gfx.hpp" :as engine :scope "fiction_engine"]
   ["fiction_gfx/fiction_gfx.hpp" :as fiction :scope "fiction"]))

;; =============================================================================
;; Style Configuration
;; =============================================================================

;; Helper to safely get style reference
(defmacro ^:private with-style [& body]
  `(let [~'tr (cpp/* (fiction/get_text_renderer))
         ~'style (cpp/.-style ~'tr)]
     ~@body))

(defn set-text-scale!
  "Set base text scale (default 1.0)."
  [scale]
  (with-style
    (cpp/= (cpp/.-textScale style) (cpp/float. scale))))

(defn set-speaker-scale!
  "Set speaker name scale relative to text (default 1.25)."
  [scale]
  (with-style
    (cpp/= (cpp/.-speakerScale style) (cpp/float. scale))))

(defn set-line-spacing!
  "Set extra spacing between lines in pixels (default 4.0)."
  [spacing]
  (with-style
    (cpp/= (cpp/.-lineSpacing style) (cpp/float. spacing))))

(defn set-entry-spacing!
  "Set lineSpacing multiplier between dialogue entries (default 2.0)."
  [spacing]
  (with-style
    (cpp/= (cpp/.-entrySpacing style) (cpp/float. spacing))))

(defn set-panel-padding!
  "Set inner panel padding in pixels (default 20.0)."
  [padding]
  (with-style
    (cpp/= (cpp/.-panelPadding style) (cpp/float. padding))))

(defn set-choice-indent!
  "Set indent for choice text in pixels (default 20.0)."
  [indent]
  (with-style
    (cpp/= (cpp/.-choiceIndent style) (cpp/float. indent))))

(defn set-panel-x!
  "Set panel X position as fraction of screen (default 0.70)."
  [x]
  (with-style
    (cpp/= (cpp/.-panelX style) (cpp/float. x))))

(defn set-panel-width!
  "Set panel width as fraction of screen (default 0.30)."
  [width]
  (with-style
    (cpp/= (cpp/.-panelWidth style) (cpp/float. width))))

(defn set-bottom-margin!
  "Set bottom margin in pixels (default 250.0)."
  [margin]
  (with-style
    (cpp/= (cpp/.-bottomMargin style) (cpp/float. margin))))

(defn set-auto-scroll!
  "Enable/disable auto-scroll animation (default true)."
  [enabled]
  (cpp/= (cpp/.-autoScrollEnabled (cpp/* (fiction/get_text_renderer)))
         (cpp/bool. enabled)))

(defn set-scroll-speed!
  "Set auto-scroll speed in lines per second (default 16.0)."
  [speed]
  (cpp/= (cpp/.-scrollAnimationSpeed (cpp/* (fiction/get_text_renderer)))
         (cpp/float. speed)))

(defn set-panel-bg-color!
  "Set panel background color (RGBA 0.0-1.0)."
  [r g b a]
  (with-style
    (cpp/= (cpp/.-bgR style) (cpp/float. r))
    (cpp/= (cpp/.-bgG style) (cpp/float. g))
    (cpp/= (cpp/.-bgB style) (cpp/float. b))
    (cpp/= (cpp/.-bgA style) (cpp/float. a))))

(defn set-text-color!
  "Set default dialogue text color (RGB 0.0-1.0)."
  [r g b]
  (with-style
    (cpp/= (cpp/.-textR style) (cpp/float. r))
    (cpp/= (cpp/.-textG style) (cpp/float. g))
    (cpp/= (cpp/.-textB style) (cpp/float. b))))

(defn set-narration-color!
  "Set narration text color (RGB 0.0-1.0)."
  [r g b]
  (with-style
    (cpp/= (cpp/.-narrationR style) (cpp/float. r))
    (cpp/= (cpp/.-narrationG style) (cpp/float. g))
    (cpp/= (cpp/.-narrationB style) (cpp/float. b))))

(defn set-choice-color!
  "Set choice text color (RGB 0.0-1.0)."
  [r g b]
  (with-style
    (cpp/= (cpp/.-choiceR style) (cpp/float. r))
    (cpp/= (cpp/.-choiceG style) (cpp/float. g))
    (cpp/= (cpp/.-choiceB style) (cpp/float. b))))

(defn set-choice-hover-color!
  "Set hovered choice text color (RGB 0.0-1.0)."
  [r g b]
  (with-style
    (cpp/= (cpp/.-choiceHoverR style) (cpp/float. r))
    (cpp/= (cpp/.-choiceHoverG style) (cpp/float. g))
    (cpp/= (cpp/.-choiceHoverB style) (cpp/float. b))))

(defn set-choice-selected-color!
  "Set selected choice text color (RGB 0.0-1.0)."
  [r g b]
  (with-style
    (cpp/= (cpp/.-choiceSelectedR style) (cpp/float. r))
    (cpp/= (cpp/.-choiceSelectedG style) (cpp/float. g))
    (cpp/= (cpp/.-choiceSelectedB style) (cpp/float. b))))

(defn set-choice-selected-hover-color!
  "Set hovered selected choice text color (RGB 0.0-1.0)."
  [r g b]
  (with-style
    (cpp/= (cpp/.-choiceSelectedHoverR style) (cpp/float. r))
    (cpp/= (cpp/.-choiceSelectedHoverG style) (cpp/float. g))
    (cpp/= (cpp/.-choiceSelectedHoverB style) (cpp/float. b))))

;; Convenience macro to set multiple layout properties at once
(defmacro set-layout!
  "Set multiple layout properties from a hashmap.

   Example:
   (set-layout! {:panel-x 0.65
                 :panel-width 0.35
                 :text-scale 1.2
                 :bottom-margin 300})"
  [m]
  `(do
     ~@(mapcat (fn [[k# v#]]
                (case k#
                  :text-scale `((set-text-scale! ~v#))
                  :speaker-scale `((set-speaker-scale! ~v#))
                  :line-spacing `((set-line-spacing! ~v#))
                  :entry-spacing `((set-entry-spacing! ~v#))
                  :panel-padding `((set-panel-padding! ~v#))
                  :choice-indent `((set-choice-indent! ~v#))
                  :panel-x `((set-panel-x! ~v#))
                  :panel-width `((set-panel-width! ~v#))
                  :bottom-margin `((set-bottom-margin! ~v#))
                  :auto-scroll `((set-auto-scroll! ~v#))
                  :scroll-speed `((set-scroll-speed! ~v#))
                  nil))
              m)))

;; =============================================================================
;; Initialization
;; =============================================================================

(defn init!
  "Initialize the text renderer with Vulkan resources.
   Must be called after the main Vulkan engine is initialized."
  [screen-width screen-height shader-dir]
  (fiction/init_text_renderer_simple
   (cpp/float. (+ 0.0 screen-width))
   (cpp/float. (+ 0.0 screen-height))
   shader-dir)
  ;; Set default layout
  #_(set-layout! {:panel-x 0.7
                :panel-width 0.3
                :text-scale 1.0
                :speaker-scale 1.25
                :line-spacing 4.0
                :entry-spacing 2.0
                :panel-padding 20.0
                :choice-indent 20.0
                :bottom-margin 300.0
                :auto-scroll true
                :scroll-speed 16.0}))

(defn init-background!
  "Load background image. Must be called after init!."
  [image-path shader-dir]
  (fiction/load_background_image_simple image-path shader-dir))

(defn init-overlay!
  "Load/update overlay image in screen pixel coordinates.
   Useful for lightweight animated regions over a static background."
  [image-path shader-dir x y width height]
  (fiction/load_overlay_image_simple
   image-path
   shader-dir
   (cpp/float. x)
   (cpp/float. y)
   (cpp/float. width)
   (cpp/float. height)))

(defn clear-overlay!
  "Remove the current overlay image layer."
  []
  (fiction/clear_overlay_image))

(defn cleanup!
  "Clean up text renderer resources."
  []
  (fiction/cleanup_text_renderer))

(defn initialized?
  "Check if text renderer is initialized."
  []
  (fiction/text_renderer_initialized))

;; =============================================================================
;; Dialogue Entry Type Mapping
;; =============================================================================

(def entry-type->int
  {:dialogue 0
   :narration 1
   :choice 2
   :choice-selected 3})

;; =============================================================================
;; Build Dialogue Vertices
;; =============================================================================

;; Simple ASCII uppercase to lowercase lookup
(def ^:private upper-to-lower
  {"A" "a" "B" "b" "C" "c" "D" "d" "E" "e" "F" "f" "G" "g"
   "H" "h" "I" "i" "J" "j" "K" "k" "L" "l" "M" "m" "N" "n"
   "O" "o" "P" "p" "Q" "q" "R" "r" "S" "s" "T" "t" "U" "u"
   "V" "v" "W" "w" "X" "x" "Y" "y" "Z" "z"})

(defn- simple-lowercase
  "Convert a simple ASCII string to lowercase."
  [s]
  (if (nil? s)
    nil
    (get upper-to-lower s s)))

(defn- get-speaker-color
  "Get color for a speaker based on metadata."
  [speaker]
  (let [metadata (state/get-metadata)
        colors (:colors metadata {})
        speakers (:speakers metadata {})
        ;; Speaker ID is already uppercase single char like "V" or "M"
        speaker-key (when speaker
                      (keyword speaker))
        speaker-first-char (when (and speaker (> (count speaker) 0))
                             (subs speaker 0 1))
        speaker-first-key (when speaker-first-char
                            (keyword speaker-first-char))
        matched-speaker-id (when speaker
                             (loop [entries (seq speakers)]
                               (if (empty? entries)
                                 nil
                                 (let [entry (first entries)
                                       k (key entry)
                                       v (val entry)]
                                   (if (= v speaker)
                                     k
                                     (recur (next entries)))))))]
    (or
        ;; Direct match by speaker token.
        (get colors speaker-key)
        ;; Try lowercase version
        (when speaker
          (let [lower-key (keyword (simple-lowercase speaker))]
            (get colors lower-key)))
        ;; If token is a full speaker name, try first letter token.
        (get colors speaker-first-key)
        (when speaker-first-char
          (let [first-lower-key (keyword (simple-lowercase speaker-first-char))]
            (get colors first-lower-key)))
        ;; Reverse lookup by metadata speaker display name.
        (when matched-speaker-id
          (or (get colors matched-speaker-id)
              (let [id-name (name matched-speaker-id)]
                (get colors (keyword (simple-lowercase id-name))))))
        [180 180 180])))  ;; Default grey

(defn- get-speaker-name
  "Get full speaker name from metadata. Falls back to speaker ID."
  [speaker-id]
  (if (nil? speaker-id)
    ""
    (let [metadata (state/get-metadata)
          speakers (:speakers metadata {})
          speaker-key (keyword speaker-id)]
      (or (get speakers speaker-key)
          speaker-id))))  ;; Fall back to the ID itself

(defn- add-history-entry!
  "Add a single history entry to C++ pending list."
  [entry]
  (let [entry-type (:type entry)
        type-int (cond
                   (= entry-type :choice) (if (:selected? entry) 3 2)
                   :else (get entry-type->int entry-type 1))
        speaker-id (:speaker entry)
        speaker-name (get-speaker-name speaker-id)
        text (or (:text entry) "")
        color (get-speaker-color speaker-id)
        ;; Defensive: ensure we have valid color values
        r (or (nth color 0 nil) 180)
        g (or (nth color 1 nil) 180)
        b (or (nth color 2 nil) 180)
        selected (:selected? entry false)]
    (fiction/add_history_entry
     type-int
     speaker-name
     text
     (cpp/float. (/ r 255.0))
     (cpp/float. (/ g 255.0))
     (cpp/float. (/ b 255.0))
     selected)))

(defn- add-choice-entry!
  "Add a single choice entry to C++ pending list."
  [choice selected-ids]
  (let [is-selected (contains? selected-ids (:id choice))]
    (fiction/add_choice_entry_with_selected (or (:text choice) "") is-selected)))

(defn build-dialogue-vertices!
  "Build text vertices from current dialogue state.
   Call this before recording render commands."
  []
  ;; Clear previous entries
  (fiction/clear_pending_entries)

  ;; Add all history entries
  (doseq [entry (state/get-history)]
    (add-history-entry! entry))

  ;; Add all available choices (marking already-selected ones)
  (let [selected-ids (state/get-selected-ids)]
    (doseq [choice (state/get-available-choices)]
      (add-choice-entry! choice selected-ids)))

  ;; Build vertices from pending entries
  (fiction/build_dialogue_from_pending))

;; =============================================================================
;; Render Commands
;; =============================================================================

;; Note: record_text_commands is called internally by fiction_engine during draw_frame
;; Not exposed to jank due to VkCommandBuffer boxing issues

;; =============================================================================
;; Scroll Control
;; =============================================================================

;; =============================================================================
;; Panel Customization
;; =============================================================================

(defn set-panel-colors!
  "Set the dialogue panel background color."
  [r g b a]
  (fiction/set_panel_colors
   (cpp/float. r) (cpp/float. g) (cpp/float. b) (cpp/float. a)))

(defn set-panel-position!
  "Set the dialogue panel position and width (as fractions of screen width).
   x: start position (0.0 = left, 1.0 = right)
   width: panel width (0.0 to 1.0)"
  [x width]
  (fiction/set_panel_position (cpp/float. x) (cpp/float. width)))


(defn update-mouse-position!
  "Update the mouse position for hover detection."
  [x y]
  (fiction/update_mouse_position (cpp/float. x) (cpp/float. y)))

(defn get-hovered-choice
  "Get the index of the currently hovered choice (-1 if none)."
  []
  (fiction/get_hovered_choice))

(defn scroll!
  "Scroll the dialogue panel by delta pixels."
  [delta]
  (fiction/scroll_dialogue (cpp/float. delta)))

(defn scroll-dialogue!
  "Scroll the dialogue panel by delta pixels."
  [delta]
  (fiction/scroll_dialogue (cpp/float. delta)))

(defn scroll-to-bottom!
  "Scroll to the bottom of the dialogue."
  []
  (fiction/scroll_to_bottom true))

;; =============================================================================
;; Getters
;; =============================================================================

(defn get-vertex-count
  "Get the number of text vertices to render."
  []
  (fiction/get_text_vertex_count))

;; =============================================================================
;; Mouse Interaction
;; =============================================================================

(defn update-mouse-position!
  "Update the mouse position for hover detection."
  [x y]
  (fiction/update_mouse_position (cpp/float. x) (cpp/float. y)))

(defn get-hovered-choice
  "Get the index of the currently hovered choice (-1 if none)."
  []
  (fiction/get_hovered_choice))

(defn get-clicked-choice
  "Get the index of the clicked choice (-1 if none)."
  []
  (fiction/get_clicked_choice))

;; =============================================================================
;; Debug
;; =============================================================================

(defn debug-pending-counts
  "Print pending entry counts for debugging."
  []
  (println "Pending history:" (fiction/get_pending_history_count))
  (println "Pending choices:" (fiction/get_pending_choices_count)))
