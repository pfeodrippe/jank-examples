(ns vybe.flecs
  (:require
   ["flecs.h" :as fl :scope ""]
   [vybe.type :as vt]))

;; =============================================================================
;; C++ helpers for Flecs operations
;; IMPORTANT: Keep all cpp/raw in one block per namespace, at the top of the file
;; =============================================================================
(cpp/raw "
// Create entity with a name (symbol) - used by eid function
ecs_entity_t vybe_create_entity_with_name(ecs_world_t* w, jank::runtime::object_ref name_obj) {
  auto name_str = jank::runtime::to_string(name_obj);
  ecs_entity_desc_t desc = {};
  desc.name = name_str.c_str();
  ecs_entity_t e = ecs_entity_init(w, &desc);
  // Also set symbol for lookup
  if (e > 0) {
    ecs_set_symbol(w, e, name_str.c_str());
  }
  return e;
}

jank::runtime::object_ref vybe_query_entities(ecs_world_t* w, ecs_query_t* q) {
  jank::runtime::object_ref result = jank::runtime::make_box<jank::runtime::obj::persistent_vector>();
  ecs_iter_t it = ecs_query_iter(w, q);
  while (ecs_query_next(&it)) {
    for (int i = 0; i < it.count; i++) {
      ecs_entity_t entity = it.entities[i];
      result = jank::runtime::conj(result, jank::runtime::make_box(static_cast<int64_t>(entity)));
    }
  }
  return result;
}

// Query entities using a runtime string (not compile-time literal)
jank::runtime::object_ref vybe_query_entities_str(ecs_world_t* w, const char* query_str) {
  ecs_query_desc_t desc = {};
  desc.expr = query_str;
  ecs_query_t* q = ecs_query_init(w, &desc);
  if (!q) {
    return jank::runtime::make_box<jank::runtime::obj::persistent_vector>();
  }
  jank::runtime::object_ref result = jank::runtime::make_box<jank::runtime::obj::persistent_vector>();
  ecs_iter_t it = ecs_query_iter(w, q);
  while (ecs_query_next(&it)) {
    for (int i = 0; i < it.count; i++) {
      ecs_entity_t entity = it.entities[i];
      result = jank::runtime::conj(result, jank::runtime::make_box(static_cast<int64_t>(entity)));
    }
  }
  ecs_query_fini(q);
  return result;
}

// =============================================================================
// World/Entity helpers for map interface
// =============================================================================

// Check if entity is alive
bool vybe_entity_alive(ecs_world_t* w, ecs_entity_t e) {
  return ecs_is_alive(w, e);
}

// Get entity name (symbol)
const char* vybe_entity_name(ecs_world_t* w, ecs_entity_t e) {
  const char* name = ecs_get_symbol(w, e);
  return name ? name : \"\";
}

// Get entity type string (all components/tags)
const char* vybe_type_str(ecs_world_t* w, ecs_entity_t e) {
  const ecs_type_t* type = ecs_get_type(w, e);
  if (!type) return \"\";
  return ecs_type_str(w, type);
}

// Check if entity has a component/tag
bool vybe_has_id(ecs_world_t* w, ecs_entity_t e, ecs_entity_t id) {
  return ecs_has_id(w, e, id);
}

// Check if an ID is a tag (no data, just a marker)
bool vybe_is_tag(ecs_world_t* w, ecs_entity_t id) {
  const ecs_type_info_t* ti = ecs_get_type_info(w, id);
  return ti == nullptr || ti->size == 0;
}

// Remove component/tag from entity
void vybe_remove_id(ecs_world_t* w, ecs_entity_t e, ecs_entity_t id) {
  ecs_remove_id(w, e, id);
}

// Delete entity
void vybe_delete_entity(ecs_world_t* w, ecs_entity_t e) {
  ecs_delete(w, e);
}

// Get all entity IDs (components/tags) as a vector
jank::runtime::object_ref vybe_entity_ids(ecs_world_t* w, ecs_entity_t e) {
  jank::runtime::object_ref result = jank::runtime::make_box<jank::runtime::obj::persistent_vector>();
  const ecs_type_t* type = ecs_get_type(w, e);
  if (!type) return result;

  for (int i = 0; i < type->count; i++) {
    ecs_entity_t id = type->array[i];
    result = jank::runtime::conj(result, jank::runtime::make_box(static_cast<int64_t>(id)));
  }
  return result;
}

// Get all named entities in the world
jank::runtime::object_ref vybe_all_named_entities(ecs_world_t* w) {
  jank::runtime::object_ref result = jank::runtime::make_box<jank::runtime::obj::persistent_vector>();
  // Query for entities that have names (EcsIdentifier)
  ecs_query_desc_t desc = {};
  desc.expr = \"$this != 0\";  // Match all entities
  ecs_query_t* q = ecs_query_init(w, &desc);
  if (!q) return result;

  ecs_iter_t it = ecs_query_iter(w, q);
  while (ecs_query_next(&it)) {
    for (int i = 0; i < it.count; i++) {
      ecs_entity_t e = it.entities[i];
      // Only include entities with a symbol (user-created with names)
      const char* sym = ecs_get_symbol(w, e);
      if (sym && sym[0] != '\\0') {
        result = jank::runtime::conj(result, jank::runtime::make_box(static_cast<int64_t>(e)));
      }
    }
  }
  ecs_query_fini(q);
  return result;
}

// Convert a pointer to int64 for use as a stable cache key
int64_t vybe_ptr_to_int64(ecs_world_t* ptr) {
  return reinterpret_cast<int64_t>(ptr);
}

// Create a pair from two entity IDs
ecs_entity_t vybe_ecs_pair(ecs_entity_t first, ecs_entity_t second) {
  return ecs_pair(first, second);
}

// Get EcsChildOf constant
ecs_entity_t vybe_EcsChildOf() {
  return EcsChildOf;
}

// Get children iterator for an entity
jank::runtime::object_ref vybe_children_ids(ecs_world_t* w, ecs_entity_t parent) {
  jank::runtime::object_ref result = jank::runtime::make_box<jank::runtime::obj::persistent_vector>();
  ecs_iter_t it = ecs_children(w, parent);
  while (ecs_children_next(&it)) {
    for (int i = 0; i < it.count; i++) {
      ecs_entity_t child = it.entities[i];
      result = jank::runtime::conj(result, jank::runtime::make_box(static_cast<int64_t>(child)));
    }
  }
  return result;
}
")

;; =============================================================================
;; Builtin Flecs entity IDs
;; =============================================================================

(def EcsChildOf
  "The EcsChildOf builtin relationship entity ID."
  (cpp/vybe_EcsChildOf))

;; Builtin entities map for keyword -> ID lookup
(def builtin-entities
  "Map of builtin Flecs entities."
  {:vf/child-of EcsChildOf})

;; =============================================================================
;; Path function for hierarchical entity names
;; =============================================================================

(defn path
  "Builds a path string from a sequence of entity names/ids.
   Uses '#id.name' format for numeric parent IDs.
   E.g. (path [:sun :mercury]) => \"sun.mercury\"
        (path [123 :mercury]) => \"#123.mercury\""
  [ks]
  (apply str
    (interpose "."
      (map (fn [v]
             (cond
               (int? v) (str "#" v)
               (keyword? v) (vt/mangle-keyword v)
               (string? v) v
               :else (str v)))
           ks))))

;; =============================================================================
;; defn* macro - for functions that return native C++ types
;; =============================================================================

(defmacro defn*
  "Define a function that returns a native C++ type.
   When :tag metadata specifies a native type, generates a macro
   that inlines the body and wraps the result in cpp/unbox.

   This is needed because jank functions must return object_ref due to
   virtual dispatch, but we often need to return native types for C interop.

   Usage:
     (defn* ^{:tag \"ecs_world_t*\"} world-ptr [world]
       world)

   Expands to a macro that inlines: (cpp/unbox (cpp/type \"ecs_world_t*\") world)"
  [name & body]
  (let [m (meta name)
        tag (:tag m)
        ;; Parse optional docstring
        [docstring params forms] (if (string? (first body))
                                   [(first body) (second body) (drop 2 body)]
                                   [nil (first body) (rest body)])]
    (if tag
      ;; Generate a macro that wraps body result in cpp/unbox
      `(defmacro ~(with-meta name (dissoc m :tag))
         ~@(when docstring [docstring])
         ~params
         (list (quote cpp/unbox)
               (list (quote cpp/type) ~tag)
               ~@forms))
      ;; No tag, just use regular defn
      `(defn ~name ~@body))))

;; =============================================================================
;; Flecs C API wrappers for jank
;; =============================================================================

;; World management
(defn- ^{:tag "ecs_world_t*"} -make-world
  "Create a new Flecs world (internal, returns boxed pointer)."
  []
  (cpp/box (fl/ecs_init)))

(defn ^{:tag "ecs_world_t*"} make-world-mini
  "Create a minimal Flecs world using ecs_mini (faster, no addons).
   Returns a boxed ecs_world_t* - use (cpp/unbox (make-world-mini)) to get raw pointer."
  []
  (cpp/box (fl/ecs_mini)))

(defn get-world-box
  "Get the boxed world pointer from a world (either raw box or user type)."
  [world]
  ;; Try to get :vf/world-box - if it returns non-nil, use that, otherwise assume world is already a box
  (let [wb (get world :vf/world-box)]
    (if wb
      wb
      world)))

(defn destroy-world!
  "Destroy a Flecs world."
  [world]
  (fl/ecs_fini (cpp/unbox (cpp/type "ecs_world_t*") (get-world-box world)))
  nil)

(defmacro world-ptr
  "Extract ecs_world_t* from boxed world. Returns raw pointer for use in C calls."
  [world]
  `(cpp/unbox (cpp/type "ecs_world_t*") (get-world-box ~world)))

;; Entity management
(defn eid
  "Get entity ID from various entity representations.

   Single arity (VybeFlecsEntity only):
     (eid entity) - extracts :vf/entity-id from entity

   Two arity (world + entity designator):
     (eid world e) - resolves e to an entity ID, auto-creating if needed

   Supported entity designators:
   - Integer: returned as-is
   - VybeFlecsEntity: extracts :vf/entity-id
   - Keyword: mangled and looked up/created (e.g. :my-tag -> \"my_tag\")
   - String: looked up/created by name
   - Vector pair: creates a Flecs pair (e.g. [:vf/child-of :parent])"
  ([e]
   ;; Single arity - only works for VybeFlecsEntity or integers
   (cond
     (int? e) e
     (some? (get e :vf/entity-id)) (get e :vf/entity-id)
     :else (throw (ex-info "Single-arity eid requires VybeFlecsEntity or integer" {:e e}))))
  ([world e]
   (cond
     (int? e) e

     ;; VybeFlecsEntity user type - extract entity ID directly
     ;; Use `get` instead of `contains?` because user types may not implement contains properly
     (some? (get e :vf/entity-id))
     (get e :vf/entity-id)

     ;; Vector - treat as a pair (e.g. [:vf/child-of :parent])
     (vector? e)
     (let [first-elem (first e)
           second-elem (second e)
           first-id (eid world first-elem)
           second-id (eid world second-elem)]
       (cpp/vybe_ecs_pair first-id second-id))

     ;; Keyword - check builtins first, then lookup/create
     (keyword? e)
     (if-let [builtin-id (get builtin-entities e)]
       builtin-id
       (let [w (world-ptr world)
             tag-name (vt/mangle-keyword e)
             existing-id (fl/ecs_lookup w tag-name)]
         (if (> existing-id 0)
           existing-id
           (cpp/vybe_create_entity_with_name w tag-name))))

     ;; String - lookup/create by name
     (string? e)
     (let [w (world-ptr world)
           existing-id (fl/ecs_lookup w e)]
       (if (> existing-id 0)
         existing-id
         (cpp/vybe_create_entity_with_name w e)))

     :else (throw (ex-info "Unsupported entity type" {:e e})))))

(defn new-entity
  "Create a new entity in the world."
  [world]
  (fl/ecs_new (world-ptr world)))

(defn new-entity-named
  "Create a new named entity in the world."
  [world entity-name]
  (fl/ecs_entity_init
   (world-ptr world)
   (cpp/& (cpp/value "ecs_entity_desc_t{.name = nullptr}"))))

(comment

  (let [desc (cpp/new fl/ecs_entity_desc_t)]
    (cpp/= (cpp/.-name desc) #cpp "ddd")
    (-> desc cpp/* cpp/.-name))

  (let [desc (cpp/new fl/ecs_entity_desc_t)]
    (cpp/= (cpp/.-name (cpp/* desc)) (cpp/static_cast cpp/const_char* #cpp "ddd"))
    nil)

  (cpp/raw "
  void set_entity_name(ecs_entity_desc_t* desc, const char* name) {
    desc->name = name;
  }
  ")

  (let [desc (cpp/new fl/ecs_entity_desc_t)]
    (cpp/set_entity_name desc "ddd")
    (-> desc cpp/* cpp/.-name))

  ())

;; Component registration
;; NOTE: Commented out due to cpp/value requiring literal strings
;; TODO: Fix this using cpp/raw or a different approach
#_(defn register-component
  "Register a component type with the given name and size.
   Returns the component entity ID."
  [world component-name size alignment]
  (let [w (world-ptr world)
        ;; Create entity for the component
        entity-id (fl/ecs_entity_init
                   w
                   (cpp/& (cpp/value "ecs_entity_desc_t{}")))
        ;; Register as component with size info
        comp-id (fl/ecs_component_init
                 w
                 (cpp/& (cpp/value
                         (str "ecs_component_desc_t{.entity = " entity-id
                              ", .type = {.size = " size
                              ", .alignment = " alignment "}}"))))]
    comp-id))

;; =============================================================================
;; System API
;; =============================================================================

(defn system-run
  "Run a system by its entity ID with delta time."
  ([world system-id]
   (system-run world system-id 0.0))
  ([world system-id delta-time]
   (fl/ecs_run (world-ptr world)
               (if (keyword? system-id)
                 (eid world system-id)
                 system-id)
               (cpp/float. delta-time)
               (cpp/value "nullptr"))
   nil))

(defn progress
  "Advance the world by delta-time, running all systems in the pipeline."
  ([world]
   (progress world 0.0))
  ([world delta-time]
   (fl/ecs_progress (world-ptr world) (cpp/float. delta-time))))

;; =============================================================================
;; Query iteration helpers
;; These are building blocks for with-system
;; =============================================================================

;; Query creation - requires literal string due to cpp/value limitation
(defmacro query-str
  "Create a query from a Flecs DSL string literal.
   NOTE: query-string must be a compile-time literal, not a runtime value.
   Example: (query-str world \"Position, Velocity\")"
  [world query-string]
  `(cpp/box
    (fl/ecs_query_init
     (world-ptr ~world)
     (cpp/& (cpp/value ~(str "ecs_query_desc_t{.expr = \"" query-string "\"}"))))))

;; These return native types directly from C calls - use defmacro to inline
(defmacro query-iter
  "Get an iterator for a query. Returns ecs_iter_t (native struct)."
  [world query]
  `(fl/ecs_query_iter
    (world-ptr ~world)
    (cpp/unbox (cpp/type "ecs_query_t*") ~query)))

(defmacro iter-next
  "Advance the iterator. Returns true if there are more results."
  [iter]
  `(fl/ecs_query_next (cpp/& ~iter)))

(defmacro iter-count
  "Get the number of entities in the current iterator table."
  [iter]
  `(cpp/.-count ~iter))

(defmacro iter-entities
  "Get the entities array from the iterator."
  [iter]
  `(cpp/.-entities ~iter))

(defmacro iter-entity-at
  "Get entity ID at index from iterator."
  [iter idx]
  `(cpp/aget (iter-entities ~iter) (cpp/int. ~idx)))

;; =============================================================================
;; Query helpers
;; =============================================================================

(defmacro query-entities
  "Return all entities matching a query string as a vector.
   NOTE: query-string must be a compile-time literal.

   Example:
     (doseq [e (query-entities world \"TestTag\")]
       (println \"Entity:\" e))"
  [world query-string]
  `(cpp/vybe_query_entities (world-ptr ~world)
                            (cpp/unbox (cpp/type "ecs_query_t*") (query-str ~world ~query-string))))

(defn query-entities-runtime
  "Return all entities matching a query string as a vector.
   Unlike query-entities, this accepts runtime-computed query strings."
  [world query-string]
  (cpp/vybe_query_entities_str (world-ptr world) query-string))

;; with-query matches vybe's interface: (with-query world [p Position, v Velocity, e :vf/entity] body...)
;; Component values in bindings become query terms and bind component data
;; String values are query terms (for backward compat), :vf/entity binds the entity ID
(defmacro with-query
  "Iterate over query results with automatic component binding.

   world    - the Flecs world
   bindings - pairs of [sym spec], where:
              - Component (e.g. Position) becomes a query term and binds component data
              - String spec becomes a query term (use _ to ignore binding)
              - :vf/entity binds the entity ID
   body     - forms to execute for each matched entity

   Example:
     (with-query world [p Position, v Velocity, e :vf/entity]
       (merge p {:x (+ (:x p) (:dx v))}))

   Within the body, `merge` is shadowed to automatically handle component refs,
   updating native memory when merging into component bindings.

   This is the jank equivalent of:
     q.each([](flecs::entity e, Position& p, const Velocity& v) { ... });"
  [world bindings & body]
  (let [binding-pairs (partition 2 bindings)
        ;; Identify component bindings (not string, not keyword, not :vf/entity)
        is-component? (fn [spec] (and (not (string? spec))
                                      (not (keyword? spec))))
        ;; Identify tag bindings (keywords that are not :vf/entity)
        is-tag? (fn [spec] (and (keyword? spec)
                                (not (= :vf/entity spec))))
        ;; Extract tag keywords for auto-registration
        tag-keywords (->> binding-pairs
                          (map second)
                          (filter is-tag?))
        ;; Extract component bindings for later get-comp calls
        comp-bindings (->> binding-pairs
                           (filter #(is-component? (second %))))
        ;; Build query terms from strings, keywords (tags), and component names
        query-terms (->> binding-pairs
                         (map second)
                         (filter #(or (string? %) (is-tag? %) (is-component? %))))
        ;; Extract entity binding (where value is :vf/entity)
        entity-binding (->> binding-pairs
                            (filter #(= :vf/entity (second %)))
                            first
                            first)
        entity-sym (or entity-binding (gensym "entity__"))]
    (when (empty? query-terms)
      (throw (ex-info "with-query requires at least one query term" {:bindings bindings})))
    `(do
       ;; Ensure all tag keywords exist as entities before querying (using eid for auto-registration)
       ~@(map (fn [kw] `(eid ~world ~kw)) tag-keywords)
       (let [entities# (query-entities-runtime ~world (vybe.type/build-query-string [~@query-terms]))]
         (mapv (fn [~entity-sym]
                 (let [~@(mapcat (fn [[sym comp]]
                                   [sym `(vt/get-comp ~world ~entity-sym ~comp)])
                                 comp-bindings)]
                   ~@body))
               entities#)))))

;; =============================================================================
;; Component field access helpers
;; =============================================================================

;; These return native pointers - use defmacro to inline
(defmacro field-ptr
  "Get pointer to component data at field index in iterator.
   field-index is 0-based (first component in query = 0)."
  [iter field-index size]
  `(fl/ecs_field_w_size (cpp/& ~iter) (cpp/size_t. ~size) (cpp/int. (inc ~field-index))))

(defmacro field-at
  "Get component data pointer for entity at idx in the current iterator table."
  [iter field-index size idx]
  `(let [base-ptr# (field-ptr ~iter ~field-index ~size)]
     (cpp/+ base-ptr# (cpp/* (cpp/size_t. ~idx) (cpp/size_t. ~size)))))

;; =============================================================================
;; VybeFlecsWorld and VybeFlecsEntity - Map interface for Flecs
;; =============================================================================

;; Forward declarations
(declare -create-vybe-flecs-entity)
(declare --set-entity-component)
(declare -world-get-entity)

;; Helper functions for entity management
(defn type-str
  "Get the type string showing all components/tags of an entity."
  [entity-or-world-entity]
  (if (contains? entity-or-world-entity :vf/world-box)
    ;; It's an entity user type
    (let [w-box (:vf/world-box entity-or-world-entity)
          e-id (:vf/entity-id entity-or-world-entity)]
      (cpp/vybe_type_str (cpp/unbox (cpp/type "ecs_world_t*") w-box) e-id))
    ;; Assume it's a world and entity pair
    entity-or-world-entity))

(defn get-rep
  "Get the keyword representation of an entity."
  [entity]
  (when (contains? entity :vf/world-box)
    (let [w-box (:vf/world-box entity)
          e-id (:vf/entity-id entity)
          name-str (cpp/vybe_entity_name (cpp/unbox (cpp/type "ecs_world_t*") w-box) e-id)]
      (when (and name-str (not= name-str ""))
        (keyword name-str)))))

(defn entity-alive?
  "Check if an entity is alive."
  [world entity-id]
  (cpp/vybe_entity_alive (world-ptr world) entity-id))

(defn entity-ids
  "Get all component/tag IDs for an entity as a vector."
  [world entity-id]
  (cpp/vybe_entity_ids (world-ptr world) entity-id))

(defn all-named-entities
  "Get all named entities in the world."
  [world]
  (cpp/vybe_all_named_entities (world-ptr world)))

(defn children-ids
  "Get all child entity IDs for a given parent entity."
  [world parent-entity-id]
  (cpp/vybe_children_ids (world-ptr world) parent-entity-id))

(defn is-tag?
  "Check if an ID represents a tag (no data)."
  [world id]
  (cpp/vybe_is_tag (world-ptr world) id))

(defn has-id?
  "Check if an entity has a component/tag ID."
  [world entity-id comp-id]
  (cpp/vybe_has_id (world-ptr world) entity-id comp-id))

(defn remove-id!
  "Remove a component or tag from an entity.
   entity can be a VybeFlecsEntity user type or entity ID.
   tag-or-comp can be a keyword (tag name) or component ID."
  [entity tag-or-comp]
  (let [w-box (:vf/world-box entity)
        e-id (:vf/entity-id entity)
        w (cpp/unbox (cpp/type "ecs_world_t*") w-box)]
    (cond
      (keyword? tag-or-comp)
      (let [c-id (fl/ecs_lookup w (name tag-or-comp))]
        (when (> c-id 0)
          (cpp/vybe_remove_id w e-id c-id)))

      (int? tag-or-comp)
      (cpp/vybe_remove_id w e-id tag-or-comp)

      :else nil)
    entity))

;; -----------------------------------------------------------------------------
;; VybeFlecsEntity User Type
;; Represents an entity in the world, acts like a set of components/tags
;; -----------------------------------------------------------------------------

(defn- --entity-to-string
  "Create string representation of entity for printing."
  [w-box e-id]
  (let [w (cpp/unbox (cpp/type "ecs_world_t*") w-box)
        name-str (cpp/vybe_entity_name w e-id)
        type-str-val (cpp/vybe_type_str w e-id)]
    (str "#{" (if (and name-str (not= name-str ""))
                (str ":" name-str " ")
                "")
         type-str-val "}")))

(defn- --entity-seq
  "Get all components/tags as a sequence."
  [world w-box e-id]
  (let [ids (entity-ids world e-id)]
    (mapv (fn [id]
            (let [w (cpp/unbox (cpp/type "ecs_world_t*") w-box)
                  name-str (cpp/vybe_entity_name w id)]
              (if (and name-str (not= name-str ""))
                (if (is-tag? world id)
                  ;; Tag - return as keyword
                  (keyword name-str)
                  ;; Component - return component instance with name
                  (let [comp-desc (vt/resolve-descriptor-by-name name-str)]
                    (if comp-desc
                      ;; Known component - return the component map
                      (vt/get-comp world e-id comp-desc)
                      ;; Unknown - just return keyword
                      (keyword name-str))))
                ;; No name - return raw ID
                id)))
          ids)))

(defn- -create-vybe-flecs-entity-user-type
  "Create the user type factory for VybeFlecsEntity."
  []
  (cpp/jank.runtime.make_user_type
   "VybeFlecsEntity"
   (fn [{:keys [world-box entity-id get-world-fn]}]
     {:get (fn [this k]
             (cond
               ;; Internal metadata access
               (= k :vf/world-box) world-box
               (= k :vf/entity-id) entity-id
               (= k :vf/id) entity-id

               ;; Component/tag lookup
               :else
               (let [w (cpp/unbox (cpp/type "ecs_world_t*") world-box)
                     world (get-world-fn)]
                 (cond
                   ;; Keyword - could be a tag or lookup by name
                   (keyword? k)
                   (let [c-id (fl/ecs_lookup w (name k))]
                     (when (and (> c-id 0) (cpp/vybe_has_id w entity-id c-id))
                       (if (cpp/vybe_is_tag w c-id)
                         k  ; It's a tag, return the keyword
                         ;; It's a component, get its value
                         (let [comp-desc (vt/resolve-descriptor-by-name (name k))]
                           (if comp-desc
                             (vt/get-comp world entity-id comp-desc)
                             k)))))

                   ;; Integer - raw component ID
                   (int? k)
                   (when (cpp/vybe_has_id w entity-id k)
                     (if (cpp/vybe_is_tag w k)
                       (let [name-str (cpp/vybe_entity_name w k)]
                         (if (and name-str (not= name-str ""))
                           (keyword name-str)
                           k))
                       ;; Component - try to get value
                       (let [name-str (cpp/vybe_entity_name w k)
                             comp-desc (when (and name-str (not= name-str ""))
                                         (vt/resolve-descriptor-by-name name-str))]
                         (if comp-desc
                           (vt/get-comp world entity-id comp-desc)
                           k))))

                   ;; Component constructor function
                   :else
                   (let [comp-desc (vt/resolve-descriptor k)]
                     (when comp-desc
                       (let [c-id (fl/ecs_lookup w (:name comp-desc))]
                         (when (and (> c-id 0) (cpp/vybe_has_id w entity-id c-id))
                           (vt/get-comp world entity-id comp-desc)))))))))

      :contains (fn [this k]
                  (cond
                    (or (= k :vf/world-box) (= k :vf/entity-id) (= k :vf/id)) true
                    :else
                    (let [w (cpp/unbox (cpp/type "ecs_world_t*") world-box)]
                      (cond
                        (keyword? k)
                        (let [c-id (fl/ecs_lookup w (name k))]
                          (and (> c-id 0) (cpp/vybe_has_id w entity-id c-id)))

                        (int? k)
                        (cpp/vybe_has_id w entity-id k)

                        :else
                        (let [comp-desc (vt/resolve-descriptor k)]
                          (when comp-desc
                            (let [c-id (fl/ecs_lookup w (:name comp-desc))]
                              (and (> c-id 0) (cpp/vybe_has_id w entity-id c-id)))))))))

      :count (fn [this]
               (count (entity-ids (get-world-fn) entity-id)))

      :to-string (fn [this]
                   (--entity-to-string world-box entity-id))

      ;; assoc - set a component on the entity
      :assoc (fn [this k v]
               (let [world (get-world-fn)]
                 (--set-entity-component world entity-id k v))
               this)

      ;; conj - add a tag or component (for set-like behavior)
      :conj (fn [this entry]
              (let [world (get-world-fn)]
                (cond
                  ;; Keyword tag
                  (keyword? entry)
                  (let* [w (cpp/unbox (cpp/type "ecs_world_t*") world-box)
                         tag-id (eid world entry)
                         _ (fl/ecs_add_id w entity-id tag-id)]
                    nil)

                  ;; Component instance (user type with :vt/comp)
                  (contains? entry :vt/comp)
                  (let [comp-desc (:vt/comp entry)]
                    ;; Copy component data to entity
                    (vt/add-comp! world entity-id comp-desc entry))

                  ;; Vector [component value-or-tag] or just [tags...]
                  (vector? entry)
                  (doall
                    (map (fn [item]
                           (cond
                             (nil? item) nil  ; Skip nil entries
                             (keyword? item)
                             (let* [w (cpp/unbox (cpp/type "ecs_world_t*") world-box)
                                    tag-id (eid world item)
                                    _ (fl/ecs_add_id w entity-id tag-id)]
                               nil)
                             (contains? item :vt/comp)
                             (vt/add-comp! world entity-id (:vt/comp item) item)
                             :else nil))
                         entry))

                  :else nil))
              this)

      ;; disj - remove a tag or component (for disj)
      :disj (fn [this k]
                 (let [w (cpp/unbox (cpp/type "ecs_world_t*") world-box)]
                   (cond
                     (keyword? k)
                     (let [c-id (fl/ecs_lookup w (name k))]
                       (when (> c-id 0)
                         (cpp/vybe_remove_id w entity-id c-id)))

                     (int? k)
                     (cpp/vybe_remove_id w entity-id k)

                     :else
                     (let [comp-desc (vt/resolve-descriptor k)]
                       (when comp-desc
                         (let [c-id (fl/ecs_lookup w (:name comp-desc))]
                           (when (> c-id 0)
                             (cpp/vybe_remove_id w entity-id c-id)))))))
                 this)

      ;; seq - iterate over components/tags
      :seq (fn [this]
             (--entity-seq (get-world-fn) world-box entity-id))})))

(defn- -create-vybe-flecs-entity
  "Create a VybeFlecsEntity user type instance."
  [world w-box entity-id]
  ;; Create fresh factory each time to avoid stale JIT function references
  (let [factory (-create-vybe-flecs-entity-user-type)]
    (factory {:world-box w-box
              :entity-id entity-id
              :get-world-fn (fn [] world)})))

;; Helper for entity set operations
(defn- --set-entity-component
  "Set a component value on an entity."
  [world entity-id comp-or-key value]
  (let [w (world-ptr world)]
    (cond
      ;; Keyword tag (no value or value is the key itself)
      (and (keyword? comp-or-key) (keyword? value))
      (let* [tag-id (fl/ecs_lookup w (name value))
             _ (when (= tag-id 0)
                 ;; Create new tag entity
                 (fl/ecs_entity_init w (cpp/& (cpp/value "ecs_entity_desc_t{}"))))
             _ (fl/ecs_add_id w entity-id (eid world value))]
        nil)

      ;; Component instance (user type)
      (contains? value :vt/comp)
      (vt/add-comp! world entity-id (:vt/comp value) value)

      ;; Component descriptor + map values
      (map? value)
      (let [comp-desc (vt/resolve-descriptor comp-or-key)]
        (when comp-desc
          (vt/add-comp! world entity-id comp-desc value)))

      :else nil)))

;; -----------------------------------------------------------------------------
;; VybeFlecsWorld User Type
;; Represents a Flecs world, acts like a map of entity-name -> entity
;; -----------------------------------------------------------------------------

(defn- -world-to-string
  "Create string representation of world for printing."
  [w-box]
  (let [entities (cpp/vybe_all_named_entities (cpp/unbox (cpp/type "ecs_world_t*") w-box))
        count (count entities)]
    (str "#VybeFlecsWorld{:entity-count " count "}")))

(defn- -world-get-entity
  "Get or create an entity wrapper for a name/id.
   Supports:
   - Entity user type (passed through)
   - Integer entity ID
   - Keyword or string (lookup by name)
   - Vector path (e.g. [:sun :mercury] -> lookup 'sun.mercury')"
  [world w-box e-name-or-id]
  (let [w (cpp/unbox (cpp/type "ecs_world_t*") w-box)]
    (cond
      ;; Already an entity user type
      (contains? e-name-or-id :vf/entity-id)
      e-name-or-id

      ;; Integer entity ID
      (int? e-name-or-id)
      (when (cpp/vybe_entity_alive w e-name-or-id)
        (-create-vybe-flecs-entity world w-box e-name-or-id))

      ;; Vector path - lookup by hierarchical name (e.g. [:sun :mercury] -> "sun.mercury")
      (vector? e-name-or-id)
      (let [path-str (path e-name-or-id)
            e-id (fl/ecs_lookup w path-str)]
        (when (> e-id 0)
          (-create-vybe-flecs-entity world w-box e-id)))

      ;; Keyword or string - lookup by name
      (or (keyword? e-name-or-id) (string? e-name-or-id))
      (let [name-str (if (keyword? e-name-or-id) (name e-name-or-id) e-name-or-id)
            e-id (fl/ecs_lookup_symbol w name-str (cpp/bool. true) (cpp/bool. false))]
        (when (> e-id 0)
          (-create-vybe-flecs-entity world w-box e-id)))

      :else nil)))

(declare -world-set-entity!)

(defn- -add-item-to-entity!
  "Add a single component/tag to an entity. Helper to avoid closure issues.
   Handles:
   - nil: ignored
   - keyword: tag
   - component instance (has :vt/comp): component data
   - vector pair (e.g. [:vf/child-of :parent]): add relationship pair
   - map: nested children definitions"
  [world w-box e-id item]
  (cond
    (nil? item) nil

    ;; Keyword - add as tag
    (keyword? item)
    (let* [w (cpp/unbox (cpp/type "ecs_world_t*") w-box)
           tag-name (vt/mangle-keyword item)
           ;; First try to look up existing tag entity
           existing-id (fl/ecs_lookup w tag-name)
           ;; If not found, create it using our helper
           tag-id (if (> existing-id 0)
                    existing-id
                    (cpp/vybe_create_entity_with_name w tag-name))
           _ (fl/ecs_add_id w e-id tag-id)]
      nil)

    ;; Component instance (has :vt/comp metadata)
    (contains? item :vt/comp)
    (vt/add-comp! world e-id (:vt/comp item) item)

    ;; Vector - treat as a pair (e.g. [:vf/child-of :parent])
    (vector? item)
    (let* [w (cpp/unbox (cpp/type "ecs_world_t*") w-box)
           pair-id (eid world item)
           _ (fl/ecs_add_id w e-id pair-id)]
      nil)

    ;; Map - nested children definitions
    ;; {:mercury [:planet (Position {:x 1})] :venus [:planet]}
    (map? item)
    (doall
      (map (fn [[child-name child-components]]
             ;; Create child entity with path name (e.g. "sun.mercury")
             ;; and add ChildOf relationship
             (let* [child-path-str (path [e-id child-name])
                    child-id (-world-set-entity! world w-box child-path-str
                               ;; Prepend ChildOf relationship to child's components
                               (vec (cons [:vf/child-of e-id]
                                          (if (vector? child-components)
                                            child-components
                                            [child-components]))))]
               child-id))
           item))

    :else nil))

(defn- -world-set-entity!
  "Set components/tags on an entity (creating if needed)."
  [world w-box e-name components]
  (let* [w (cpp/unbox (cpp/type "ecs_world_t*") w-box)
         ;; Get or create entity
         name-str (cond
                    (keyword? e-name) (name e-name)
                    (string? e-name) e-name
                    (contains? e-name :vf/entity-id) nil  ; Already an entity
                    :else nil)
         e-id (if name-str
                ;; Named entity - lookup or create
                (let [existing-id (fl/ecs_lookup_symbol w name-str (cpp/bool. true) (cpp/bool. false))]
                  (if (> existing-id 0)
                    existing-id
                    ;; Create new entity with name using C++ helper
                    (cpp/vybe_create_entity_with_name w name-str)))
                ;; Entity reference - get ID
                (if (contains? e-name :vf/entity-id)
                  (:vf/entity-id e-name)
                  e-name))]
    ;; Add components/tags
    (when (and (> e-id 0) components)
      (cond
        ;; Vector of components/tags
        (vector? components)
        (doall (map (fn [item] (-add-item-to-entity! world w-box e-id item)) components))

        ;; Single keyword tag
        (keyword? components)
        (-add-item-to-entity! world w-box e-id components)

        ;; Component instance
        (contains? components :vt/comp)
        (vt/add-comp! world e-id (:vt/comp components) components)

        :else nil))
    e-id))

(defn- -create-vybe-flecs-world-user-type
  "Create the user type factory for VybeFlecsWorld."
  []
  (cpp/jank.runtime.make_user_type
   "VybeFlecsWorld"
   (fn [{:keys [world-box]}]
     (let [get-self (fn [] nil)]  ; Will be replaced with actual reference
       {:get (fn [this k]
               (cond
                 ;; Internal metadata access - both return boxed values
                 (= k :vf/world-box) world-box
                 (= k :vf/world-ptr) world-box  ; Return boxed ptr, caller can unbox
                 ;; Entity lookup
                 :else
                 (-world-get-entity this world-box k)))

        :contains (fn [this k]
                    (cond
                      (or (= k :vf/world-box) (= k :vf/world-ptr)) true
                      :else
                      (let [w (cpp/unbox (cpp/type "ecs_world_t*") world-box)]
                        (cond
                          (int? k)
                          (cpp/vybe_entity_alive w k)

                          (or (keyword? k) (string? k))
                          (let [name-str (if (keyword? k) (name k) k)
                                e-id (fl/ecs_lookup_symbol w name-str (cpp/bool. true) (cpp/bool. false))]
                            (> e-id 0))

                          :else false))))

        :count (fn [this]
                 (count (cpp/vybe_all_named_entities (cpp/unbox (cpp/type "ecs_world_t*") world-box))))

        :to-string (fn [this]
                     (-world-to-string world-box))

        ;; assoc - set entity with components
        :assoc (fn [this k v]
                 (-world-set-entity! this world-box k v)
                 this)

        ;; conj - for merge support (takes a map entry or map)
        :conj (fn [this entry]
                (if (map? entry)
                  ;; merge calls conj with a map - iterate entries
                  (doseq [[k v] entry]
                    (-world-set-entity! this world-box k v))
                  ;; Single [k v] pair
                  (let [[k v] entry]
                    (-world-set-entity! this world-box k v)))
                this)

        ;; dissoc - delete entity
        :dissoc (fn [this k]
                  (let [w (cpp/unbox (cpp/type "ecs_world_t*") world-box)
                        e-id (cond
                               (int? k) k
                               (or (keyword? k) (string? k))
                               (let [name-str (if (keyword? k) (name k) k)]
                                 (fl/ecs_lookup_symbol w name-str (cpp/bool. true) (cpp/bool. false)))
                               :else 0)]
                    (when (> e-id 0)
                      (cpp/vybe_delete_entity w e-id)))
                  this)

        ;; keys - all named entities
        :keys (fn [this]
                (let [entities (cpp/vybe_all_named_entities (cpp/unbox (cpp/type "ecs_world_t*") world-box))]
                  (mapv (fn [e-id]
                          (let [w (cpp/unbox (cpp/type "ecs_world_t*") world-box)
                                name-str (cpp/vybe_entity_name w e-id)]
                            (if (and name-str (not= name-str ""))
                              (keyword name-str)
                              e-id)))
                        entities)))}))))

(defn -create-vybe-flecs-world
  "Create a VybeFlecsWorld user type instance."
  [w-box]  ; Already boxed when passed as function arg
  ;; Create fresh factory each time to avoid stale JIT function references
  (let [factory (-create-vybe-flecs-world-user-type)]
    (factory {:world-box w-box})))

;; =============================================================================
;; Updated make-world to return user type
;; =============================================================================

(defn make-world
  "Create a new Flecs world wrapped as a VybeFlecsWorld user type.
   This world supports the map interface:
   - (get w :entity-name) -> VybeFlecsEntity
   - (assoc w :entity-name [:tag (Component {:field val})]) -> w
   - (merge w {:e1 [:tag] :e2 [:other]}) -> w
   - (get-in w [:entity Position]) -> component instance
   - (get-in w [:entity Position :x]) -> field value

   Returns a VybeFlecsWorld user type - use (cpp/unbox ...) or world-ptr for raw pointer."
  []
  (let* [w-ptr (fl/ecs_init)
         w-box (cpp/box w-ptr)]
    (-create-vybe-flecs-world w-box)))

(defn -main [& args])
