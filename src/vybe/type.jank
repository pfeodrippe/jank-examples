(ns vybe.type
  (:require
   ["flecs.h" :as fl :scope ""]
   [vybe.flecs :as vf]))

(comment

  (fl/ecs_id fl/ecs_bool_t)

  ())


;; =============================================================================
;; Name mangling - convert Clojure namespaced names to Flecs-safe identifiers
;; =============================================================================

(defn mangle-char
  "Replace . and - with _"
  [c]
  (cond
    (= c \.) \_
    (= c \-) \_
    :else c))

(defn mangle-name
  "Convert a namespaced symbol to a Flecs-safe identifier.
   Replaces . with _ and - with _ and separates ns/sym with __
   Example: 'vybe.type-test/Position' -> 'vybe_type_test__Position'"
  [ns-str sym-str]
  (let [mangled-ns (apply str (map mangle-char (str ns-str)))]
    (str mangled-ns "__" sym-str)))

;; =============================================================================
;; make-comp - Pure function to create component descriptors
;; =============================================================================

(defn make-comp
  "Create a component descriptor from a mangled name string and field definitions.
   Returns a map that can later be registered with a Flecs world.

   Usage:
     (make-comp \"vybe_type__Position\" [[:x :float] [:y :float]])

   Returns:
     {:name \"vybe_type__Position\"
      :fields [{:name \"x\" :type :float}
               {:name \"y\" :type :float}]}"
  [name-str fields]
  (let [field-maps (mapv (fn [[fname ftype]]
                           {:name (name fname)
                            :type ftype})
                         fields)]
    {:name name-str
     :fields field-maps}))

;; =============================================================================
;; Type ID lookup - maps keywords to Flecs primitive type entities
;; =============================================================================

(defn flecs-type-id
  "Get the Flecs entity ID for a primitive type keyword."
  [type-kw]
  (cond
    (or (= type-kw :float) (= type-kw :f32))    fl/FLECS_IDecs_f32_tID_
    (or (= type-kw :double) (= type-kw :f64))   fl/FLECS_IDecs_f64_tID_
    (= type-kw :i8)                             fl/FLECS_IDecs_i8_tID_
    (= type-kw :i16)                            fl/FLECS_IDecs_i16_tID_
    (or (= type-kw :i32) (= type-kw :int))      fl/FLECS_IDecs_i32_tID_
    (or (= type-kw :i64) (= type-kw :long))     fl/FLECS_IDecs_i64_tID_
    (= type-kw :u8)                             fl/FLECS_IDecs_u8_tID_
    (= type-kw :u16)                            fl/FLECS_IDecs_u16_tID_
    (= type-kw :u32)                            fl/FLECS_IDecs_u32_tID_
    (= type-kw :u64)                            fl/FLECS_IDecs_u64_tID_
    (= type-kw :bool)                           fl/FLECS_IDecs_bool_tID_
    (= type-kw :string)                         fl/FLECS_IDecs_string_tID_
    (= type-kw :entity)                         fl/FLECS_IDecs_entity_tID_
    :else (throw (ex-info "Unknown type" {:type type-kw}))))

;; =============================================================================
;; C++ helpers for struct registration (builder pattern)
;; =============================================================================

;; Builder pattern: create desc, add members one at a time, then register
(cpp/raw "
struct VybeStructBuilder {
  ecs_world_t* world;
  ecs_struct_desc_t desc;
  int member_idx;
};

VybeStructBuilder* vybe_struct_begin(ecs_world_t* w, const char* name) {
  auto* b = new VybeStructBuilder();
  b->world = w;
  b->desc = {};
  ecs_entity_desc_t ed = {}; ed.name = name;
  b->desc.entity = ecs_entity_init(w, &ed);
  b->member_idx = 0;
  return b;
}

void vybe_struct_add_member(VybeStructBuilder* b, const char* name, ecs_entity_t type) {
  if (b->member_idx < 32) {
    b->desc.members[b->member_idx].name = name;
    b->desc.members[b->member_idx].type = type;
    b->member_idx++;
  }
}

ecs_entity_t vybe_struct_end(VybeStructBuilder* b) {
  ecs_entity_t result = ecs_struct_init(b->world, &b->desc);
  delete b;
  return result;
}

// =============================================================================
// Field access helpers using meta cursor API
// =============================================================================

// Add component to entity (ensures it exists)
void vybe_add_comp(ecs_world_t* w, ecs_entity_t e, ecs_entity_t comp) {
  const ecs_type_info_t* ti = ecs_get_type_info(w, comp);
  if (ti) {
    ecs_ensure_id(w, e, comp, ti->size);
  }
}

// Set a float field on a component (entity version - gets pointer internally)
void vybe_set_field_float(ecs_world_t* w, ecs_entity_t e, ecs_entity_t comp, const char* field_name, double value) {
  const ecs_type_info_t* ti = ecs_get_type_info(w, comp);
  if (!ti) return;
  void* ptr = ecs_ensure_id(w, e, comp, ti->size);
  ecs_meta_cursor_t cur = ecs_meta_cursor(w, comp, ptr);
  ecs_meta_push(&cur);
  ecs_meta_member(&cur, field_name);
  ecs_meta_set_float(&cur, value);
}

// Set an int field on a component
void vybe_set_field_int(ecs_world_t* w, ecs_entity_t e, ecs_entity_t comp, const char* field_name, int64_t value) {
  const ecs_type_info_t* ti = ecs_get_type_info(w, comp);
  if (!ti) return;
  void* ptr = ecs_ensure_id(w, e, comp, ti->size);
  ecs_meta_cursor_t cur = ecs_meta_cursor(w, comp, ptr);
  ecs_meta_push(&cur);
  ecs_meta_member(&cur, field_name);
  ecs_meta_set_int(&cur, value);
}

// Set a uint field on a component
void vybe_set_field_uint(ecs_world_t* w, ecs_entity_t e, ecs_entity_t comp, const char* field_name, uint64_t value) {
  const ecs_type_info_t* ti = ecs_get_type_info(w, comp);
  if (!ti) return;
  void* ptr = ecs_ensure_id(w, e, comp, ti->size);
  ecs_meta_cursor_t cur = ecs_meta_cursor(w, comp, ptr);
  ecs_meta_push(&cur);
  ecs_meta_member(&cur, field_name);
  ecs_meta_set_uint(&cur, value);
}

// Set a bool field on a component
void vybe_set_field_bool(ecs_world_t* w, ecs_entity_t e, ecs_entity_t comp, const char* field_name, bool value) {
  const ecs_type_info_t* ti = ecs_get_type_info(w, comp);
  if (!ti) return;
  void* ptr = ecs_ensure_id(w, e, comp, ti->size);
  ecs_meta_cursor_t cur = ecs_meta_cursor(w, comp, ptr);
  ecs_meta_push(&cur);
  ecs_meta_member(&cur, field_name);
  ecs_meta_set_bool(&cur, value);
}

// Get a float field from a component
double vybe_get_field_float(ecs_world_t* w, ecs_entity_t e, ecs_entity_t comp, const char* field_name) {
  const void* ptr = ecs_get_id(w, e, comp);
  if (!ptr) return 0.0;
  ecs_meta_cursor_t cur = ecs_meta_cursor(w, comp, const_cast<void*>(ptr));
  ecs_meta_push(&cur);
  ecs_meta_member(&cur, field_name);
  return ecs_meta_get_float(&cur);
}

// Get an int field from a component
int64_t vybe_get_field_int(ecs_world_t* w, ecs_entity_t e, ecs_entity_t comp, const char* field_name) {
  const void* ptr = ecs_get_id(w, e, comp);
  if (!ptr) return 0;
  ecs_meta_cursor_t cur = ecs_meta_cursor(w, comp, const_cast<void*>(ptr));
  ecs_meta_push(&cur);
  ecs_meta_member(&cur, field_name);
  return ecs_meta_get_int(&cur);
}

// Get a uint field from a component
uint64_t vybe_get_field_uint(ecs_world_t* w, ecs_entity_t e, ecs_entity_t comp, const char* field_name) {
  const void* ptr = ecs_get_id(w, e, comp);
  if (!ptr) return 0;
  ecs_meta_cursor_t cur = ecs_meta_cursor(w, comp, const_cast<void*>(ptr));
  ecs_meta_push(&cur);
  ecs_meta_member(&cur, field_name);
  return ecs_meta_get_uint(&cur);
}

// Get a bool field from a component
bool vybe_get_field_bool(ecs_world_t* w, ecs_entity_t e, ecs_entity_t comp, const char* field_name) {
  const void* ptr = ecs_get_id(w, e, comp);
  if (!ptr) return false;
  ecs_meta_cursor_t cur = ecs_meta_cursor(w, comp, const_cast<void*>(ptr));
  ecs_meta_push(&cur);
  ecs_meta_member(&cur, field_name);
  return ecs_meta_get_bool(&cur);
}
")

;; =============================================================================
;; register-comp! - Register component with Flecs world
;; =============================================================================

(defn register-comp!
  "Register a component descriptor with a Flecs world using ecs_struct.
   Returns the Flecs entity ID for the component. Supports up to 32 fields.

   Usage:
     (defcomp Position [[:x :float] [:y :float]])
     (register-comp! world Position)"
  [world comp]
  (let [w (vf/world-ptr world)
        builder (cpp/box (cpp/vybe_struct_begin w (:name comp)))]
    (doseq [field (:fields comp)]
      (cpp/vybe_struct_add_member
       (cpp/unbox (cpp/type "VybeStructBuilder*") builder)
       (:name field)
       (flecs-type-id (:type field))))
    (cpp/vybe_struct_end (cpp/unbox (cpp/type "VybeStructBuilder*") builder))))

;; =============================================================================
;; Component data access - add, get, set fields
;; =============================================================================

(defn comp-id
  "Get the registered entity ID for a component descriptor.
   The component must have been registered with register-comp! first."
  [world comp]
  (fl/ecs_lookup (vf/world-ptr world) (:name comp)))

(defn has-comp?
  "Check if an entity has a component.

   Usage:
     (has-comp? world entity Position)"
  [world entity comp]
  (let [w (vf/world-ptr world)
        cid (comp-id world comp)]
    (fl/ecs_has_id w entity cid)))

(defn- is-float-type? [t]
  (or (= t :float) (= t :f32) (= t :double) (= t :f64)))

(defn- is-int-type? [t]
  (or (= t :i8) (= t :i16) (= t :i32) (= t :i64) (= t :int) (= t :long)))

(defn- is-uint-type? [t]
  (or (= t :u8) (= t :u16) (= t :u32) (= t :u64)))

(defn add-comp!
  "Add a component to an entity with optional initial values.

   Usage:
     (add-comp! world entity Position)                    ; zero-initialized
     (add-comp! world entity Position {:x 10.0 :y 20.0})  ; with map
     (add-comp! world entity Position 10.0 20.0)          ; positional args"
  [world entity comp & args]
  (let [w (vf/world-ptr world)
        w-box (cpp/box w)
        cid (comp-id world comp)]
    ;; Add the component
    (cpp/vybe_add_comp w entity cid)
    ;; Set initial values if provided
    (when (seq args)
      (let [values (if (map? (first args))
                     (first args)  ; {:x 10 :y 20}
                     ;; positional args: convert to map using field order
                     (zipmap (map (fn [f] (keyword (:name f))) (:fields comp))
                             args))]
        (doseq [[field-kw value] values]
          (let [field-name (name field-kw)
                field-type (some (fn [f] (when (= (:name f) field-name) (:type f)))
                                 (:fields comp))
                wb (cpp/unbox (cpp/type "ecs_world_t*") w-box)]
            (cond
              (is-float-type? field-type)
              (cpp/vybe_set_field_float wb entity cid field-name (cpp/double. value))

              (is-int-type? field-type)
              (cpp/vybe_set_field_int wb entity cid field-name (cpp/long. value))

              (is-uint-type? field-type)
              (cpp/vybe_set_field_uint wb entity cid field-name (cpp/long. value))

              (= field-type :bool)
              (cpp/vybe_set_field_bool wb entity cid field-name value))))))))

(defn get-comp
  "Get component data from an entity as a map.

   Usage:
     (get-comp world entity Position)
     ;; => {:x 10.0 :y 20.0}"
  [world entity comp]
  (let [w (vf/world-ptr world)
        w-box (cpp/box w)
        cid (comp-id world comp)]
    (when (fl/ecs_has_id w entity cid)
      (into {}
            (map (fn [field]
                   (let [field-name (:name field)
                         field-type (:type field)
                         wb (cpp/unbox (cpp/type "ecs_world_t*") w-box)
                         value (cond
                                 (is-float-type? field-type)
                                 (cpp/vybe_get_field_float wb entity cid field-name)

                                 (is-int-type? field-type)
                                 (cpp/vybe_get_field_int wb entity cid field-name)

                                 (is-uint-type? field-type)
                                 (cpp/vybe_get_field_uint wb entity cid field-name)

                                 (= field-type :bool)
                                 (cpp/vybe_get_field_bool wb entity cid field-name)

                                 :else nil)]
                     [(keyword field-name) value]))
                 (:fields comp))))))

(defn set-comp!
  "Set component fields on an entity using a map (like merge).

   Usage:
     (set-comp! world entity Position {:x 10.0})       ; update just :x
     (set-comp! world entity Position {:x 1.0 :y 2.0}) ; update both"
  [world entity comp values]
  (let [w (vf/world-ptr world)
        w-box (cpp/box w)
        cid (comp-id world comp)]
    (doseq [[field-kw value] values]
      (let [field-name (name field-kw)
            field-type (some (fn [f] (when (= (:name f) field-name) (:type f)))
                             (:fields comp))
            wb (cpp/unbox (cpp/type "ecs_world_t*") w-box)]
        (cond
          (is-float-type? field-type)
          (cpp/vybe_set_field_float wb entity cid field-name (cpp/double. value))

          (is-int-type? field-type)
          (cpp/vybe_set_field_int wb entity cid field-name (cpp/long. value))

          (is-uint-type? field-type)
          (cpp/vybe_set_field_uint wb entity cid field-name (cpp/long. value))

          (= field-type :bool)
          (cpp/vybe_set_field_bool wb entity cid field-name value))))))

;; =============================================================================
;; defcomp - Macro to define components
;; =============================================================================

(defmacro defcomp
  "Define a Flecs component type with namespace-qualified name.

   Usage:
     (defcomp Position [[:x :float] [:y :float]])

   Creates a var `Position` containing the component descriptor.
   The component name will be namespace-qualified and mangled for Flecs
   (e.g., \"vybe_type__Position\" for vybe.type/Position).
   Register with a world using: (register-comp! world Position)

   Supported types:
     :float, :f32    - 32-bit float
     :double, :f64   - 64-bit float
     :i8, :i16, :i32, :i64 - signed integers
     :int            - alias for :i32
     :long           - alias for :i64
     :u8, :u16, :u32, :u64 - unsigned integers
     :bool           - boolean
     :string         - string (char*)
     :entity         - entity reference"
  [sym fields]
  `(def ~sym (make-comp ~(mangle-name *ns* sym) ~fields)))

(defn -main [& args])
