(ns vybe.type
  (:require
   ["flecs.h" :as fl :scope ""]
   [vybe.flecs :as vf]))

(comment

  (fl/ecs_id fl/ecs_bool_t)

  ())


;; =============================================================================
;; Name mangling - convert Clojure namespaced names to Flecs-safe identifiers
;; =============================================================================

(defn mangle-char
  "Replace . and - with _"
  [c]
  (cond
    (= c \.) \_
    (= c \-) \_
    :else c))

(defn mangle-name
  "Convert a namespaced symbol to a Flecs-safe identifier.
   Replaces . with _ and - with _ and separates ns/sym with __
   Example: 'vybe.type-test/Position' -> 'vybe_type_test__Position'"
  [ns-str sym-str]
  (let [mangled-ns (apply str (map mangle-char (str ns-str)))]
    (str mangled-ns "__" sym-str)))

;; =============================================================================
;; make-comp - Pure function to create component descriptors
;; =============================================================================

(defn make-comp
  "Create a component descriptor from a mangled name string and field definitions.
   Returns a map that can later be registered with a Flecs world.

   Usage:
     (make-comp \"vybe_type__Position\" [[:x :float] [:y :float]])

   Returns:
     {:name \"vybe_type__Position\"
      :fields [{:name \"x\" :type :float}
               {:name \"y\" :type :float}]}"
  [name-str fields]
  (let [field-maps (mapv (fn [[fname ftype]]
                           {:name (name fname)
                            :type ftype})
                         fields)]
    {:name name-str
     :fields field-maps}))

;; =============================================================================
;; Type ID lookup - maps keywords to Flecs primitive type entities
;; =============================================================================

(defn flecs-type-id
  "Get the Flecs entity ID for a primitive type keyword."
  [type-kw]
  (cond
    (or (= type-kw :float) (= type-kw :f32))    fl/FLECS_IDecs_f32_tID_
    (or (= type-kw :double) (= type-kw :f64))   fl/FLECS_IDecs_f64_tID_
    (= type-kw :i8)                             fl/FLECS_IDecs_i8_tID_
    (= type-kw :i16)                            fl/FLECS_IDecs_i16_tID_
    (or (= type-kw :i32) (= type-kw :int))      fl/FLECS_IDecs_i32_tID_
    (or (= type-kw :i64) (= type-kw :long))     fl/FLECS_IDecs_i64_tID_
    (= type-kw :u8)                             fl/FLECS_IDecs_u8_tID_
    (= type-kw :u16)                            fl/FLECS_IDecs_u16_tID_
    (= type-kw :u32)                            fl/FLECS_IDecs_u32_tID_
    (= type-kw :u64)                            fl/FLECS_IDecs_u64_tID_
    (= type-kw :bool)                           fl/FLECS_IDecs_bool_tID_
    (= type-kw :string)                         fl/FLECS_IDecs_string_tID_
    (= type-kw :entity)                         fl/FLECS_IDecs_entity_tID_
    :else (throw (ex-info "Unknown type" {:type type-kw}))))

;; =============================================================================
;; C++ helpers for struct registration (builder pattern)
;; =============================================================================

;; Builder pattern: create desc, add members one at a time, then register
(cpp/raw "
struct VybeStructBuilder {
  ecs_world_t* world;
  ecs_struct_desc_t desc;
  int member_idx;
};

VybeStructBuilder* vybe_struct_begin(ecs_world_t* w, const char* name) {
  auto* b = new VybeStructBuilder();
  b->world = w;
  b->desc = {};
  ecs_entity_desc_t ed = {}; ed.name = name;
  b->desc.entity = ecs_entity_init(w, &ed);
  b->member_idx = 0;
  return b;
}

void vybe_struct_add_member(VybeStructBuilder* b, const char* name, ecs_entity_t type) {
  if (b->member_idx < 32) {
    b->desc.members[b->member_idx].name = name;
    b->desc.members[b->member_idx].type = type;
    b->member_idx++;
  }
}

ecs_entity_t vybe_struct_end(VybeStructBuilder* b) {
  ecs_entity_t result = ecs_struct_init(b->world, &b->desc);
  delete b;
  return result;
}
")

;; =============================================================================
;; register-comp! - Register component with Flecs world
;; =============================================================================

(defn register-comp!
  "Register a component descriptor with a Flecs world using ecs_struct.
   Returns the Flecs entity ID for the component. Supports up to 32 fields.

   Usage:
     (defcomp Position [[:x :float] [:y :float]])
     (register-comp! world Position)"
  [world comp]
  (let [w (vf/world-ptr world)
        builder (cpp/box (cpp/vybe_struct_begin w (:name comp)))]
    (doseq [field (:fields comp)]
      (cpp/vybe_struct_add_member
       (cpp/unbox (cpp/type "VybeStructBuilder*") builder)
       (:name field)
       (flecs-type-id (:type field))))
    (cpp/vybe_struct_end (cpp/unbox (cpp/type "VybeStructBuilder*") builder))))

;; =============================================================================
;; defcomp - Macro to define components
;; =============================================================================

(defmacro defcomp
  "Define a Flecs component type with namespace-qualified name.

   Usage:
     (defcomp Position [[:x :float] [:y :float]])

   Creates a var `Position` containing the component descriptor.
   The component name will be namespace-qualified and mangled for Flecs
   (e.g., \"vybe_type__Position\" for vybe.type/Position).
   Register with a world using: (register-comp! world Position)

   Supported types:
     :float, :f32    - 32-bit float
     :double, :f64   - 64-bit float
     :i8, :i16, :i32, :i64 - signed integers
     :int            - alias for :i32
     :long           - alias for :i64
     :u8, :u16, :u32, :u64 - unsigned integers
     :bool           - boolean
     :string         - string (char*)
     :entity         - entity reference"
  [sym fields]
  `(def ~sym (make-comp ~(mangle-name *ns* sym) ~fields)))

(defn -main [& args])
