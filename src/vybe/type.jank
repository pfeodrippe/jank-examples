(ns vybe.type
  (:require
   ["flecs.h" :as fl :scope ""]
   [vybe.flecs :as vf]))

;; =============================================================================
;; Name mangling - convert Clojure namespaced names to Flecs-safe identifiers
;; =============================================================================

(defn mangle-char
  "Replace . and - with _"
  [c]
  (cond
    (= c \.) \_
    (= c \-) \_
    :else c))

(defn mangle-name
  "Convert a namespaced symbol to a Flecs-safe identifier.
   Replaces . with _ and - with _ and separates ns/sym with __
   Example: 'vybe.type-test/Position' -> 'vybe_type_test__Position'"
  [ns-str sym-str]
  (let [mangled-ns (apply str (map mangle-char (str ns-str)))]
    (str mangled-ns "__" sym-str)))

;; =============================================================================
;; make-comp - Pure function to create component descriptors
;; =============================================================================

(defn make-comp
  "Create a component descriptor from a mangled name string and field definitions.
   Returns a map that can later be registered with a Flecs world.

   Usage:
     (make-comp \"vybe_type__Position\" [[:x :float] [:y :float]])

   Returns:
     {:name \"vybe_type__Position\"
      :fields [{:name \"x\" :type :float}
               {:name \"y\" :type :float}]}"
  [name-str fields]
  (let [field-maps (mapv (fn [[fname ftype]]
                           {:name (name fname)
                            :type ftype})
                         fields)]
    {:name name-str
     :fields field-maps}))

;; =============================================================================
;; Type ID lookup - maps keywords to Flecs primitive type entities
;; =============================================================================

(defn flecs-type-id
  "Get the Flecs entity ID for a primitive type keyword."
  [type-kw]
  (cond
    (or (= type-kw :float) (= type-kw :f32))    fl/FLECS_IDecs_f32_tID_
    (or (= type-kw :double) (= type-kw :f64))   fl/FLECS_IDecs_f64_tID_
    (= type-kw :i8)                             fl/FLECS_IDecs_i8_tID_
    (= type-kw :i16)                            fl/FLECS_IDecs_i16_tID_
    (or (= type-kw :i32) (= type-kw :int))      fl/FLECS_IDecs_i32_tID_
    (or (= type-kw :i64) (= type-kw :long))     fl/FLECS_IDecs_i64_tID_
    (= type-kw :u8)                             fl/FLECS_IDecs_u8_tID_
    (= type-kw :u16)                            fl/FLECS_IDecs_u16_tID_
    (= type-kw :u32)                            fl/FLECS_IDecs_u32_tID_
    (= type-kw :u64)                            fl/FLECS_IDecs_u64_tID_
    (= type-kw :bool)                           fl/FLECS_IDecs_bool_tID_
    (= type-kw :string)                         fl/FLECS_IDecs_string_tID_
    (= type-kw :entity)                         fl/FLECS_IDecs_entity_tID_
    :else (throw (ex-info "Unknown type" {:type type-kw}))))

;; =============================================================================
;; C++ helpers for struct registration (builder pattern)
;; =============================================================================

;; Builder pattern: create desc, add members one at a time, then register
(cpp/raw "
struct VybeStructBuilder {
  ecs_world_t* world;
  ecs_struct_desc_t desc;
  int member_idx;
};

VybeStructBuilder* vybe_struct_begin(ecs_world_t* w, const char* name) {
  auto* b = new VybeStructBuilder();
  b->world = w;
  b->desc = {};
  ecs_entity_desc_t ed = {}; ed.name = name;
  b->desc.entity = ecs_entity_init(w, &ed);
  b->member_idx = 0;
  return b;
}

void vybe_struct_add_member(VybeStructBuilder* b, const char* name, ecs_entity_t type) {
  if (b->member_idx < 32) {
    b->desc.members[b->member_idx].name = name;
    b->desc.members[b->member_idx].type = type;
    b->member_idx++;
  }
}

ecs_entity_t vybe_struct_end(VybeStructBuilder* b) {
  ecs_entity_t result = ecs_struct_init(b->world, &b->desc);
  delete b;
  return result;
}

// =============================================================================
// Field access helpers using meta cursor API
// =============================================================================

// Add component to entity (ensures it exists)
void vybe_add_comp(ecs_world_t* w, ecs_entity_t e, ecs_entity_t comp) {
  if (!w || !e || !comp) return;
  const ecs_type_info_t* ti = ecs_get_type_info(w, comp);
  if (ti && ti->size > 0) {
    ecs_ensure_id(w, e, comp, ti->size);
  }
}

// Set a float field on a component (entity version - gets pointer internally)
void vybe_set_field_float(ecs_world_t* w, ecs_entity_t e, ecs_entity_t comp, const char* field_name, double value) {
  if (!w || !e || !comp || !field_name) return;
  const ecs_type_info_t* ti = ecs_get_type_info(w, comp);
  if (!ti || ti->size == 0) return;
  void* ptr = ecs_ensure_id(w, e, comp, ti->size);
  if (!ptr) return;
  ecs_meta_cursor_t cur = ecs_meta_cursor(w, comp, ptr);
  ecs_meta_push(&cur);
  ecs_meta_member(&cur, field_name);
  ecs_meta_set_float(&cur, value);
}

// Set an int field on a component
void vybe_set_field_int(ecs_world_t* w, ecs_entity_t e, ecs_entity_t comp, const char* field_name, int64_t value) {
  if (!w || !e || !comp || !field_name) return;
  const ecs_type_info_t* ti = ecs_get_type_info(w, comp);
  if (!ti || ti->size == 0) return;
  void* ptr = ecs_ensure_id(w, e, comp, ti->size);
  if (!ptr) return;
  ecs_meta_cursor_t cur = ecs_meta_cursor(w, comp, ptr);
  ecs_meta_push(&cur);
  ecs_meta_member(&cur, field_name);
  ecs_meta_set_int(&cur, value);
}

// Set a uint field on a component
void vybe_set_field_uint(ecs_world_t* w, ecs_entity_t e, ecs_entity_t comp, const char* field_name, uint64_t value) {
  if (!w || !e || !comp || !field_name) return;
  const ecs_type_info_t* ti = ecs_get_type_info(w, comp);
  if (!ti || ti->size == 0) return;
  void* ptr = ecs_ensure_id(w, e, comp, ti->size);
  if (!ptr) return;
  ecs_meta_cursor_t cur = ecs_meta_cursor(w, comp, ptr);
  ecs_meta_push(&cur);
  ecs_meta_member(&cur, field_name);
  ecs_meta_set_uint(&cur, value);
}

// Set a bool field on a component
void vybe_set_field_bool(ecs_world_t* w, ecs_entity_t e, ecs_entity_t comp, const char* field_name, bool value) {
  if (!w || !e || !comp || !field_name) return;
  const ecs_type_info_t* ti = ecs_get_type_info(w, comp);
  if (!ti || ti->size == 0) return;
  void* ptr = ecs_ensure_id(w, e, comp, ti->size);
  if (!ptr) return;
  ecs_meta_cursor_t cur = ecs_meta_cursor(w, comp, ptr);
  ecs_meta_push(&cur);
  ecs_meta_member(&cur, field_name);
  ecs_meta_set_bool(&cur, value);
}

// Get a float field from a component
double vybe_get_field_float(ecs_world_t* w, ecs_entity_t e, ecs_entity_t comp, const char* field_name) {
  if (!w || !e || !comp || !field_name) return 0.0;
  const void* ptr = ecs_get_id(w, e, comp);
  if (!ptr) return 0.0;
  ecs_meta_cursor_t cur = ecs_meta_cursor(w, comp, const_cast<void*>(ptr));
  ecs_meta_push(&cur);
  ecs_meta_member(&cur, field_name);
  return ecs_meta_get_float(&cur);
}

// Get an int field from a component
int64_t vybe_get_field_int(ecs_world_t* w, ecs_entity_t e, ecs_entity_t comp, const char* field_name) {
  if (!w || !e || !comp || !field_name) return 0;
  const void* ptr = ecs_get_id(w, e, comp);
  if (!ptr) return 0;
  ecs_meta_cursor_t cur = ecs_meta_cursor(w, comp, const_cast<void*>(ptr));
  ecs_meta_push(&cur);
  ecs_meta_member(&cur, field_name);
  return ecs_meta_get_int(&cur);
}

// Get a uint field from a component
uint64_t vybe_get_field_uint(ecs_world_t* w, ecs_entity_t e, ecs_entity_t comp, const char* field_name) {
  if (!w || !e || !comp || !field_name) return 0;
  const void* ptr = ecs_get_id(w, e, comp);
  if (!ptr) return 0;
  ecs_meta_cursor_t cur = ecs_meta_cursor(w, comp, const_cast<void*>(ptr));
  ecs_meta_push(&cur);
  ecs_meta_member(&cur, field_name);
  return ecs_meta_get_uint(&cur);
}

// Get a bool field from a component
bool vybe_get_field_bool(ecs_world_t* w, ecs_entity_t e, ecs_entity_t comp, const char* field_name) {
  if (!w || !e || !comp || !field_name) return false;
  const void* ptr = ecs_get_id(w, e, comp);
  if (!ptr) return false;
  ecs_meta_cursor_t cur = ecs_meta_cursor(w, comp, const_cast<void*>(ptr));
  ecs_meta_push(&cur);
  ecs_meta_member(&cur, field_name);
  return ecs_meta_get_bool(&cur);
}

// =============================================================================
// Field metadata access - get offsets and sizes from Flecs
// =============================================================================

// Get the number of members in a struct component
int32_t vybe_get_member_count(ecs_world_t* w, ecs_entity_t comp) {
  const EcsStruct* st = ecs_get(w, comp, EcsStruct);
  if (!st) return 0;
  return ecs_vec_count(&st->members);
}

// Get the offset of a member by index
int32_t vybe_get_member_offset(ecs_world_t* w, ecs_entity_t comp, int32_t idx) {
  const EcsStruct* st = ecs_get(w, comp, EcsStruct);
  if (!st) return -1;
  if (idx < 0 || idx >= ecs_vec_count(&st->members)) return -1;
  const ecs_member_t* m = ecs_vec_get_t(&st->members, ecs_member_t, idx);
  return m->offset;
}

// Get the size of a member by index
int32_t vybe_get_member_size(ecs_world_t* w, ecs_entity_t comp, int32_t idx) {
  const EcsStruct* st = ecs_get(w, comp, EcsStruct);
  if (!st) return -1;
  if (idx < 0 || idx >= ecs_vec_count(&st->members)) return -1;
  const ecs_member_t* m = ecs_vec_get_t(&st->members, ecs_member_t, idx);
  return m->size;
}

// Get the name of a member by index (returns empty string if not found)
const char* vybe_get_member_name(ecs_world_t* w, ecs_entity_t comp, int32_t idx) {
  const EcsStruct* st = ecs_get(w, comp, EcsStruct);
  if (!st) return \"\";
  if (idx < 0 || idx >= ecs_vec_count(&st->members)) return \"\";
  const ecs_member_t* m = ecs_vec_get_t(&st->members, ecs_member_t, idx);
  return m->name ? m->name : \"\";
}

// Get the total size of a component
int32_t vybe_get_comp_size(ecs_world_t* w, ecs_entity_t comp) {
  const ecs_type_info_t* ti = ecs_get_type_info(w, comp);
  return ti ? ti->size : 0;
}

// =============================================================================
// Direct memory access - use offsets for O(1) field access
// =============================================================================

// Get component pointer for an entity (returns NULL if entity doesn't have it)
void* vybe_get_comp_ptr(ecs_world_t* w, ecs_entity_t e, ecs_entity_t comp) {
  // First check if entity has the component
  if (!ecs_has_id(w, e, comp)) return nullptr;
  const ecs_type_info_t* ti = ecs_get_type_info(w, comp);
  if (!ti || ti->size == 0) return nullptr;
  return ecs_ensure_id(w, e, comp, ti->size);
}

// Get const component pointer for an entity (returns NULL if entity doesn't have it)
const void* vybe_get_comp_ptr_const(ecs_world_t* w, ecs_entity_t e, ecs_entity_t comp) {
  if (!ecs_has_id(w, e, comp)) return nullptr;
  return ecs_get_id(w, e, comp);
}

// Direct set float at offset
void vybe_set_float_at(void* base, int32_t offset, double value) {
  if (!base) return;
  *(float*)((char*)base + offset) = (float)value;
}

// Direct set double at offset
void vybe_set_double_at(void* base, int32_t offset, double value) {
  if (!base) return;
  *(double*)((char*)base + offset) = value;
}

// Direct set i32 at offset
void vybe_set_i32_at(void* base, int32_t offset, int64_t value) {
  if (!base) return;
  *(int32_t*)((char*)base + offset) = (int32_t)value;
}

// Direct set i64 at offset
void vybe_set_i64_at(void* base, int32_t offset, int64_t value) {
  if (!base) return;
  *(int64_t*)((char*)base + offset) = value;
}

// Direct set u32 at offset
void vybe_set_u32_at(void* base, int32_t offset, uint64_t value) {
  if (!base) return;
  *(uint32_t*)((char*)base + offset) = (uint32_t)value;
}

// Direct set u64 at offset
void vybe_set_u64_at(void* base, int32_t offset, uint64_t value) {
  if (!base) return;
  *(uint64_t*)((char*)base + offset) = value;
}

// Direct set bool at offset
void vybe_set_bool_at(void* base, int32_t offset, bool value) {
  if (!base) return;
  *(bool*)((char*)base + offset) = value;
}

// Direct get float at offset
double vybe_get_float_at(const void* base, int32_t offset) {
  if (!base) return 0.0;
  return (double)*(const float*)((const char*)base + offset);
}

// Direct get double at offset
double vybe_get_double_at(const void* base, int32_t offset) {
  if (!base) return 0.0;
  return *(const double*)((const char*)base + offset);
}

// Direct get i32 at offset
int64_t vybe_get_i32_at(const void* base, int32_t offset) {
  if (!base) return 0;
  return (int64_t)*(const int32_t*)((const char*)base + offset);
}

// Direct get i64 at offset
int64_t vybe_get_i64_at(const void* base, int32_t offset) {
  if (!base) return 0;
  return *(const int64_t*)((const char*)base + offset);
}

// Direct get u32 at offset
uint64_t vybe_get_u32_at(const void* base, int32_t offset) {
  if (!base) return 0;
  return (uint64_t)*(const uint32_t*)((const char*)base + offset);
}

// Direct get u64 at offset
uint64_t vybe_get_u64_at(const void* base, int32_t offset) {
  if (!base) return 0;
  return *(const uint64_t*)((const char*)base + offset);
}

// Direct get bool at offset
bool vybe_get_bool_at(const void* base, int32_t offset) {
  if (!base) return false;
  return *(const bool*)((const char*)base + offset);
}

// =============================================================================
// Standalone instance memory allocation
// =============================================================================

// Allocate memory for a standalone component instance
void* vybe_alloc_comp(int32_t size) {
  return calloc(1, size);  // Zero-initialized
}

// Free standalone component memory
void vybe_free_comp(void* ptr) {
  if (ptr) free(ptr);
}
")

;; =============================================================================
;; Component metadata cache - stores offsets and sizes for direct memory access
;; =============================================================================

;; Global cache: component-name -> {:offsets {field-name offset} :sizes {field-name size} :comp-size size}
(def ^:private comp-meta-cache (atom {}))

;; Global registry: maps component constructor functions to their descriptors
(def ^:private comp-registry (atom {}))

(defn- cache-comp-meta!
  "Cache field offsets and sizes for a component after registration."
  [world comp cid]
  (let [w (vf/world-ptr world)
        w-box (cpp/box w)
        member-count (cpp/vybe_get_member_count w cid)
        comp-size (cpp/vybe_get_comp_size w cid)]
    ;; Build offset and size maps for each field
    (loop [idx 0
           offsets {}
           sizes {}]
      (if (>= idx member-count)
        ;; Done - cache the metadata
        (swap! comp-meta-cache assoc (:name comp)
               {:offsets offsets
                :sizes sizes
                :comp-size comp-size
                :cid cid})
        ;; Get metadata for this field
        (let [wb (cpp/unbox (cpp/type "ecs_world_t*") w-box)
              fname (cpp/vybe_get_member_name wb cid idx)
              offset (cpp/vybe_get_member_offset wb cid idx)
              size (cpp/vybe_get_member_size wb cid idx)]
          (recur (inc idx)
                 (assoc offsets fname offset)
                 (assoc sizes fname size)))))))

(defn get-comp-meta
  "Get cached metadata for a component. Returns nil if not cached."
  [comp]
  (let [desc (if (map? comp) comp (get @comp-registry comp))]
    (get @comp-meta-cache (:name desc))))

(defn comp-size
  "Get the total size of a component in bytes. Requires prior registration."
  [comp]
  (:comp-size (get-comp-meta comp)))

(defn field-offset
  "Get the byte offset of a field. Requires prior registration."
  [comp field-name]
  (get-in (get-comp-meta comp) [:offsets (if (keyword? field-name)
                                            (name field-name)
                                            field-name)]))

(defn field-size
  "Get the byte size of a field. Requires prior registration."
  [comp field-name]
  (get-in (get-comp-meta comp) [:sizes (if (keyword? field-name)
                                          (name field-name)
                                          field-name)]))

;; =============================================================================
;; Component resolution - handle both descriptors and constructor functions
;; =============================================================================

(defn resolve-descriptor
  "Resolve a component to its descriptor.
   Accepts either a descriptor map or a constructor function."
  [comp]
  (if (map? comp)
    comp  ; Already a descriptor
    (get @comp-registry comp)))  ; Look up constructor in registry

;; =============================================================================
;; register-comp! - Register component with Flecs world
;; =============================================================================

(defn register-comp!
  "Register a component descriptor with a Flecs world using ecs_struct.
   Returns the Flecs entity ID for the component. Supports up to 32 fields.
   Also caches field offsets and sizes for direct memory access.

   Usage:
     (defcomp Position [[:x :float] [:y :float]])
     (register-comp! world Position)"
  [world comp]
  (let [desc (resolve-descriptor comp)
        w (vf/world-ptr world)
        builder (cpp/box (cpp/vybe_struct_begin w (:name desc)))]
    (doseq [field (:fields desc)]
      (cpp/vybe_struct_add_member
       (cpp/unbox (cpp/type "VybeStructBuilder*") builder)
       (:name field)
       (flecs-type-id (:type field))))
    (let [cid (cpp/vybe_struct_end (cpp/unbox (cpp/type "VybeStructBuilder*") builder))]
      ;; Cache the field metadata for direct memory access
      (cache-comp-meta! world desc cid)
      cid)))

;; =============================================================================
;; init-comp-meta! - Initialize component metadata using a temporary world
;; =============================================================================

(defn init-comp-meta!
  "Initialize component metadata using a temporary world.
   This allows getting field offsets before registering with a real world.
   Useful for pre-caching metadata at startup.

   Note: Uses full world (not mini) because meta addon is required for structs.
   The world is intentionally not destroyed to avoid issues with jank's
   lazy evaluation accessing the world after destruction.

   Usage:
     (defcomp Position [[:x :float] [:y :float]])
     (init-comp-meta! Position)
     ;; Now field-offset and comp-size work without a real world"
  [comp]
  (let [desc (resolve-descriptor comp)
        temp-world (vf/make-world)]
    (register-comp! temp-world desc))
  nil)

;; =============================================================================
;; Component data access - add, get, set fields
;; =============================================================================

(defn comp-id
  "Get the registered entity ID for a component descriptor.
   The component must have been registered with register-comp! first."
  [world comp]
  (let [desc (resolve-descriptor comp)]
    (fl/ecs_lookup (vf/world-ptr world) (:name desc))))

(defn has-comp?
  "Check if an entity has a component.

   Usage:
     (has-comp? world entity Position)"
  [world entity comp]
  (let [w (vf/world-ptr world)
        cid (comp-id world comp)]
    (fl/ecs_has_id w entity cid)))

(defn- is-float-type? [t]
  (or (= t :float) (= t :f32) (= t :double) (= t :f64)))

(defn- is-int-type? [t]
  (or (= t :i8) (= t :i16) (= t :i32) (= t :i64) (= t :int) (= t :long)))

(defn- is-uint-type? [t]
  (or (= t :u8) (= t :u16) (= t :u32) (= t :u64)))

(defn add-comp!
  "Add a component to an entity with optional initial values.

   Usage:
     (add-comp! world entity Position)                    ; zero-initialized
     (add-comp! world entity Position {:x 10.0 :y 20.0})  ; with map
     (add-comp! world entity Position 10.0 20.0)          ; positional args"
  [world entity comp & args]
  (let [desc (resolve-descriptor comp)
        w (vf/world-ptr world)
        w-box (cpp/box w)
        cid (comp-id world comp)]
    ;; Add the component
    (cpp/vybe_add_comp w entity cid)
    ;; Set initial values if provided
    (when (seq args)
      (let [values (if (map? (first args))
                     (first args)  ; {:x 10 :y 20}
                     ;; positional args: convert to map using field order
                     (zipmap (map (fn [f] (keyword (:name f))) (:fields desc))
                             args))]
        (doseq [[field-kw value] values]
          (let [field-name (name field-kw)
                field-type (some (fn [f] (when (= (:name f) field-name) (:type f)))
                                 (:fields desc))
                wb (cpp/unbox (cpp/type "ecs_world_t*") w-box)]
            (cond
              (is-float-type? field-type)
              (cpp/vybe_set_field_float wb entity cid field-name (cpp/double. value))

              (is-int-type? field-type)
              (cpp/vybe_set_field_int wb entity cid field-name (cpp/long. value))

              (is-uint-type? field-type)
              (cpp/vybe_set_field_uint wb entity cid field-name (cpp/long. value))

              (= field-type :bool)
              (cpp/vybe_set_field_bool wb entity cid field-name value))))))))

(defn get-comp
  "Get component data from an entity as a ComponentRef.
   Returns a map-like object that can be read with keywords and updated with merge!.

   Usage:
     (get-comp world entity Position)
     ;; => {:x 10.0 :y 20.0 :vt/world-box ... :vt/entity ... :vt/comp ...}

     (let [pos (get-comp world entity Position)]
       (:x pos)              ; read field
       (merge! pos {:x 5}))  ; update field"
  [world entity comp]
  (let [desc (resolve-descriptor comp)
        w (vf/world-ptr world)
        w-box (cpp/box w)
        cid (comp-id world comp)]
    (when (fl/ecs_has_id w entity cid)
      ;; Build the component ref with metadata for later updates
      (let [field-values (into {}
                               (map (fn [field]
                                      (let [field-name (:name field)
                                            field-type (:type field)
                                            wb (cpp/unbox (cpp/type "ecs_world_t*") w-box)
                                            value (cond
                                                    (is-float-type? field-type)
                                                    (cpp/vybe_get_field_float wb entity cid field-name)

                                                    (is-int-type? field-type)
                                                    (cpp/vybe_get_field_int wb entity cid field-name)

                                                    (is-uint-type? field-type)
                                                    (cpp/vybe_get_field_uint wb entity cid field-name)

                                                    (= field-type :bool)
                                                    (cpp/vybe_get_field_bool wb entity cid field-name)

                                                    :else nil)]
                                        [(keyword field-name) value]))
                                    (:fields desc)))]
        ;; Return map with component ref metadata embedded
        (assoc field-values
               :vt/world-box w-box
               :vt/entity entity
               :vt/comp desc)))))

(defn comp-ref?
  "Check if x is a ComponentRef (returned by get-comp)."
  [x]
  (and (map? x) (contains? x :vt/comp)))

(defn merge!
  "Update component fields. Works with:
   1. A standalone instance: (merge! pos {:x 5})
   2. A ComponentRef from get-comp: (merge! pos {:x 5})
   3. Explicit args: (merge! world entity Position {:x 5})

   Usage:
     (let [pos (Position {:x 1.0 :y 2.0})]
       (merge! pos {:x 5.0}))  ; update standalone instance

     (let [pos (get-comp world entity Position)]
       (merge! pos {:x 5.0}))  ; update ComponentRef

     (merge! world entity Position {:x 5.0})  ; explicit form"
  ([instance-or-ref values]
   ;; Check if it's a standalone instance (has :vt/ptr-box after deref)
   ;; Note: standalone instances are atoms, ComponentRefs are plain maps
   (if (and (not (map? instance-or-ref))
            (contains? (deref instance-or-ref) :vt/ptr-box))
     ;; Standalone instance: use direct update
     (let [data @instance-or-ref
           comp (:vt/comp data)
           ptr-box (:vt/ptr-box data)]
       ;; Write values to native memory
       (doseq [[field-kw value] values]
         (let [field-name (name field-kw)
               offset (field-offset comp field-name)
               field-type (some (fn [f] (when (= (:name f) field-name) (:type f)))
                                (:fields comp))]
           (when offset
             (let [ptr (cpp/unbox (cpp/type "void*") ptr-box)]
               (cond
                 ;; Float types (f32, f64)
                 (is-float-type? field-type)
                 (cpp/vybe_set_float_at ptr offset (cpp/double. value))

                 ;; Int types (i8, i16, i32, i64)
                 (is-int-type? field-type)
                 (cpp/vybe_set_i32_at ptr offset (cpp/long. value))

                 ;; Uint types (u8, u16, u32, u64)
                 (is-uint-type? field-type)
                 (cpp/vybe_set_u32_at ptr offset (cpp/long. value))

                 (= field-type :bool)
                 (cpp/vybe_set_bool_at ptr offset value))))))
       ;; Update the atom's map so keyword access works
       (swap! instance-or-ref merge values)
       instance-or-ref)
     ;; ComponentRef form: (merge! pos {:x 5})
     (let [comp-ref instance-or-ref
           w-box (:vt/world-box comp-ref)
           entity (:vt/entity comp-ref)
           comp (:vt/comp comp-ref)
           cid (fl/ecs_lookup (cpp/unbox (cpp/type "ecs_world_t*") w-box) (:name comp))]
       (doseq [[field-kw value] values]
         (let [field-name (name field-kw)
               field-type (some (fn [f] (when (= (:name f) field-name) (:type f)))
                                (:fields comp))
               wb (cpp/unbox (cpp/type "ecs_world_t*") w-box)]
           (cond
             (is-float-type? field-type)
             (cpp/vybe_set_field_float wb entity cid field-name (cpp/double. value))

             (is-int-type? field-type)
             (cpp/vybe_set_field_int wb entity cid field-name (cpp/long. value))

             (is-uint-type? field-type)
             (cpp/vybe_set_field_uint wb entity cid field-name (cpp/long. value))

             (= field-type :bool)
             (cpp/vybe_set_field_bool wb entity cid field-name value)))))))
  ([world entity comp values]
   ;; Explicit form: (merge! world entity Position {:x 5})
   (let [desc (resolve-descriptor comp)
         w (vf/world-ptr world)
         w-box (cpp/box w)
         cid (comp-id world comp)]
     (doseq [[field-kw value] values]
       (let [field-name (name field-kw)
             field-type (some (fn [f] (when (= (:name f) field-name) (:type f)))
                              (:fields desc))
             wb (cpp/unbox (cpp/type "ecs_world_t*") w-box)]
         (cond
           (is-float-type? field-type)
           (cpp/vybe_set_field_float wb entity cid field-name (cpp/double. value))

           (is-int-type? field-type)
           (cpp/vybe_set_field_int wb entity cid field-name (cpp/long. value))

           (is-uint-type? field-type)
           (cpp/vybe_set_field_uint wb entity cid field-name (cpp/long. value))

           (= field-type :bool)
           (cpp/vybe_set_field_bool wb entity cid field-name value)))))))

(defn set-comp!
  "Alias for merge! with explicit args. Set component fields on an entity.

   Usage:
     (set-comp! world entity Position {:x 10.0})       ; update just :x
     (set-comp! world entity Position {:x 1.0 :y 2.0}) ; update both"
  [world entity comp values]
  (merge! world entity comp values))

;; =============================================================================
;; Direct memory access - O(1) field access using cached offsets
;; =============================================================================

(defn- is-f32-type? [t]
  (or (= t :float) (= t :f32)))

(defn- is-f64-type? [t]
  (or (= t :double) (= t :f64)))

(defn- is-i32-type? [t]
  (or (= t :i32) (= t :int) (= t :i8) (= t :i16)))

(defn- is-i64-type? [t]
  (or (= t :i64) (= t :long)))

(defn- is-u32-type? [t]
  (or (= t :u32) (= t :u8) (= t :u16)))

(defn- is-u64-type? [t]
  (= t :u64))

(defn get-field-direct
  "Get a single field value using direct memory access (O(1)).
   Requires component to be registered first.

   Usage:
     (get-field-direct world entity Position :x)"
  [world entity comp field-kw]
  (let [desc (resolve-descriptor comp)
        w (vf/world-ptr world)
        cid (comp-id world comp)]
    (when (fl/ecs_has_id w entity cid)
      (let [ptr (cpp/vybe_get_comp_ptr_const w entity cid)
            field-name (name field-kw)
            offset (field-offset desc field-name)
            field-type (some (fn [f] (when (= (:name f) field-name) (:type f)))
                             (:fields desc))]
        (when offset
          (cond
            (is-f32-type? field-type)
            (cpp/vybe_get_float_at ptr offset)

            (is-f64-type? field-type)
            (cpp/vybe_get_double_at ptr offset)

            (is-i32-type? field-type)
            (cpp/vybe_get_i32_at ptr offset)

            (is-i64-type? field-type)
            (cpp/vybe_get_i64_at ptr offset)

            (is-u32-type? field-type)
            (cpp/vybe_get_u32_at ptr offset)

            (is-u64-type? field-type)
            (cpp/vybe_get_u64_at ptr offset)

            (= field-type :bool)
            (cpp/vybe_get_bool_at ptr offset)))))))

(defn set-field-direct!
  "Set a single field value using direct memory access (O(1)).
   Requires component to be registered first.

   Usage:
     (set-field-direct! world entity Position :x 42.0)"
  [world entity comp field-kw value]
  (let [desc (resolve-descriptor comp)
        w (vf/world-ptr world)
        cid (comp-id world comp)]
    (when (fl/ecs_has_id w entity cid)
      (let [ptr (cpp/vybe_get_comp_ptr w entity cid)
            field-name (name field-kw)
            offset (field-offset desc field-name)
            field-type (some (fn [f] (when (= (:name f) field-name) (:type f)))
                             (:fields desc))]
        (when offset
          (cond
            (is-f32-type? field-type)
            (cpp/vybe_set_float_at ptr offset (cpp/double. value))

            (is-f64-type? field-type)
            (cpp/vybe_set_double_at ptr offset (cpp/double. value))

            (is-i32-type? field-type)
            (cpp/vybe_set_i32_at ptr offset (cpp/long. value))

            (is-i64-type? field-type)
            (cpp/vybe_set_i64_at ptr offset (cpp/long. value))

            (is-u32-type? field-type)
            (cpp/vybe_set_u32_at ptr offset (cpp/long. value))

            (is-u64-type? field-type)
            (cpp/vybe_set_u64_at ptr offset (cpp/long. value))

            (= field-type :bool)
            (cpp/vybe_set_bool_at ptr offset value)))))))

(defn get-comp-direct
  "Get component data using direct memory access (faster than get-comp).
   Returns a plain map without ComponentRef metadata.

   Usage:
     (get-comp-direct world entity Position)
     ;; => {:x 10.0 :y 20.0}"
  [world entity comp]
  (let [desc (resolve-descriptor comp)
        w (vf/world-ptr world)
        cid (comp-id world comp)]
    (when (fl/ecs_has_id w entity cid)
      (let [ptr (cpp/vybe_get_comp_ptr_const w entity cid)
            ptr-box (cpp/box ptr)]
        (into {}
              (map (fn [field]
                     (let [field-name (:name field)
                           field-type (:type field)
                           offset (field-offset desc field-name)
                           p (cpp/unbox (cpp/type "const void*") ptr-box)
                           value (when offset
                                   (cond
                                     (is-f32-type? field-type)
                                     (cpp/vybe_get_float_at p offset)

                                     (is-f64-type? field-type)
                                     (cpp/vybe_get_double_at p offset)

                                     (is-i32-type? field-type)
                                     (cpp/vybe_get_i32_at p offset)

                                     (is-i64-type? field-type)
                                     (cpp/vybe_get_i64_at p offset)

                                     (is-u32-type? field-type)
                                     (cpp/vybe_get_u32_at p offset)

                                     (is-u64-type? field-type)
                                     (cpp/vybe_get_u64_at p offset)

                                     (= field-type :bool)
                                     (cpp/vybe_get_bool_at p offset)))]
                       [(keyword field-name) value]))
                   (:fields desc)))))))

(defn set-comp-direct!
  "Set component fields using direct memory access (faster than set-comp!).

   Usage:
     (set-comp-direct! world entity Position {:x 10.0 :y 20.0})"
  [world entity comp values]
  (let [desc (resolve-descriptor comp)
        w (vf/world-ptr world)
        cid (comp-id world comp)]
    (when (fl/ecs_has_id w entity cid)
      (let [ptr (cpp/vybe_get_comp_ptr w entity cid)
            ptr-box (cpp/box ptr)]
        (doseq [[field-kw value] values]
          (let [field-name (name field-kw)
                offset (field-offset desc field-name)
                field-type (some (fn [f] (when (= (:name f) field-name) (:type f)))
                                 (:fields desc))
                p (cpp/unbox (cpp/type "void*") ptr-box)]
            (when offset
              (cond
                (is-f32-type? field-type)
                (cpp/vybe_set_float_at p offset (cpp/double. value))

                (is-f64-type? field-type)
                (cpp/vybe_set_double_at p offset (cpp/double. value))

                (is-i32-type? field-type)
                (cpp/vybe_set_i32_at p offset (cpp/long. value))

                (is-i64-type? field-type)
                (cpp/vybe_set_i64_at p offset (cpp/long. value))

                (is-u32-type? field-type)
                (cpp/vybe_set_u32_at p offset (cpp/long. value))

                (is-u64-type? field-type)
                (cpp/vybe_set_u64_at p offset (cpp/long. value))

                (= field-type :bool)
                (cpp/vybe_set_bool_at p offset value)))))))))

;; =============================================================================
;; Standalone component instances - native memory-backed mutable structs
;; =============================================================================

(defn- write-field-to-ptr!
  "Write a field value to native memory at the given offset."
  [ptr-box field-type offset value]
  (let [ptr (cpp/unbox (cpp/type "void*") ptr-box)]
    (cond
      (is-f32-type? field-type)
      (cpp/vybe_set_float_at ptr offset (cpp/double. value))

      (is-f64-type? field-type)
      (cpp/vybe_set_double_at ptr offset (cpp/double. value))

      (is-i32-type? field-type)
      (cpp/vybe_set_i32_at ptr offset (cpp/long. value))

      (is-i64-type? field-type)
      (cpp/vybe_set_i64_at ptr offset (cpp/long. value))

      (is-u32-type? field-type)
      (cpp/vybe_set_u32_at ptr offset (cpp/long. value))

      (is-u64-type? field-type)
      (cpp/vybe_set_u64_at ptr offset (cpp/long. value))

      (= field-type :bool)
      (cpp/vybe_set_bool_at ptr offset value))))

(defn- read-field-from-ptr
  "Read a field value from native memory at the given offset."
  [ptr-box field-type offset]
  (let [ptr (cpp/unbox (cpp/type "const void*") ptr-box)]
    (cond
      (is-f32-type? field-type)
      (cpp/vybe_get_float_at ptr offset)

      (is-f64-type? field-type)
      (cpp/vybe_get_double_at ptr offset)

      (is-i32-type? field-type)
      (cpp/vybe_get_i32_at ptr offset)

      (is-i64-type? field-type)
      (cpp/vybe_get_i64_at ptr offset)

      (is-u32-type? field-type)
      (cpp/vybe_get_u32_at ptr offset)

      (is-u64-type? field-type)
      (cpp/vybe_get_u64_at ptr offset)

      (= field-type :bool)
      (cpp/vybe_get_bool_at ptr offset))))

(defn- create-standalone-instance
  "Create a standalone component instance backed by native memory.
   Returns an atom wrapping a map with :vt/comp, :vt/ptr-box, and field values.
   The atom allows mutation while the pointer provides native memory storage."
  [comp values]
  ;; Ensure metadata is initialized
  (when-not (get-comp-meta comp)
    (init-comp-meta! comp))
  (let [;; Allocate native memory
        size (comp-size comp)
        ptr (cpp/vybe_alloc_comp size)
        ptr-box (cpp/box ptr)
        ;; Convert values to a map if it's a vector (positional args)
        value-map (if (vector? values)
                    (zipmap (map (fn [f] (keyword (:name f))) (:fields comp))
                            values)
                    values)]
    ;; Write initial values to native memory
    (doseq [[field-kw value] value-map]
      (let [field-name (name field-kw)
            offset (field-offset comp field-name)
            field-type (some (fn [f] (when (= (:name f) field-name) (:type f)))
                             (:fields comp))]
        (when offset
          (write-field-to-ptr! ptr-box field-type offset value))))
    ;; Return atom wrapping map with pointer and field values
    (atom (merge value-map
                 {:vt/comp comp
                  :vt/ptr-box ptr-box}))))

(defn standalone-instance?
  "Check if x is a standalone component instance (atom wrapping pointer-backed map)."
  [x]
  (and (not (map? x))
       (contains? (deref x) :vt/ptr-box)))

(defn standalone-get
  "Get a field value from a standalone instance by reading from native memory."
  [instance field-kw]
  (let [data @instance
        comp (:vt/comp data)
        ptr-box (:vt/ptr-box data)
        field-name (name field-kw)
        offset (field-offset comp field-name)
        field-type (some (fn [f] (when (= (:name f) field-name) (:type f)))
                         (:fields comp))]
    (when offset
      (read-field-from-ptr ptr-box field-type offset))))

(defn standalone-merge!
  "Update fields in a standalone instance by writing to native memory.
   Also updates the atom's map so keyword access reflects changes."
  [instance values]
  (let [data @instance
        comp (:vt/comp data)
        ptr-box (:vt/ptr-box data)]
    ;; Write values to native memory
    (doseq [[field-kw value] values]
      (let [field-name (name field-kw)
            offset (field-offset comp field-name)
            field-type (some (fn [f] (when (= (:name f) field-name) (:type f)))
                             (:fields comp))]
        (when offset
          (write-field-to-ptr! ptr-box field-type offset value))))
    ;; Update the atom's map so keyword access works
    (swap! instance merge values)
    instance))

(defn comp-descriptor
  "Get the component descriptor from a component constructor function."
  [comp-fn]
  (get @comp-registry comp-fn))

;; =============================================================================
;; defcomp - Macro to define components
;; =============================================================================

(defn make-comp-constructor
  "Create a component constructor function from a descriptor.
   The constructor can be called with a map or vector to create standalone instances.
   Also registers the function in comp-registry for descriptor lookup."
  [desc]
  (let [constructor (fn [values]
                      (create-standalone-instance desc values))]
    ;; Register the constructor -> descriptor mapping
    (swap! comp-registry assoc constructor desc)
    constructor))

(defmacro defcomp
  "Define a Flecs component type with namespace-qualified name.

   Usage:
     (defcomp Position [[:x :float] [:y :float]])

   Creates a var `Position` that is a callable constructor function.
   Call it to create standalone instances: (Position {:x 1.0 :y 2.0})
   Use (comp-descriptor Position) to get the descriptor for registration.

   The component name will be namespace-qualified and mangled for Flecs
   (e.g., \"vybe_type__Position\" for vybe.type/Position).
   Register with a world using: (register-comp! world Position)

   Supported types:
     :float, :f32    - 32-bit float
     :double, :f64   - 64-bit float
     :i8, :i16, :i32, :i64 - signed integers
     :int            - alias for :i32
     :long           - alias for :i64
     :u8, :u16, :u32, :u64 - unsigned integers
     :bool           - boolean
     :string         - string (char*)
     :entity         - entity reference"
  [sym fields]
  `(def ~sym
     (make-comp-constructor (make-comp ~(mangle-name *ns* sym) ~fields))))

(defn -main [& args])
