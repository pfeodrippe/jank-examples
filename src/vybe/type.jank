(ns vybe.type
  (:require
   ["flecs.h" :as fl :scope ""]
   [vybe.flecs :as vf]))

(comment

  (fl/ecs_id fl/ecs_bool_t)

  ())

;; =============================================================================
;; Type Mapping
;; =============================================================================

;; Map jank type keywords to Flecs primitive type IDs
;; These are accessed via FLECS_IDecs_*_tID_ macros
(def flecs-type-ids
  "Map of jank type keywords to Flecs primitive type ID macro names."
  {:float  "FLECS_IDecs_f32_tID_"
   :f32    "FLECS_IDecs_f32_tID_"
   :double "FLECS_IDecs_f64_tID_"
   :f64    "FLECS_IDecs_f64_tID_"
   :i8     "FLECS_IDecs_i8_tID_"
   :i16    "FLECS_IDecs_i16_tID_"
   :i32    "FLECS_IDecs_i32_tID_"
   :int    "FLECS_IDecs_i32_tID_"
   :i64    "FLECS_IDecs_i64_tID_"
   :long   "FLECS_IDecs_i64_tID_"
   :u8     "FLECS_IDecs_u8_tID_"
   :u16    "FLECS_IDecs_u16_tID_"
   :u32    "FLECS_IDecs_u32_tID_"
   :u64    "FLECS_IDecs_u64_tID_"
   :bool   "FLECS_IDecs_bool_tID_"
   :string "FLECS_IDecs_string_tID_"
   :entity "FLECS_IDecs_entity_tID_"})

;; =============================================================================
;; make-comp - Pure function to create component descriptors
;; =============================================================================

(defn make-comp
  "Create a component descriptor from a name and field definitions.
   Returns a map that can later be registered with a Flecs world.

   Usage:
     (make-comp 'Position [[:x :float] [:y :float]])

   Returns:
     {:name \"Position\"
      :fields [{:name \"x\" :type :float}
               {:name \"y\" :type :float}]}"
  [sym fields]
  (let [field-maps (mapv (fn [[fname ftype]]
                           {:name (name fname)
                            :type ftype})
                         fields)]
    {:name (str sym)
     :fields field-maps}))

;; =============================================================================
;; C++ Helper for ecs_struct registration
;; =============================================================================

;; Helper to register a struct with up to 4 members using ecs_struct_init
;; We use explicit struct initialization to avoid compound literal issues with JIT
(cpp/raw "
// Helper to get Flecs primitive type ID
ecs_entity_t vybe_get_flecs_type(ecs_world_t* w, int type_id) {
  switch(type_id) {
    case 0: return ecs_id(ecs_f32_t);   // :float, :f32
    case 1: return ecs_id(ecs_f64_t);   // :double, :f64
    case 2: return ecs_id(ecs_i8_t);    // :i8
    case 3: return ecs_id(ecs_i16_t);   // :i16
    case 4: return ecs_id(ecs_i32_t);   // :i32, :int
    case 5: return ecs_id(ecs_i64_t);   // :i64, :long
    case 6: return ecs_id(ecs_u8_t);    // :u8
    case 7: return ecs_id(ecs_u16_t);   // :u16
    case 8: return ecs_id(ecs_u32_t);   // :u32
    case 9: return ecs_id(ecs_u64_t);   // :u64
    case 10: return ecs_id(ecs_bool_t); // :bool
    case 11: return ecs_id(ecs_string_t); // :string
    case 12: return ecs_id(ecs_entity_t); // :entity
    default: return 0;
  }
}

// Register a struct with 1 member
ecs_entity_t vybe_register_struct_1(
    ecs_world_t* w, const char* name,
    const char* n0, int t0
) {
  ecs_entity_desc_t ent_desc = {};
  ent_desc.name = name;
  ecs_entity_t ent = ecs_entity_init(w, &ent_desc);

  ecs_struct_desc_t desc = {};
  desc.entity = ent;
  desc.members[0].name = n0;
  desc.members[0].type = vybe_get_flecs_type(w, t0);
  return ecs_struct_init(w, &desc);
}

// Register a struct with 2 members
ecs_entity_t vybe_register_struct_2(
    ecs_world_t* w, const char* name,
    const char* n0, int t0,
    const char* n1, int t1
) {
  ecs_entity_desc_t ent_desc = {};
  ent_desc.name = name;
  ecs_entity_t ent = ecs_entity_init(w, &ent_desc);

  ecs_struct_desc_t desc = {};
  desc.entity = ent;
  desc.members[0].name = n0;
  desc.members[0].type = vybe_get_flecs_type(w, t0);
  desc.members[1].name = n1;
  desc.members[1].type = vybe_get_flecs_type(w, t1);
  return ecs_struct_init(w, &desc);
}

// Register a struct with 3 members
ecs_entity_t vybe_register_struct_3(
    ecs_world_t* w, const char* name,
    const char* n0, int t0,
    const char* n1, int t1,
    const char* n2, int t2
) {
  ecs_entity_desc_t ent_desc = {};
  ent_desc.name = name;
  ecs_entity_t ent = ecs_entity_init(w, &ent_desc);

  ecs_struct_desc_t desc = {};
  desc.entity = ent;
  desc.members[0].name = n0;
  desc.members[0].type = vybe_get_flecs_type(w, t0);
  desc.members[1].name = n1;
  desc.members[1].type = vybe_get_flecs_type(w, t1);
  desc.members[2].name = n2;
  desc.members[2].type = vybe_get_flecs_type(w, t2);
  return ecs_struct_init(w, &desc);
}

// Register a struct with 4 members
ecs_entity_t vybe_register_struct_4(
    ecs_world_t* w, const char* name,
    const char* n0, int t0,
    const char* n1, int t1,
    const char* n2, int t2,
    const char* n3, int t3
) {
  ecs_entity_desc_t ent_desc = {};
  ent_desc.name = name;
  ecs_entity_t ent = ecs_entity_init(w, &ent_desc);

  ecs_struct_desc_t desc = {};
  desc.entity = ent;
  desc.members[0].name = n0;
  desc.members[0].type = vybe_get_flecs_type(w, t0);
  desc.members[1].name = n1;
  desc.members[1].type = vybe_get_flecs_type(w, t1);
  desc.members[2].name = n2;
  desc.members[2].type = vybe_get_flecs_type(w, t2);
  desc.members[3].name = n3;
  desc.members[3].type = vybe_get_flecs_type(w, t3);
  return ecs_struct_init(w, &desc);
}
")

;; Map type keywords to integer IDs for the C++ helper
(def type-to-id
  {:float 0, :f32 0
   :double 1, :f64 1
   :i8 2
   :i16 3
   :i32 4, :int 4
   :i64 5, :long 5
   :u8 6
   :u16 7
   :u32 8
   :u64 9
   :bool 10
   :string 11
   :entity 12})

;; =============================================================================
;; register-comp! - Register component with Flecs world
;; =============================================================================

(defn register-comp!
  "Register a component descriptor with a Flecs world using ecs_struct.
   Returns the Flecs entity ID for the component.

   Usage:
     (def Position (make-comp 'Position [[:x :float] [:y :float]]))
     (register-comp! world Position)"
  [world comp]
  (let [w (vf/world-ptr world)
        comp-name (:name comp)
        fields (:fields comp)
        n (count fields)]
    (case n
      1 (cpp/vybe_register_struct_1
         w comp-name
         (:name (nth fields 0)) (get type-to-id (:type (nth fields 0))))

      2 (cpp/vybe_register_struct_2
         w comp-name
         (:name (nth fields 0)) (get type-to-id (:type (nth fields 0)))
         (:name (nth fields 1)) (get type-to-id (:type (nth fields 1))))

      3 (cpp/vybe_register_struct_3
         w comp-name
         (:name (nth fields 0)) (get type-to-id (:type (nth fields 0)))
         (:name (nth fields 1)) (get type-to-id (:type (nth fields 1)))
         (:name (nth fields 2)) (get type-to-id (:type (nth fields 2))))

      4 (cpp/vybe_register_struct_4
         w comp-name
         (:name (nth fields 0)) (get type-to-id (:type (nth fields 0)))
         (:name (nth fields 1)) (get type-to-id (:type (nth fields 1)))
         (:name (nth fields 2)) (get type-to-id (:type (nth fields 2)))
         (:name (nth fields 3)) (get type-to-id (:type (nth fields 3))))

      ;; Default: throw for unsupported member count
      (throw (ex-info "Component must have 1-4 fields" {:count n})))))

;; =============================================================================
;; defcomp - Macro to define components
;; =============================================================================

(defmacro defcomp
  "Define a Flecs component type.

   Usage:
     (defcomp Position [[:x :float] [:y :float]])

   Creates a var `Position` containing the component descriptor.
   Register with a world using: (register-comp! world Position)

   Supported types:
     :float, :f32    - 32-bit float
     :double, :f64   - 64-bit float
     :i8, :i16, :i32, :i64 - signed integers
     :int            - alias for :i32
     :long           - alias for :i64
     :u8, :u16, :u32, :u64 - unsigned integers
     :bool           - boolean
     :string         - string (char*)
     :entity         - entity reference"
  [sym fields]
  `(def ~sym (make-comp '~sym ~fields)))

(defn -main [& args])
