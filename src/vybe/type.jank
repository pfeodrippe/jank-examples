(ns vybe.type
  (:require
   ["flecs.h" :as fl :scope ""]))

;; This `eita` is being used just to measure eval time. Caching form hash takes it from 7/6s to 4/3s.
(cpp/raw "
#include <chrono>
#include <iostream>

void eita()
{
    const auto now = std::chrono::system_clock::now();
    const std::time_t t_c = std::chrono::system_clock::to_time_t(now);
    std::cout << \"The system clock is currently at \" << std::ctime(&t_c);
}
")

(cpp/eita)

;; =============================================================================
;; Local helpers (duplicated from vybe.flecs to avoid circular dependency)
;; =============================================================================

(defn- -get-world-box
  "Get the boxed world pointer from a world (either raw box or user type).
   Works with both make-world (returns opaque box) and make-world-map (returns user type)."
  [world]
  (let [wb (get world :vf/world-box)]
    (if wb
      wb
      world)))

(defmacro -world-ptr
  "Extract ecs_world_t* from boxed world. Returns raw pointer for use in C calls."
  [world]
  `(cpp/unbox (cpp/type "ecs_world_t*") (-get-world-box ~world)))

(defn- -make-world
  "Create a new Flecs world (internal use only for type registration)."
  []
  (cpp/box (fl/ecs_init)))

;; Component name registry for lookup by mangled name
(defonce ^:private -comp-name-registry (atom {}))

(defn register-descriptor-by-name
  "Register a component descriptor by its mangled name for lookup."
  [desc]
  (when desc
    (swap! -comp-name-registry assoc (:name desc) desc)))

(defn resolve-descriptor-by-name
  "Resolve a component descriptor by its mangled name string.
   Returns nil if not found."
  [name-str]
  (get @-comp-name-registry name-str))

;; Forward declarations for functions used before they're defined
(declare create-comp-user-type)

;; =============================================================================
;; Name mangling - convert Clojure namespaced names to Flecs-safe identifiers
;; =============================================================================

(defn mangle-char
  "Replace . and - with _"
  [c]
  (cond
    (= c \.) \_
    (= c \-) \_
    :else c))

(defn mangle-name
  "Convert a namespaced symbol to a Flecs-safe identifier.
   Replaces . with _ and - with _ and separates ns/sym with __
   Example: 'vybe.type-test/Position' -> 'vybe_type_test__Position'"
  [ns-str sym-str]
  (let [mangled-ns (apply str (map mangle-char (str ns-str)))]
    (str mangled-ns "__" sym-str)))

(defn mangle-keyword
  "Convert a keyword to a Flecs-safe identifier.
   For qualified keywords: :foo.bar/baz -> foo_bar__baz
   For simple keywords: :my-tag -> my_tag"
  [kw]
  (let [ns-part (namespace kw)
        name-part (name kw)
        mangled-name (apply str (map mangle-char name-part))]
    (if ns-part
      (let [mangled-ns (apply str (map mangle-char ns-part))]
        (str mangled-ns "__" mangled-name))
      mangled-name)))

;; =============================================================================
;; make-comp - Pure function to create component descriptors
;; =============================================================================

(defn make-comp
  "Create a component descriptor from a mangled name string and field definitions.
   Returns a map that can later be registered with a Flecs world.

   Usage:
     (make-comp \"vybe_type__Position\" [[:x :float] [:y :float]])

   Returns:
     {:name \"vybe_type__Position\"
      :fields [{:name \"x\" :type :float}
               {:name \"y\" :type :float}]}"
  [name-str fields]
  (let [field-maps (mapv (fn [[fname ftype]]
                           {:name (name fname)
                            :type ftype})
                         fields)]
    {:name name-str
     :fields field-maps}))

;; =============================================================================
;; Type ID lookup - maps keywords to Flecs primitive type entities
;; =============================================================================

(defn flecs-type-id
  "Get the Flecs entity ID for a primitive type keyword."
  [type-kw]
  (cond
    (or (= type-kw :float) (= type-kw :f32))    fl/FLECS_IDecs_f32_tID_
    (or (= type-kw :double) (= type-kw :f64))   fl/FLECS_IDecs_f64_tID_
    (= type-kw :i8)                             fl/FLECS_IDecs_i8_tID_
    (= type-kw :i16)                            fl/FLECS_IDecs_i16_tID_
    (or (= type-kw :i32) (= type-kw :int))      fl/FLECS_IDecs_i32_tID_
    (or (= type-kw :i64) (= type-kw :long))     fl/FLECS_IDecs_i64_tID_
    (= type-kw :u8)                             fl/FLECS_IDecs_u8_tID_
    (= type-kw :u16)                            fl/FLECS_IDecs_u16_tID_
    (= type-kw :u32)                            fl/FLECS_IDecs_u32_tID_
    (= type-kw :u64)                            fl/FLECS_IDecs_u64_tID_
    (= type-kw :bool)                           fl/FLECS_IDecs_bool_tID_
    (= type-kw :string)                         fl/FLECS_IDecs_string_tID_
    (= type-kw :entity)                         fl/FLECS_IDecs_entity_tID_
    :else (throw (ex-info "Unknown type" {:type type-kw}))))

;; =============================================================================
;; C++ helpers for struct registration (builder pattern)
;; =============================================================================

;; Builder pattern: create desc, add members one at a time, then register
(cpp/raw "
struct VybeStructBuilder {
  ecs_world_t* world;
  ecs_struct_desc_t desc;
  int member_idx;
};

VybeStructBuilder* vybe_struct_begin(ecs_world_t* w, const char* name) {
  auto* b = new VybeStructBuilder();
  b->world = w;
  b->desc = {};
  ecs_entity_desc_t ed = {}; ed.name = name;
  b->desc.entity = ecs_entity_init(w, &ed);
  b->member_idx = 0;
  return b;
}

void vybe_struct_add_member(VybeStructBuilder* b, const char* name, ecs_entity_t type) {
  if (b->member_idx < 32) {
    b->desc.members[b->member_idx].name = name;
    b->desc.members[b->member_idx].type = type;
    b->member_idx++;
  }
}

ecs_entity_t vybe_struct_end(VybeStructBuilder* b) {
  ecs_entity_t result = ecs_struct_init(b->world, &b->desc);
  delete b;
  return result;
}

// =============================================================================
// Field access helpers using meta cursor API
// =============================================================================

// Add component to entity (ensures it exists)
void vybe_add_comp(ecs_world_t* w, ecs_entity_t e, ecs_entity_t comp) {
  if (!w || !e || !comp) return;
  const ecs_type_info_t* ti = ecs_get_type_info(w, comp);
  if (ti && ti->size > 0) {
    ecs_ensure_id(w, e, comp, ti->size);
  }
}

// Set a float field on a component (entity version - gets pointer internally)
void vybe_set_field_float(ecs_world_t* w, ecs_entity_t e, ecs_entity_t comp, const char* field_name, double value) {
  if (!w || !e || !comp || !field_name) return;
  const ecs_type_info_t* ti = ecs_get_type_info(w, comp);
  if (!ti || ti->size == 0) return;
  void* ptr = ecs_ensure_id(w, e, comp, ti->size);
  if (!ptr) return;
  ecs_meta_cursor_t cur = ecs_meta_cursor(w, comp, ptr);
  ecs_meta_push(&cur);
  ecs_meta_member(&cur, field_name);
  ecs_meta_set_float(&cur, value);
}

// Set an int field on a component
void vybe_set_field_int(ecs_world_t* w, ecs_entity_t e, ecs_entity_t comp, const char* field_name, int64_t value) {
  if (!w || !e || !comp || !field_name) return;
  const ecs_type_info_t* ti = ecs_get_type_info(w, comp);
  if (!ti || ti->size == 0) return;
  void* ptr = ecs_ensure_id(w, e, comp, ti->size);
  if (!ptr) return;
  ecs_meta_cursor_t cur = ecs_meta_cursor(w, comp, ptr);
  ecs_meta_push(&cur);
  ecs_meta_member(&cur, field_name);
  ecs_meta_set_int(&cur, value);
}

// Set a uint field on a component
void vybe_set_field_uint(ecs_world_t* w, ecs_entity_t e, ecs_entity_t comp, const char* field_name, uint64_t value) {
  if (!w || !e || !comp || !field_name) return;
  const ecs_type_info_t* ti = ecs_get_type_info(w, comp);
  if (!ti || ti->size == 0) return;
  void* ptr = ecs_ensure_id(w, e, comp, ti->size);
  if (!ptr) return;
  ecs_meta_cursor_t cur = ecs_meta_cursor(w, comp, ptr);
  ecs_meta_push(&cur);
  ecs_meta_member(&cur, field_name);
  ecs_meta_set_uint(&cur, value);
}

// Set a bool field on a component
void vybe_set_field_bool(ecs_world_t* w, ecs_entity_t e, ecs_entity_t comp, const char* field_name, bool value) {
  if (!w || !e || !comp || !field_name) return;
  const ecs_type_info_t* ti = ecs_get_type_info(w, comp);
  if (!ti || ti->size == 0) return;
  void* ptr = ecs_ensure_id(w, e, comp, ti->size);
  if (!ptr) return;
  ecs_meta_cursor_t cur = ecs_meta_cursor(w, comp, ptr);
  ecs_meta_push(&cur);
  ecs_meta_member(&cur, field_name);
  ecs_meta_set_bool(&cur, value);
}

// Check if a component is registered in the given world
bool vybe_has_type_info(ecs_world_t* w, ecs_entity_t comp) {
  if (!w || !comp) return false;
  return ecs_get_type_info(w, comp) != nullptr;
}

// Get a float field from a component
double vybe_get_field_float(ecs_world_t* w, ecs_entity_t e, ecs_entity_t comp, const char* field_name) {
  if (!w || !e || !comp || !field_name) return 0.0;
  const void* ptr = ecs_get_id(w, e, comp);
  if (!ptr) return 0.0;
  ecs_meta_cursor_t cur = ecs_meta_cursor(w, comp, const_cast<void*>(ptr));
  ecs_meta_push(&cur);
  ecs_meta_member(&cur, field_name);
  return ecs_meta_get_float(&cur);
}

// Get an int field from a component
int64_t vybe_get_field_int(ecs_world_t* w, ecs_entity_t e, ecs_entity_t comp, const char* field_name) {
  if (!w || !e || !comp || !field_name) return 0;
  const void* ptr = ecs_get_id(w, e, comp);
  if (!ptr) return 0;
  ecs_meta_cursor_t cur = ecs_meta_cursor(w, comp, const_cast<void*>(ptr));
  ecs_meta_push(&cur);
  ecs_meta_member(&cur, field_name);
  return ecs_meta_get_int(&cur);
}

// Get a uint field from a component
uint64_t vybe_get_field_uint(ecs_world_t* w, ecs_entity_t e, ecs_entity_t comp, const char* field_name) {
  if (!w || !e || !comp || !field_name) return 0;
  const void* ptr = ecs_get_id(w, e, comp);
  if (!ptr) return 0;
  ecs_meta_cursor_t cur = ecs_meta_cursor(w, comp, const_cast<void*>(ptr));
  ecs_meta_push(&cur);
  ecs_meta_member(&cur, field_name);
  return ecs_meta_get_uint(&cur);
}

// Get a bool field from a component
bool vybe_get_field_bool(ecs_world_t* w, ecs_entity_t e, ecs_entity_t comp, const char* field_name) {
  if (!w || !e || !comp || !field_name) return false;
  const void* ptr = ecs_get_id(w, e, comp);
  if (!ptr) return false;
  ecs_meta_cursor_t cur = ecs_meta_cursor(w, comp, const_cast<void*>(ptr));
  ecs_meta_push(&cur);
  ecs_meta_member(&cur, field_name);
  return ecs_meta_get_bool(&cur);
}

// =============================================================================
// Field metadata access - get offsets and sizes from Flecs
// =============================================================================

// Get the number of members in a struct component
int32_t vybe_get_member_count(ecs_world_t* w, ecs_entity_t comp) {
  const EcsStruct* st = ecs_get(w, comp, EcsStruct);
  if (!st) return 0;
  return ecs_vec_count(&st->members);
}

// Get the offset of a member by index
int32_t vybe_get_member_offset(ecs_world_t* w, ecs_entity_t comp, int32_t idx) {
  const EcsStruct* st = ecs_get(w, comp, EcsStruct);
  if (!st) return -1;
  if (idx < 0 || idx >= ecs_vec_count(&st->members)) return -1;
  const ecs_member_t* m = ecs_vec_get_t(&st->members, ecs_member_t, idx);
  return m->offset;
}

// Get the size of a member by index
int32_t vybe_get_member_size(ecs_world_t* w, ecs_entity_t comp, int32_t idx) {
  const EcsStruct* st = ecs_get(w, comp, EcsStruct);
  if (!st) return -1;
  if (idx < 0 || idx >= ecs_vec_count(&st->members)) return -1;
  const ecs_member_t* m = ecs_vec_get_t(&st->members, ecs_member_t, idx);
  return m->size;
}

// Get the name of a member by index (returns empty string if not found)
const char* vybe_get_member_name(ecs_world_t* w, ecs_entity_t comp, int32_t idx) {
  const EcsStruct* st = ecs_get(w, comp, EcsStruct);
  if (!st) return \"\";
  if (idx < 0 || idx >= ecs_vec_count(&st->members)) return \"\";
  const ecs_member_t* m = ecs_vec_get_t(&st->members, ecs_member_t, idx);
  return m->name ? m->name : \"\";
}

// Get the total size of a component
int32_t vybe_get_comp_size(ecs_world_t* w, ecs_entity_t comp) {
  const ecs_type_info_t* ti = ecs_get_type_info(w, comp);
  return ti ? ti->size : 0;
}

// =============================================================================
// Direct memory access - use offsets for O(1) field access
// =============================================================================

// Get component pointer for an entity (returns NULL if entity doesn't have it)
void* vybe_get_comp_ptr(ecs_world_t* w, ecs_entity_t e, ecs_entity_t comp) {
  // First check if entity has the component
  if (!ecs_has_id(w, e, comp)) return nullptr;
  const ecs_type_info_t* ti = ecs_get_type_info(w, comp);
  if (!ti || ti->size == 0) return nullptr;
  return ecs_ensure_id(w, e, comp, ti->size);
}

// Get const component pointer for an entity (returns NULL if entity doesn't have it)
const void* vybe_get_comp_ptr_const(ecs_world_t* w, ecs_entity_t e, ecs_entity_t comp) {
  if (!ecs_has_id(w, e, comp)) return nullptr;
  return ecs_get_id(w, e, comp);
}

// Direct set float at offset
void vybe_set_float_at(void* base, int32_t offset, double value) {
  if (!base) return;
  *(float*)((char*)base + offset) = (float)value;
}

// Direct set double at offset
void vybe_set_double_at(void* base, int32_t offset, double value) {
  if (!base) return;
  *(double*)((char*)base + offset) = value;
}

// Direct set i32 at offset
void vybe_set_i32_at(void* base, int32_t offset, int64_t value) {
  if (!base) return;
  *(int32_t*)((char*)base + offset) = (int32_t)value;
}

// Direct set i64 at offset
void vybe_set_i64_at(void* base, int32_t offset, int64_t value) {
  if (!base) return;
  *(int64_t*)((char*)base + offset) = value;
}

// Direct set u32 at offset
void vybe_set_u32_at(void* base, int32_t offset, uint64_t value) {
  if (!base) return;
  *(uint32_t*)((char*)base + offset) = (uint32_t)value;
}

// Direct set u64 at offset
void vybe_set_u64_at(void* base, int32_t offset, uint64_t value) {
  if (!base) return;
  *(uint64_t*)((char*)base + offset) = value;
}

// Direct set bool at offset
void vybe_set_bool_at(void* base, int32_t offset, bool value) {
  if (!base) return;
  *(bool*)((char*)base + offset) = value;
}

// Direct get float at offset
double vybe_get_float_at(const void* base, int32_t offset) {
  if (!base) return 0.0;
  return (double)*(const float*)((const char*)base + offset);
}

// Direct get double at offset
double vybe_get_double_at(const void* base, int32_t offset) {
  if (!base) return 0.0;
  return *(const double*)((const char*)base + offset);
}

// Direct get i32 at offset
int64_t vybe_get_i32_at(const void* base, int32_t offset) {
  if (!base) return 0;
  return (int64_t)*(const int32_t*)((const char*)base + offset);
}

// Direct get i64 at offset
int64_t vybe_get_i64_at(const void* base, int32_t offset) {
  if (!base) return 0;
  return *(const int64_t*)((const char*)base + offset);
}

// Direct get u32 at offset
uint64_t vybe_get_u32_at(const void* base, int32_t offset) {
  if (!base) return 0;
  return (uint64_t)*(const uint32_t*)((const char*)base + offset);
}

// Direct get u64 at offset
uint64_t vybe_get_u64_at(const void* base, int32_t offset) {
  if (!base) return 0;
  return *(const uint64_t*)((const char*)base + offset);
}

// Direct get bool at offset
bool vybe_get_bool_at(const void* base, int32_t offset) {
  if (!base) return false;
  return *(const bool*)((const char*)base + offset);
}

// =============================================================================
// Standalone instance memory allocation
// =============================================================================

// Allocate memory for a standalone component instance
void* vybe_alloc_comp(int32_t size) {
  return calloc(1, size);  // Zero-initialized
}

// Free standalone component memory
void vybe_free_comp(void* ptr) {
  if (ptr) free(ptr);
}
")

;; =============================================================================
;; Component metadata cache - stores offsets and sizes for direct memory access
;; =============================================================================

;; Global cache: component-name -> {:offsets {field-name offset} :sizes {field-name size} :comp-size size}
(defonce ^:private comp-meta-cache (atom {}))

;; Global registry: maps component constructor functions to their descriptors
(defonce ^:private comp-registry (atom {}))

(defn- cache-comp-meta!
  "Cache field offsets and sizes for a component after registration."
  [world comp cid]
  (let [w (-world-ptr world)
        w-box (cpp/box w)
        member-count (cpp/vybe_get_member_count w cid)
        comp-size (cpp/vybe_get_comp_size w cid)]
    ;; Build offset and size maps for each field
    (loop [idx 0
           offsets {}
           sizes {}]
      (if (>= idx member-count)
        ;; Done - cache the metadata
        (swap! comp-meta-cache assoc (:name comp)
               {:offsets offsets
                :sizes sizes
                :comp-size comp-size
                :cid cid})
        ;; Get metadata for this field
        (let [wb (cpp/unbox (cpp/type "ecs_world_t*") w-box)
              fname (cpp/vybe_get_member_name wb cid idx)
              offset (cpp/vybe_get_member_offset wb cid idx)
              size (cpp/vybe_get_member_size wb cid idx)]
          (recur (inc idx)
                 (assoc offsets fname offset)
                 (assoc sizes fname size)))))))

(defn get-comp-meta
  "Get cached metadata for a component. Returns nil if not cached."
  [comp]
  (let [desc (if (map? comp) comp (get @comp-registry comp))]
    (get @comp-meta-cache (:name desc))))

(defn comp-size
  "Get the total size of a component in bytes. Requires prior registration."
  [comp]
  (:comp-size (get-comp-meta comp)))

(defn field-offset
  "Get the byte offset of a field. Requires prior registration."
  [comp field-name]
  (get-in (get-comp-meta comp) [:offsets (if (keyword? field-name)
                                            (name field-name)
                                            field-name)]))

(defn field-size
  "Get the byte size of a field. Requires prior registration."
  [comp field-name]
  (get-in (get-comp-meta comp) [:sizes (if (keyword? field-name)
                                          (name field-name)
                                          field-name)]))

;; =============================================================================
;; Component resolution - handle both descriptors and constructor functions
;; =============================================================================

(defn resolve-descriptor
  "Resolve a component to its descriptor.
   Accepts either a descriptor map or a constructor function.
   Prioritizes name-based lookup for stability across JIT recompilation."
  [comp]
  (cond
    (map? comp) comp  ; Already a descriptor
    :else
    ;; Prioritize name-based lookup (stable across JIT recompilation)
    ;; Function identity can change when JIT recompiles, but the name is stable
    (or (when-let [comp-name (:vt/comp-name (meta comp))]
          (resolve-descriptor-by-name comp-name))
        ;; Fallback to function identity lookup
        (get @comp-registry comp))))

;; =============================================================================
;; register-comp! - Register component with Flecs world
;; =============================================================================

;; C++ helper for pointer to int64 conversion (duplicated from flecs.jank)
(cpp/raw "
// Convert a pointer to int64 for use as a stable cache key
int64_t vybe_type_ptr_to_int64(ecs_world_t* ptr) {
  return reinterpret_cast<int64_t>(ptr);
}
")

;; Cache for registered component IDs: {world-identity -> {comp-name -> cid}}
(defonce ^:private comp-id-cache (atom {}))

(defn- get-world-identity
  "Get a unique identity for a world (using the pointer address as integer)."
  [world]
  ;; Convert pointer to integer for stable identity
  (cpp/vybe_type_ptr_to_int64 (-world-ptr world)))

(defn register-comp!
  "Register a component descriptor with a Flecs world using ecs_struct.
   Returns the Flecs entity ID for the component. Supports up to 32 fields.
   Also caches field offsets and sizes for direct memory access.

   Usage:
     (defcomp Position [[:x :float] [:y :float]])
     (register-comp! world Position)"
  [world comp]
  (let [desc (resolve-descriptor comp)
        w (-world-ptr world)
        builder (cpp/box (cpp/vybe_struct_begin w (:name desc)))]
    (doseq [field (:fields desc)]
      (cpp/vybe_struct_add_member
       (cpp/unbox (cpp/type "VybeStructBuilder*") builder)
       (:name field)
       (flecs-type-id (:type field))))
    (let [cid (cpp/vybe_struct_end (cpp/unbox (cpp/type "VybeStructBuilder*") builder))
          w-id (get-world-identity world)]
      ;; Cache the component ID for lookup
      (swap! comp-id-cache assoc-in [w-id (:name desc)] cid)
      ;; Cache the field metadata for direct memory access
      (cache-comp-meta! world desc cid)
      cid)))

;; =============================================================================
;; init-comp-meta! - Initialize component metadata using a temporary world
;; =============================================================================

(defn init-comp-meta!
  "Initialize component metadata using a temporary world.
   This allows getting field offsets before registering with a real world.
   Useful for pre-caching metadata at startup.

   Note: Uses full world (not mini) because meta addon is required for structs.
   The world is intentionally not destroyed to avoid issues with jank's
   lazy evaluation accessing the world after destruction.

   Usage:
     (defcomp Position [[:x :float] [:y :float]])
     (init-comp-meta! Position)
     ;; Now field-offset and comp-size work without a real world"
  [comp]
  (let [desc (resolve-descriptor comp)
        temp-world (-make-world)]
    (register-comp! temp-world desc))
  nil)

;; =============================================================================
;; Component data access - add, get, set fields
;; =============================================================================

(defn comp-id
  "Get the registered entity ID for a component descriptor.
   Auto-registers the component if not already registered with this world."
  [world comp]
  (let [desc (resolve-descriptor comp)
      w (-world-ptr world)
        w-id (get-world-identity world)
        ;; Try cache first
      cached-cid (get-in @comp-id-cache [w-id (:name desc)])
      cached-valid? (and cached-cid (cpp/vybe_has_type_info w cached-cid))]
    (cond
      cached-valid?
      cached-cid

      ;; Cached but invalid (e.g. world pointer reused) - re-register and refresh cache
      cached-cid
      (do
        (swap! comp-id-cache update w-id dissoc (:name desc))
        (register-comp! world comp))

      :else
      ;; Not in cache - try lookup, then auto-register if needed
      (let [cid (fl/ecs_lookup w (:name desc))]
        (if (> cid 0)
          cid
          ;; Not found - auto-register the component
          (register-comp! world comp))))))

(defn has-comp?
  "Check if an entity has a component.

   Usage:
     (has-comp? world entity Position)"
  [world entity comp]
  (let [w (-world-ptr world)
        cid (comp-id world comp)]
    (fl/ecs_has_id w entity cid)))

(defn- is-float-type? [t]
  (or (= t :float) (= t :f32) (= t :double) (= t :f64)))

(defn- is-int-type? [t]
  (or (= t :i8) (= t :i16) (= t :i32) (= t :i64) (= t :int) (= t :long)))

(defn- is-uint-type? [t]
  (or (= t :u8) (= t :u16) (= t :u32) (= t :u64)))

(defn add-comp!
  "Add a component to an entity with optional initial values.

   Usage:
     (add-comp! world entity Position)                    ; zero-initialized
     (add-comp! world entity Position {:x 10.0 :y 20.0})  ; with map
     (add-comp! world entity Position 10.0 20.0)          ; positional args
     (add-comp! world entity Position instance)           ; from component instance"
  [world entity comp & args]
  (let [desc (resolve-descriptor comp)
        w (-world-ptr world)
        w-box (cpp/box w)
        cid (comp-id world comp)]
    ;; Add the component
    (cpp/vybe_add_comp w entity cid)
    ;; Set initial values if provided
    (when (seq args)
      (let [first-arg (first args)
            ;; Extract values from different input forms
            values (cond
                     ;; Component instance (user type with :vt/comp)
                     (contains? first-arg :vt/comp)
                     (let [instance-desc (:vt/comp first-arg)]
                       ;; Read all field values from the instance
                       (into {}
                             (map (fn [f]
                                    (let [field-kw (keyword (:name f))]
                                      [field-kw (get first-arg field-kw)]))
                                  (:fields instance-desc))))

                     ;; Plain map {:x 10 :y 20}
                     (map? first-arg)
                     first-arg

                     ;; Positional args: convert to map using field order
                     :else
                     (zipmap (map (fn [f] (keyword (:name f))) (:fields desc))
                             args))]
        (doseq [[field-kw value] values]
          (let [field-name (name field-kw)
                field-type (some (fn [f] (when (= (:name f) field-name) (:type f)))
                                 (:fields desc))
                wb (cpp/unbox (cpp/type "ecs_world_t*") w-box)]
            (cond
              (is-float-type? field-type)
              (cpp/vybe_set_field_float wb entity cid field-name (cpp/double. value))

              (is-int-type? field-type)
              (cpp/vybe_set_field_int wb entity cid field-name (cpp/long. value))

              (is-uint-type? field-type)
              (cpp/vybe_set_field_uint wb entity cid field-name (cpp/long. value))

              (= field-type :bool)
              (cpp/vybe_set_field_bool wb entity cid field-name value))))))))

(defn get-comp
  "Get component data from an entity as a user-type instance.
   Returns an instance that supports the map interface and merge for updates.

   Usage:
     (get-comp world entity Position)
     ;; => #vybe_type__Position{:x 10.0, :y 20.0}

     (let [pos (get-comp world entity Position)]
       (:x pos)              ; read field
       (merge pos {:x 5}))   ; update field (native merge!)"
  [world entity comp]
  (let [desc (resolve-descriptor comp)
        w (-world-ptr world)
        cid (comp-id world comp)]
    (when (fl/ecs_has_id w entity cid)
      ;; Ensure metadata is initialized for this component
      (when-not (get-comp-meta desc)
        (init-comp-meta! desc))
      ;; Get mutable pointer to the entity's component memory
      (let [ptr (cpp/vybe_get_comp_ptr w entity cid)
            ptr-box (cpp/box ptr)
            ;; Get factory from descriptor or create it lazily
            ut-factory (or (:vt/ut-factory desc)
                           (create-comp-user-type desc))]
        ;; Return user-type instance backed by entity's component memory
        (ut-factory {:ptr-box ptr-box :comp desc})))))

(defn comp-ref?
  "Check if x is a ComponentRef (returned by get-comp)."
  [x]
  (and (map? x) (contains? x :vt/comp)))

;; Type predicates for field types
(defn- is-f32-type? [t]
  (or (= t :float) (= t :f32)))

(defn- is-f64-type? [t]
  (or (= t :double) (= t :f64)))

(defn- is-i32-type? [t]
  (or (= t :i32) (= t :int) (= t :i8) (= t :i16)))

(defn- is-i64-type? [t]
  (or (= t :i64) (= t :long)))

(defn- is-u32-type? [t]
  (or (= t :u32) (= t :u8) (= t :u16)))

(defn- is-u64-type? [t]
  (= t :u64))

(defn- write-field-to-ptr!
  "Write a field value to native memory at the given offset."
  [ptr-box field-type offset value]
  (let [ptr (cpp/unbox (cpp/type "void*") ptr-box)]
    (cond
      (is-f32-type? field-type)
      (cpp/vybe_set_float_at ptr offset (cpp/double. value))

      (is-f64-type? field-type)
      (cpp/vybe_set_double_at ptr offset (cpp/double. value))

      (is-i32-type? field-type)
      (cpp/vybe_set_i32_at ptr offset (cpp/long. value))

      (is-i64-type? field-type)
      (cpp/vybe_set_i64_at ptr offset (cpp/long. value))

      (is-u32-type? field-type)
      (cpp/vybe_set_u32_at ptr offset (cpp/long. value))

      (is-u64-type? field-type)
      (cpp/vybe_set_u64_at ptr offset (cpp/long. value))

      (= field-type :bool)
      (cpp/vybe_set_bool_at ptr offset value))))

(defn- read-field-from-ptr
  "Read a field value from native memory at the given offset."
  [ptr-box field-type offset]
  (let [ptr (cpp/unbox (cpp/type "void*") ptr-box)]
    (cond
      (is-f32-type? field-type)
      (cpp/vybe_get_float_at ptr offset)

      (is-f64-type? field-type)
      (cpp/vybe_get_double_at ptr offset)

      (is-i32-type? field-type)
      (cpp/vybe_get_i32_at ptr offset)

      (is-i64-type? field-type)
      (cpp/vybe_get_i64_at ptr offset)

      (is-u32-type? field-type)
      (cpp/vybe_get_u32_at ptr offset)

      (is-u64-type? field-type)
      (cpp/vybe_get_u64_at ptr offset)

      (= field-type :bool)
      (cpp/vybe_get_bool_at ptr offset))))

(defn merge!
  "Update component fields. Works with:
   1. A standalone instance: (merge! pos {:x 5})
   2. A ComponentRef from get-comp: (merge! pos {:x 5})
   3. Explicit args: (merge! world entity Position {:x 5})

   Usage:
     (let [pos (Position {:x 1.0 :y 2.0})]
       (merge! pos {:x 5.0}))  ; update standalone instance

     (let [pos (get-comp world entity Position)]
       (merge! pos {:x 5.0}))  ; update ComponentRef

     (merge! world entity Position {:x 5.0})  ; explicit form"
  ([instance-or-ref values]
   ;; Check if it's a standalone instance (map with :vt/ptr-box)
   ;; or a ComponentRef (map with :vt/world-box)
   (if (contains? instance-or-ref :vt/ptr-box)
     ;; Standalone instance: write directly to native pointer
     (let [comp (:vt/comp instance-or-ref)
           ptr-box (:vt/ptr-box instance-or-ref)]
       ;; Write values to native memory
       (doseq [[field-kw value] values]
         (let [field-name (name field-kw)
               offset (field-offset comp field-name)
               field-type (some (fn [f] (when (= (:name f) field-name) (:type f)))
                                (:fields comp))]
           (when offset
             (write-field-to-ptr! ptr-box field-type offset value))))
       ;; Return the instance (native memory has been updated)
       instance-or-ref)
     ;; ComponentRef form: (merge! pos {:x 5})
     (let [comp-ref instance-or-ref
           w-box (:vt/world-box comp-ref)
           entity (:vt/entity comp-ref)
           comp (:vt/comp comp-ref)
           cid (fl/ecs_lookup (cpp/unbox (cpp/type "ecs_world_t*") w-box) (:name comp))]
       (doseq [[field-kw value] values]
         (let [field-name (name field-kw)
               field-type (some (fn [f] (when (= (:name f) field-name) (:type f)))
                                (:fields comp))
               wb (cpp/unbox (cpp/type "ecs_world_t*") w-box)]
           (cond
             (is-float-type? field-type)
             (cpp/vybe_set_field_float wb entity cid field-name (cpp/double. value))

             (is-int-type? field-type)
             (cpp/vybe_set_field_int wb entity cid field-name (cpp/long. value))

             (is-uint-type? field-type)
             (cpp/vybe_set_field_uint wb entity cid field-name (cpp/long. value))

             (= field-type :bool)
             (cpp/vybe_set_field_bool wb entity cid field-name value)))))))
  ([world entity comp values]
   ;; Explicit form: (merge! world entity Position {:x 5})
   (let [desc (resolve-descriptor comp)
         w (-world-ptr world)
         w-box (cpp/box w)
         cid (comp-id world comp)]
     (doseq [[field-kw value] values]
       (let [field-name (name field-kw)
             field-type (some (fn [f] (when (= (:name f) field-name) (:type f)))
                              (:fields desc))
             wb (cpp/unbox (cpp/type "ecs_world_t*") w-box)]
         (cond
           (is-float-type? field-type)
           (cpp/vybe_set_field_float wb entity cid field-name (cpp/double. value))

           (is-int-type? field-type)
           (cpp/vybe_set_field_int wb entity cid field-name (cpp/long. value))

           (is-uint-type? field-type)
           (cpp/vybe_set_field_uint wb entity cid field-name (cpp/long. value))

           (= field-type :bool)
           (cpp/vybe_set_field_bool wb entity cid field-name value)))))))

(defn set-comp!
  "Alias for merge! with explicit args. Set component fields on an entity.

   Usage:
     (set-comp! world entity Position {:x 10.0})       ; update just :x
     (set-comp! world entity Position {:x 1.0 :y 2.0}) ; update both"
  [world entity comp values]
  (merge! world entity comp values))

;; =============================================================================
;; Direct memory access - O(1) field access using cached offsets
;; =============================================================================

(defn get-field-direct
  "Get a single field value using direct memory access (O(1)).
   Requires component to be registered first.

   Usage:
     (get-field-direct world entity Position :x)"
  [world entity comp field-kw]
  (let [desc (resolve-descriptor comp)
        w (-world-ptr world)
        cid (comp-id world comp)]
    (when (fl/ecs_has_id w entity cid)
      (let [ptr (cpp/vybe_get_comp_ptr_const w entity cid)
            field-name (name field-kw)
            offset (field-offset desc field-name)
            field-type (some (fn [f] (when (= (:name f) field-name) (:type f)))
                             (:fields desc))]
        (when offset
          (cond
            (is-f32-type? field-type)
            (cpp/vybe_get_float_at ptr offset)

            (is-f64-type? field-type)
            (cpp/vybe_get_double_at ptr offset)

            (is-i32-type? field-type)
            (cpp/vybe_get_i32_at ptr offset)

            (is-i64-type? field-type)
            (cpp/vybe_get_i64_at ptr offset)

            (is-u32-type? field-type)
            (cpp/vybe_get_u32_at ptr offset)

            (is-u64-type? field-type)
            (cpp/vybe_get_u64_at ptr offset)

            (= field-type :bool)
            (cpp/vybe_get_bool_at ptr offset)))))))

(defn set-field-direct!
  "Set a single field value using direct memory access (O(1)).
   Requires component to be registered first.

   Usage:
     (set-field-direct! world entity Position :x 42.0)"
  [world entity comp field-kw value]
  (let [desc (resolve-descriptor comp)
        w (-world-ptr world)
        cid (comp-id world comp)]
    (when (fl/ecs_has_id w entity cid)
      (let [ptr (cpp/vybe_get_comp_ptr w entity cid)
            field-name (name field-kw)
            offset (field-offset desc field-name)
            field-type (some (fn [f] (when (= (:name f) field-name) (:type f)))
                             (:fields desc))]
        (when offset
          (cond
            (is-f32-type? field-type)
            (cpp/vybe_set_float_at ptr offset (cpp/double. value))

            (is-f64-type? field-type)
            (cpp/vybe_set_double_at ptr offset (cpp/double. value))

            (is-i32-type? field-type)
            (cpp/vybe_set_i32_at ptr offset (cpp/long. value))

            (is-i64-type? field-type)
            (cpp/vybe_set_i64_at ptr offset (cpp/long. value))

            (is-u32-type? field-type)
            (cpp/vybe_set_u32_at ptr offset (cpp/long. value))

            (is-u64-type? field-type)
            (cpp/vybe_set_u64_at ptr offset (cpp/long. value))

            (= field-type :bool)
            (cpp/vybe_set_bool_at ptr offset value)))))))

(defn get-comp-direct
  "Get component data using direct memory access (faster than get-comp).
   Returns a plain map without ComponentRef metadata.

   Usage:
     (get-comp-direct world entity Position)
     ;; => {:x 10.0 :y 20.0}"
  [world entity comp]
  (let [desc (resolve-descriptor comp)
        w (-world-ptr world)
        cid (comp-id world comp)]
    (when (fl/ecs_has_id w entity cid)
      (let [ptr (cpp/vybe_get_comp_ptr_const w entity cid)
            ptr-box (cpp/box ptr)]
        (into {}
              (map (fn [field]
                     (let [field-name (:name field)
                           field-type (:type field)
                           offset (field-offset desc field-name)
                           p (cpp/unbox (cpp/type "const void*") ptr-box)
                           value (when offset
                                   (cond
                                     (is-f32-type? field-type)
                                     (cpp/vybe_get_float_at p offset)

                                     (is-f64-type? field-type)
                                     (cpp/vybe_get_double_at p offset)

                                     (is-i32-type? field-type)
                                     (cpp/vybe_get_i32_at p offset)

                                     (is-i64-type? field-type)
                                     (cpp/vybe_get_i64_at p offset)

                                     (is-u32-type? field-type)
                                     (cpp/vybe_get_u32_at p offset)

                                     (is-u64-type? field-type)
                                     (cpp/vybe_get_u64_at p offset)

                                     (= field-type :bool)
                                     (cpp/vybe_get_bool_at p offset)))]
                       [(keyword field-name) value]))
                   (:fields desc)))))))

(defn set-comp-direct!
  "Set component fields using direct memory access (faster than set-comp!).

   Usage:
     (set-comp-direct! world entity Position {:x 10.0 :y 20.0})"
  [world entity comp values]
  (let [desc (resolve-descriptor comp)
        w (-world-ptr world)
        cid (comp-id world comp)]
    (when (fl/ecs_has_id w entity cid)
      (let [ptr (cpp/vybe_get_comp_ptr w entity cid)
            ptr-box (cpp/box ptr)]
        (doseq [[field-kw value] values]
          (let [field-name (name field-kw)
                offset (field-offset desc field-name)
                field-type (some (fn [f] (when (= (:name f) field-name) (:type f)))
                                 (:fields desc))
                p (cpp/unbox (cpp/type "void*") ptr-box)]
            (when offset
              (cond
                (is-f32-type? field-type)
                (cpp/vybe_set_float_at p offset (cpp/double. value))

                (is-f64-type? field-type)
                (cpp/vybe_set_double_at p offset (cpp/double. value))

                (is-i32-type? field-type)
                (cpp/vybe_set_i32_at p offset (cpp/long. value))

                (is-i64-type? field-type)
                (cpp/vybe_set_i64_at p offset (cpp/long. value))

                (is-u32-type? field-type)
                (cpp/vybe_set_u32_at p offset (cpp/long. value))

                (is-u64-type? field-type)
                (cpp/vybe_set_u64_at p offset (cpp/long. value))

                (= field-type :bool)
                (cpp/vybe_set_bool_at p offset value)))))))))

;; =============================================================================
;; User-type based component instances - implements map interface
;; =============================================================================

(defn make-user-type [type-name constructor-fn]
  (cpp/jank.runtime.make_user_type type-name constructor-fn))

(defn- create-comp-user-type
  "Create a user-type factory for a component descriptor."
  [comp]
  (let [comp-name (:name comp)
        field-names (set (map (fn [f] (keyword (:name f))) (:fields comp)))
        field-types (into {} (map (fn [f] [(keyword (:name f)) (:type f)]) (:fields comp)))]
    (make-user-type
     comp-name
     (fn [{:keys [ptr-box comp]}]
       {:get (fn [this k]
               (cond
                 ;; Expose metadata for merge! compatibility
                 (= k :vt/ptr-box) ptr-box
                 (= k :vt/comp) comp
                 ;; Field access
                 (contains? field-names k)
                 (let [offset (field-offset comp (name k))
                       field-type (get field-types k)]
                   (when offset
                     (read-field-from-ptr ptr-box field-type offset)))))
        :contains (fn [this k]
                    (or (= k :vt/ptr-box)
                        (= k :vt/comp)
                        (contains? field-names k)))
        :count (fn [this]
                 (count (:fields comp)))
        :to-string (fn [this]
                     (let [field-strs (map (fn [f]
                                             (let [k (keyword (:name f))
                                                   offset (field-offset comp (:name f))
                                                   field-type (get field-types k)
                                                   v (read-field-from-ptr ptr-box field-type offset)]
                                               (str k " " v)))
                                           (:fields comp))]
                       (str "#" comp-name "{" (apply str (interpose ", " field-strs)) "}")))
        ;; assoc - writes to native memory and returns this (mutable update)
        :assoc (fn [this k v]
                 (when (contains? field-names k)
                   (let [offset (field-offset comp (name k))
                         field-type (get field-types k)]
                     (when offset
                       (write-field-to-ptr! ptr-box field-type offset v))))
                 this)
        ;; conj - handles both [k v] pairs and maps (for merge support)
        :conj (fn [this entry]
                (if (map? entry)
                  ;; merge calls (conj m1 m2) with a map
                  (doseq [[k v] entry]
                    (when (contains? field-names k)
                      (let [offset (field-offset comp (name k))
                            field-type (get field-types k)]
                        (when offset
                          (write-field-to-ptr! ptr-box field-type offset v)))))
                  ;; single [k v] entry
                  (let [k (first entry)
                        v (second entry)]
                    (when (contains? field-names k)
                      (let [offset (field-offset comp (name k))
                            field-type (get field-types k)]
                        (when offset
                          (write-field-to-ptr! ptr-box field-type offset v))))))
                this)}))))

;; Store factory directly on descriptor via :vt/ut-factory key
(defn- get-ut-factory
  "Get or create user-type factory for a descriptor."
  [comp]
  (if-let [factory (:vt/ut-factory comp)]
    factory
    (create-comp-user-type comp)))

(defn create-user-type-instance
  "Create a user-type component instance backed by native memory.
   This instance implements the map interface, so you can use:
   - (:x pos) or (get pos :x) - read field
   - (contains? pos :x) - check field exists
   - (count pos) - get number of fields"
  [comp values]
  ;; Ensure metadata is initialized
  (when-not (get-comp-meta comp)
    (init-comp-meta! comp))
  (let [size (comp-size comp)
        ptr (cpp/vybe_alloc_comp size)
        ptr-box (cpp/box ptr)
        value-map (if (vector? values)
                    (zipmap (map (fn [f] (keyword (:name f))) (:fields comp)) values)
                    values)
        ut-factory (get-ut-factory comp)
        field-types (into {} (map (fn [f] [(:name f) (:type f)]) (:fields comp)))]
    ;; Write initial values
    (doseq [[field-kw value] value-map]
      (let [field-name (name field-kw)
            offset (field-offset comp field-name)
            field-type (get field-types field-name)]
        (when offset
          (write-field-to-ptr! ptr-box field-type offset value))))
    (ut-factory {:ptr-box ptr-box :comp comp})))

;; =============================================================================
;; Standalone component instances - native memory-backed mutable structs
;; =============================================================================

(defn- create-standalone-instance
  "Create a standalone component instance backed by native memory.
   Returns a function that when called:
   - (instance :x) - reads field :x from native memory (live read)
   - (instance) - returns a snapshot map of all fields
   The function also carries metadata for merge! to work."
  [comp values]
  ;; Ensure metadata is initialized
  (when-not (get-comp-meta comp)
    (init-comp-meta! comp))
  (let [;; Allocate native memory
        size (comp-size comp)
        ptr (cpp/vybe_alloc_comp size)
        ptr-box (cpp/box ptr)
        ;; Convert values to a map if it's a vector (positional args)
        value-map (if (vector? values)
                    (zipmap (map (fn [f] (keyword (:name f))) (:fields comp))
                            values)
                    values)
        ;; Store metadata in an atom so the function can access it
        meta-data {:vt/comp comp
                   :vt/ptr-box ptr-box}]
    ;; Write initial values to native memory
    (doseq [[field-kw value] value-map]
      (let [field-name (name field-kw)
            offset (field-offset comp field-name)
            field-type (some (fn [f] (when (= (:name f) field-name) (:type f)))
                             (:fields comp))]
        (when offset
          (write-field-to-ptr! ptr-box field-type offset value))))
    ;; Return a callable function with metadata attached
    (with-meta
      (fn
        ;; 0-arity: return snapshot of all fields
        ([]
         (into {}
               (map (fn [field]
                      (let [field-name (:name field)
                            field-type (:type field)
                            offset (field-offset comp field-name)]
                        [(keyword field-name)
                         (read-field-from-ptr ptr-box field-type offset)]))
                    (:fields comp))))
        ;; 1-arity: read a field from native memory
        ([field-kw]
         (let [field-name (name field-kw)
               offset (field-offset comp field-name)
               field-type (some (fn [f] (when (= (:name f) field-name) (:type f)))
                                (:fields comp))]
           (when offset
             (read-field-from-ptr ptr-box field-type offset)))))
      meta-data)))

(defn standalone-instance?
  "Check if x is a standalone component instance (function with :vt/ptr-box in metadata)."
  [x]
  (and (fn? x) (contains? (meta x) :vt/ptr-box)))

(defn standalone-get
  "Get a field value from a standalone instance by reading from native memory.
   Just calls the instance function with the field keyword."
  [instance field-kw]
  (instance field-kw))

(defn standalone-merge!
  "Update fields in a standalone instance by writing to native memory.
   Returns the instance unchanged (the native memory is updated in-place)."
  [instance values]
  (let [m (meta instance)
        comp (:vt/comp m)
        ptr-box (:vt/ptr-box m)]
    ;; Write values to native memory
    (doseq [[field-kw value] values]
      (let [field-name (name field-kw)
            offset (field-offset comp field-name)
            field-type (some (fn [f] (when (= (:name f) field-name) (:type f)))
                             (:fields comp))]
        (when offset
          (write-field-to-ptr! ptr-box field-type offset value))))
    ;; Return the instance (native memory has been updated)
    instance))

(defn vget
  "Get a field value from native memory. Works with both standalone instances and ComponentRefs.
   Unlike keyword access (which returns a snapshot), this always reads fresh values from memory.

   Usage:
     (let [pos (Position {:x 1.0 :y 2.0})]
       (vt/merge! pos {:x 99.0})
       (vt/vget pos :x))  ;; => 99.0 (reads from native memory)"
  [instance-or-ref field-kw]
  (if (contains? instance-or-ref :vt/ptr-box)
    ;; Standalone instance: read from pointer
    (standalone-get instance-or-ref field-kw)
    ;; ComponentRef: read from Flecs world
    (let [w-box (:vt/world-box instance-or-ref)
          entity (:vt/entity instance-or-ref)
          comp (:vt/comp instance-or-ref)
          cid (fl/ecs_lookup (cpp/unbox (cpp/type "ecs_world_t*") w-box) (:name comp))
          field-name (name field-kw)
          field-type (some (fn [f] (when (= (:name f) field-name) (:type f)))
                           (:fields comp))
          wb (cpp/unbox (cpp/type "ecs_world_t*") w-box)]
      (cond
        (is-float-type? field-type)
        (cpp/vybe_get_field_float wb entity cid field-name)

        (is-int-type? field-type)
        (cpp/vybe_get_field_int wb entity cid field-name)

        (is-uint-type? field-type)
        (cpp/vybe_get_field_uint wb entity cid field-name)

        (= field-type :bool)
        (cpp/vybe_get_field_bool wb entity cid field-name)))))

(defn comp-descriptor
  "Get the component descriptor from a component constructor function."
  [comp-fn]
  (get @comp-registry comp-fn))

(defn comp-name
  "Get the mangled component name (e.g. 'vybe_type__Position') from a component."
  [comp]
  (:name (resolve-descriptor comp)))


(defn build-query-string
  "Build a query string from a list of specs (strings, keywords, or components).
   Used by vybe.flecs/with-query to build query expressions.
   Keywords are mangled (e.g. :my-tag -> \"my_tag\", :foo/bar -> \"foo__bar\")."
  [specs]
  (apply str (interpose ", " (map (fn [spec]
                                     (cond
                                       (string? spec) spec
                                       (keyword? spec) (mangle-keyword spec)
                                       :else (comp-name spec)))
                                   specs))))

;; =============================================================================
;; defcomp - Macro to define components
;; =============================================================================

(defn make-comp-constructor
  "Create a component constructor function from a descriptor.
   The constructor can be called with a map or vector to create user-type instances
   that implement the map interface (supports :x pos, get, contains?, count).
   Also registers the function in comp-registry for descriptor lookup."
  [desc]
  (let [comp-name (:name desc)
        constructor (with-meta (fn [values]
                                 (create-user-type-instance desc values))
                               {:vt/comp-name comp-name})]
    ;; Remove any existing entries with the same component name (handles reload case)
    ;; This prevents stale function objects from accumulating in comp-registry
    (swap! comp-registry (fn [reg]
                           (let [;; Find keys (functions) that map to descriptors with same name
                                 stale-keys (filter (fn [k]
                                                      (= comp-name (:name (get reg k))))
                                                    (keys reg))]
                             ;; Remove stale entries, then add new one
                             (assoc (apply dissoc reg stale-keys) constructor desc))))
    ;; Also register by name for lookup from entity components
    (register-descriptor-by-name desc)
    constructor))

(defmacro defcomp
  "Define a Flecs component type with namespace-qualified name.

   Usage:
     (defcomp Position [[:x :float] [:y :float]])

   Creates a var `Position` that is a callable constructor function.
   Call it to create instances that implement the map interface:

     (def pos (Position {:x 1.0 :y 2.0}))
     (:x pos)          ;; => 1.0 (keyword as function)
     (get pos :y)      ;; => 2.0
     (contains? pos :x) ;; => true
     (count pos)        ;; => 2

   Use (comp-descriptor Position) to get the descriptor for registration.

   The component name will be namespace-qualified and mangled for Flecs
   (e.g., \"vybe_type__Position\" for vybe.type/Position).
   Register with a world using: (register-comp! world Position)

   Supported types:
     :float, :f32    - 32-bit float
     :double, :f64   - 64-bit float
     :i8, :i16, :i32, :i64 - signed integers
     :int            - alias for :i32
     :long           - alias for :i64
     :u8, :u16, :u32, :u64 - unsigned integers
     :bool           - boolean
     :string         - string (char*)
     :entity         - entity reference"
  [sym fields]
  `(def ~sym
     (make-comp-constructor (make-comp ~(mangle-name *ns* sym) ~fields))))

(defn -main [& args])

(cpp/eita)
