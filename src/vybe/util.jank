(ns vybe.util
  (:require
   [clojure.string :as str]))

(defn ->cpp-type
  "Converts a Malli-like type specification to a C++ type string.

  Examples:
    :i32                -> \"int\"
    :i64                -> \"long\"
    :f32                -> \"float\"
    :f64                -> \"double\"
    :bool               -> \"bool\"
    :void               -> \"void\"
    :char               -> \"char\"
    \"MyType\"          -> \"MyType\"
    [:* :i32]           -> \"int*\"
    [:const :char]      -> \"char const\"
    [:* [:const :char]] -> \"char const*\"
    [:ref :i32]         -> \"int&\"
    [:vector :i32]      -> \"std::vector<int>\"
    [:map :string :i32] -> \"std::map<std::string, int>\""
  [spec]
  (cond
    (string? spec) spec

    (keyword? spec)
    (case spec
      :i8     "int8_t"
      :i16    "int16_t"
      :i32    "int"
      :i64    "long"
      :u8     "uint8_t"
      :u16    "uint16_t"
      :u32    "unsigned int"
      :u64    "unsigned long"
      :f32    "float"
      :f64    "double"
      (:bool :boolean)   "bool"
      :void   "void"
      :char   "char"
      :size_t "size_t"
      :string "std::string"
      :cstr   "char const*"
      (name spec))

    (vector? spec)
    (let [op (first spec)]
      (case op
        :*      (str (->cpp-type (second spec)) "*")
        :&      (str (->cpp-type (second spec)) "&")
        :ref    (str (->cpp-type (second spec)) "&")
        :const  (str (->cpp-type (second spec)) " const")
        :vector (str "std::vector<" (->cpp-type (second spec)) ">")
        :array  (str "std::array<" (->cpp-type (second spec)) ", " (nth spec 2) ">")
        :map    (str "std::map<" (->cpp-type (second spec)) ", " (->cpp-type (nth spec 2)) ">")
        :pair   (str "std::pair<" (->cpp-type (second spec)) ", " (->cpp-type (nth spec 2)) ">")
        :optional (str "std::optional<" (->cpp-type (second spec)) ">")
        :unique_ptr (str "std::unique_ptr<" (->cpp-type (second spec)) ">")
        :shared_ptr (str "std::shared_ptr<" (->cpp-type (second spec)) ">")
        ;; Template instantiation: [:template "MyClass" :i32 :f64]
        :template (str (second spec) "<" (str/join ", " (map ->cpp-type (drop 2 spec))) ">")
        ;; Function pointer: [:fn [:i32 :i32] :i32] -> int(*)(int, int)
        :fn (let [args (second spec)
                  ret (nth spec 2)]
              (str (->cpp-type ret) "(*)(" (str/join ", " (map ->cpp-type args)) ")"))
        ;; Default: treat first element as template name
        (str (->cpp-type op) "<" (str/join ", " (map ->cpp-type (rest spec))) ">")))

    :else (str spec)))

(defn- infer-cpp-type
  "Infers C++ type string from a literal value at macro-expansion time."
  [v]
  (cond
    (boolean? v) "bool"
    (int? v)     "long"
    (float? v)   "double"
    :else        nil))

;; v->p: Create a pointer to a value.
;; Allocates a C++ value and returns a boxed pointer to it.
;; Type is inferred from the literal, or can be provided explicitly.
;; Example: (defonce is-paused (v->p false))  ; creates bool*
;; Example: (defonce counter (v->p 0 "int"))  ; explicit int*
(defmacro v->p
  [v & [type-str]]
  (let [cpp-type (or type-str (infer-cpp-type v))]
    (when-not cpp-type
      (throw (ex-info "v->p: Cannot infer type, please provide it explicitly" {:value v})))
    `(cpp/box (cpp/new (cpp/type ~cpp-type) ~v))))

;; p->v: Dereference a pointer to get the value.
;; Type is automatically inferred by the compiler from the var's init expression.
;; Example: (defonce is-paused (v->p false))
;;          (p->v is-paused)  ; returns the bool value
(defmacro p->v
  [p]
  `(cpp/* (cpp/unbox ~p)))

(defmacro ->*
  [head & tail]
  `(-> ~head
       ~@(map #(cond
                 (symbol? %)
                 (symbol "cpp" %)

                 (list? %)
                 (concat (list (symbol "cpp" (first %))) (rest %))

                 :else
                 %)
              tail)))

;; (cpp/= (cpp/.-image barrier) vk-image)
;; (cpp/= (cpp/.-aspectMask (cpp/.-subresourceRange barrier)) (cpp/VkImageAspectFlags. vk/VK_IMAGE_ASPECT_COLOR_BIT))

(defn- split-by-dot
  "Split a string by dots, returns vector of parts."
  [s]
  (loop [remaining s
         result []]
    (let [idx (str/index-of remaining ".")]
      (if idx
        (recur (subs remaining (inc idx))
               (conj result (subs remaining 0 idx)))
        (conj result remaining)))))

(defmacro merge*
  "Merges a map of field assignments into a C++ struct.
   Keys with dots expand to nested field access.

   Example:
     (merge* barrier {:image vk-image
                      :subresourceRange.aspectMask (cpp/VkImageAspectFlags. vk/VK_IMAGE_ASPECT_COLOR_BIT)})
   Expands to:
     (do
       (cpp/= (->* barrier .-image) vk-image)
       (cpp/= (->* barrier .-subresourceRange .-aspectMask) (cpp/VkImageAspectFlags. vk/VK_IMAGE_ASPECT_COLOR_BIT)))"
  [struct m]
  (let [assignments (for [[k v] m]
                      (let [;; Split key by dots: :subresourceRange.aspectMask -> ["subresourceRange" "aspectMask"]
                            parts (split-by-dot (name k))
                            ;; Convert to .-field symbols
                            field-syms (map #(symbol (str ".-" %)) parts)]
                        ;; Generate (cpp/= (->* struct .-field1 .-field2 ...) value)
                        `(cpp/= (->* ~struct ~@field-syms) ~v)))]
    `(do ~@assignments)))

;; =============================================================================
;; Profiling / Metrics macros
;; =============================================================================

(defonce *metrics* (atom {}))
(defonce *metrics-enabled* (atom false))

(defn now-us
  "Get current time in microseconds (from nanoseconds)."
  []
  (quot (@#'clojure.core/current-time) 1000))

(defn record-metric!
  "Record a timing measurement for the given key."
  [key elapsed-us]
  (swap! *metrics* update key
    (fn [m]
      (let [m (or m {:count 0 :total-us 0 :min-us 999999999 :max-us 0})]
        {:count (inc (:count m))
         :total-us (+ (:total-us m) elapsed-us)
         :min-us (min (:min-us m) elapsed-us)
         :max-us (max (:max-us m) elapsed-us)}))))

(defn reset-metrics!
  "Reset all collected metrics."
  []
  (reset! *metrics* {}))

(defn enable-metrics!
  "Enable metrics collection."
  []
  (reset! *metrics-enabled* true))

(defn disable-metrics!
  "Disable metrics collection."
  []
  (reset! *metrics-enabled* false))

(defn- pad-left
  "Pad string s to width with spaces on the left."
  [s width]
  (let [s (str s)
        len (count s)]
    (if (>= len width)
      s
      (str (apply str (repeat (- width len) " ")) s))))

(defn- pad-right
  "Pad string s to width with spaces on the right."
  [s width]
  (let [s (str s)
        len (count s)]
    (if (>= len width)
      s
      (str s (apply str (repeat (- width len) " "))))))

(defn- insert-sorted
  "Insert item into sorted-vec maintaining descending order by key-fn."
  [sorted-vec item key-fn]
  (let [k (key-fn item)]
    (loop [i 0]
      (if (>= i (count sorted-vec))
        (conj sorted-vec item)
        (if (> k (key-fn (nth sorted-vec i)))
          (into (conj (subvec sorted-vec 0 i) item) (subvec sorted-vec i))
          (recur (inc i)))))))

(defn- sort-by-desc
  "Sort collection by key-fn in descending order."
  [key-fn coll]
  (reduce #(insert-sorted %1 %2 key-fn) [] coll))

(defn print-metrics
  "Print collected metrics sorted by total time (descending).
   Shows: key, count, total-ms, %, avg-us, min-us, max-us

   By default, excludes :timed/* overhead and main wrapper, showing real work percentages.
   Pass true to include all metrics (overhead + main wrapper) in full report."
  ([] (print-metrics false))
  ([show-overhead?]
   (let [metrics @*metrics*
         ;; Filter out :timed/* keys
         non-overhead (into {} (filter (fn [[k _]] (not (= "timed" (namespace k)))) metrics))
         ;; Find the main wrapper (key with largest total time that's not :timed/*)
         main-entry (first (sort-by-desc (fn [[_ v]] (:total-us v)) non-overhead))
         main-key (if main-entry (first main-entry) nil)
         main-total (if main-entry (:total-us (second main-entry)) 0)
         ;; For default: exclude main wrapper too, show only child operations
         ;; For full: show everything including overhead
         filtered (if show-overhead?
                    metrics
                    (into {} (filter (fn [[k _]] (and (not (= "timed" (namespace k)))
                                                      (not (= k main-key)))) metrics)))
         sorted (sort-by-desc (fn [[_ v]] (:total-us v)) filtered)
         ;; Sum of child operations (real work)
         work-total (reduce + 0 (map (fn [[_ v]] (:total-us v))
                                     (filter (fn [[k _]] (and (not (= "timed" (namespace k)))
                                                              (not (= k main-key)))) non-overhead)))
         ;; Sum of overhead
         overhead-total (reduce + 0 (map (fn [[_ v]] (:total-us v))
                                         (filter (fn [[k _]] (= "timed" (namespace k))) metrics)))
         ;; Reference for percentages
         ref-total (if show-overhead?
                     (reduce + 0 (map (fn [[_ v]] (:total-us v)) metrics))
                     work-total)]
     (println (if show-overhead?
                "\n=== METRICS (FULL WITH OVERHEAD) ==="
                "\n=== METRICS (REAL WORK) ==="))
     (when-not show-overhead?
       (println (str "Main wrapper: " (/ main-total 1000.0) " ms"))
       (println (str "Real work: " (/ work-total 1000.0) " ms ("
                     (int (/ (* 100.0 work-total) main-total)) "%)"))
       (println (str "Overhead: " (/ overhead-total 1000.0) " ms ("
                     (int (/ (* 100.0 overhead-total) main-total)) "%)")))
     (println (str (pad-right "Key" 40)
                   (pad-left "Count" 10)
                   (pad-left "Total(ms)" 14)
                   (pad-left "%" 8)
                   (pad-left "Avg(us)" 12)
                   (pad-left "Min" 10)
                   (pad-left "Max" 10)))
     (println (apply str (repeat 104 "-")))
     (doseq [[k v] sorted]
       (let [{:keys [count total-us min-us max-us]} v
             avg-us (if (> count 0) (/ total-us count) 0)
             total-ms (/ total-us 1000.0)
             pct (if (> ref-total 0) (/ (* 100.0 total-us) ref-total) 0.0)]
         (println (str (pad-right (str k) 40)
                       (pad-left count 10)
                       (pad-left total-ms 14)
                       (pad-left (str (int pct) "%") 8)
                       (pad-left avg-us 12)
                       (pad-left min-us 10)
                       (pad-left max-us 10)))))
     (println "=======\n"))))

(defmacro timed
  "Time a single form and record under the given key.
   Only records if *metrics-enabled* is true.
   Uses inline timing that works with native C++ types.
   Also records detailed overhead metrics.

   Usage: (timed :my-operation (expensive-computation))"
  [key form]
  ;; Don't use if around the form - it breaks native C++ reference types
  ;; Instead, always execute form and conditionally record timing
  `(let [t0# (now-us)
         enabled# @*metrics-enabled*
         t1# (now-us)
         start# (when enabled# (now-us))
         t2# (now-us)]
     (let [result# ~form]
       (when enabled#
         (let [t3# (now-us)
               end# (now-us)
               t4# (now-us)]
           (record-metric! ~key (- end# start#))
           (let [t5# (now-us)]
             (record-metric! :timed/now-us (+ (- t1# t0#) (- t2# t1#) (- t4# t3#)))
             (record-metric! :timed/deref (- t1# t0#))
             (let [t6# (now-us)]
               (record-metric! :timed/record (- t6# t5#))
               (let [t7# (now-us)]
                 ;; Measure let/when overhead: t2->t3 is form execution + let binding
                 ;; We subtract form time to get just the let/when overhead
                 (record-metric! :timed/let-when (- (- t3# t2#) (- end# start#)))
                 (record-metric! :timed/meta-record (- t7# t6#)))))))
       result#)))

(defn- replace-slash
  "Replace / with - in a string (workaround for missing clojure.string/replace)."
  [s]
  (apply str (map #(if (= % \/) \- %) s)))

(declare wrap-form)

(defn- wrap-bindings
  "Wrap binding expressions in a let/let* vector.
   [x (foo) y (bar)] -> [x (timed :prefix/foo (foo)) y (timed :prefix/bar (bar))]"
  [prefix bindings]
  (loop [result []
         remaining (seq bindings)]
    (if (empty? remaining)
      result
      (let [sym (first remaining)
            expr (second remaining)
            wrapped-expr (wrap-form prefix expr)]
        (recur (conj result sym wrapped-expr)
               (drop 2 remaining))))))

(defn- wrap-form
  "Recursively wrap a form with timing. Returns the wrapped form."
  [prefix form]
  (if-not (seq? form)
    form
    (let [head (first form)
          make-key (fn [f]
                     (keyword (str (clojure.core/name prefix) "/"
                                   (cond
                                     (symbol? f) (replace-slash (str f))
                                     (keyword? f) (replace-slash (name f))
                                     :else "anon"))))]
      (cond
        ;; do block - wrap each child
        (= head 'do)
        (let [wrapped-children (map #(wrap-form prefix %) (rest form))]
          `(do ~@wrapped-children))

        ;; let block - wrap binding expressions AND body forms
        (= head 'let)
        (let [bindings (second form)
              body (drop 2 form)
              wrapped-bindings (wrap-bindings prefix bindings)
              wrapped-body (map #(wrap-form prefix %) body)]
          `(let ~wrapped-bindings ~@wrapped-body))

        ;; let* block - wrap binding expressions AND body forms
        (= head 'let*)
        (let [bindings (second form)
              body (drop 2 form)
              wrapped-bindings (wrap-bindings prefix bindings)
              wrapped-body (map #(wrap-form prefix %) body)]
          `(let* ~wrapped-bindings ~@wrapped-body))

        ;; when block - wrap test AND body forms
        (= head 'when)
        (let [test (second form)
              body (drop 2 form)
              wrapped-test (wrap-form prefix test)
              wrapped-body (map #(wrap-form prefix %) body)]
          `(when ~wrapped-test ~@wrapped-body))

        ;; when-not block - wrap test AND body forms
        (= head 'when-not)
        (let [test (second form)
              body (drop 2 form)
              wrapped-test (wrap-form prefix test)
              wrapped-body (map #(wrap-form prefix %) body)]
          `(when-not ~wrapped-test ~@wrapped-body))

        ;; when-let - wrap binding expression and body
        (= head 'when-let)
        (let [bindings (second form)
              body (drop 2 form)
              wrapped-bindings (wrap-bindings prefix bindings)
              wrapped-body (map #(wrap-form prefix %) body)]
          `(when-let ~wrapped-bindings ~@wrapped-body))

        ;; if-let - wrap binding expression and branches
        (= head 'if-let)
        (let [bindings (second form)
              then-form (nth form 2)
              else-form (when (> (clojure.core/count form) 3) (nth form 3))
              wrapped-bindings (wrap-bindings prefix bindings)]
          (if else-form
            `(if-let ~wrapped-bindings
               ~(wrap-form prefix then-form)
               ~(wrap-form prefix else-form))
            `(if-let ~wrapped-bindings
               ~(wrap-form prefix then-form))))

        ;; if block - wrap test, then and else
        (= head 'if)
        (let [test (second form)
              then-form (nth form 2)
              else-form (when (> (clojure.core/count form) 3) (nth form 3))
              wrapped-test (wrap-form prefix test)]
          (if else-form
            `(if ~wrapped-test
               ~(wrap-form prefix then-form)
               ~(wrap-form prefix else-form))
            `(if ~wrapped-test
               ~(wrap-form prefix then-form))))

        ;; doseq - wrap binding expressions and body
        (= head 'doseq)
        (let [bindings (second form)
              body (drop 2 form)
              wrapped-bindings (wrap-bindings prefix bindings)
              wrapped-body (map #(wrap-form prefix %) body)]
          `(doseq ~wrapped-bindings ~@wrapped-body))

        ;; -> threading macro - wrap the initial value and each step
        (= head '->)
        (let [init (second form)
              steps (drop 2 form)
              wrapped-init (wrap-form prefix init)]
          ;; For threading, wrap the whole pipeline as a single operation
          `(timed ~(make-key '->) (-> ~wrapped-init ~@steps)))

        ;; ->> threading macro
        (= head '->>)
        (let [init (second form)
              steps (drop 2 form)
              wrapped-init (wrap-form prefix init)]
          `(timed ~(make-key '->>) (->> ~wrapped-init ~@steps)))

        ;; cond - wrap both test AND result forms
        (= head 'cond)
        (let [pairs (partition 2 (rest form))
              wrapped-pairs (mapcat (fn [[test result]]
                                      [(wrap-form prefix test) (wrap-form prefix result)])
                                    pairs)]
          `(cond ~@wrapped-pairs))

        ;; Regular function call - wrap the call AND recursively wrap call-form arguments
        ;; Only skip cpp/value forms (from #cpp "...") - they return C++ string types that can't be stored in let
        :else
        (let [cpp-value-form? (fn [f] (and (seq? f)
                                           (= (first f) 'cpp/value)))
              wrapped-args (map #(if (and (seq? %) (not (cpp-value-form? %)))
                                   (wrap-form prefix %)
                                   %)
                                (rest form))]
          `(timed ~(make-key head) (~head ~@wrapped-args)))))))

(defmacro with-metrics
  "Wrap a body of forms, timing each form recursively.
   Keys are auto-generated from form structure.

   Usage:
     (with-metrics :draw-ui
       (imgui/Begin \"Window\")      ; timed as :draw-ui/imgui-Begin
       (do
         (imgui/Text \"Hello\")      ; timed as :draw-ui/imgui-Text
         (imgui/End)))              ; timed as :draw-ui/imgui-End"
  [name & body]
  (let [wrapped (map #(wrap-form name %) body)]
    `(timed ~name (do ~@wrapped))))

(defmacro profile
  "Profile a function body, timing each top-level form.
   Designed to wrap function bodies for detailed profiling.

   Usage:
     (defn my-fn []
       (profile :my-fn
         (step-1)
         (step-2)
         (step-3)))"
  [name & body]
  `(with-metrics ~name ~@body))

;; =============================================================================
;; defn* macro - for functions that return native C++ types
;; =============================================================================

(defmacro defn*
  "Define a macro that returns a native C++ type.
   When :tag metadata specifies a native type, generates a macro
   that inlines the body and wraps the result in cpp/unbox.

   This is needed because jank functions must return object_ref due to
   virtual dispatch, but we often need to return native types for C interop.

   Usage:
     (defn* ^{:tag \"ecs_world_t*\"} world-ptr [world]
       world)

   Expands to a macro that inlines: (cpp/unbox (cpp/type \"ecs_world_t*\") world)"
  [name & body]
  (let [m (meta name)
        tag (:tag m)
        ;; Parse optional docstring
        [docstring params forms] (if (string? (first body))
                                   [(first body) (second body) (drop 2 body)]
                                   [nil (first body) (rest body)])]
    (if tag
      ;; Generate a macro that wraps body result in cpp/unbox
      `(defmacro ~(with-meta name (dissoc m :tag))
         ~@(when docstring [docstring])
         ~params
         (list (quote cpp/unbox)
               (list (quote cpp/type) ~tag)
               ~@forms))
      ;; No tag, just use regular defn
      `(defn ~name ~@body))))
