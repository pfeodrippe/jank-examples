(ns vybe.util
  (:require
   [clojure.string :as str]))

(defn ->cpp-type
  "Converts a Malli-like type specification to a C++ type string.

  Examples:
    :i32                -> \"int\"
    :i64                -> \"long\"
    :f32                -> \"float\"
    :f64                -> \"double\"
    :bool               -> \"bool\"
    :void               -> \"void\"
    :char               -> \"char\"
    \"MyType\"          -> \"MyType\"
    [:* :i32]           -> \"int*\"
    [:const :char]      -> \"char const\"
    [:* [:const :char]] -> \"char const*\"
    [:ref :i32]         -> \"int&\"
    [:vector :i32]      -> \"std::vector<int>\"
    [:map :string :i32] -> \"std::map<std::string, int>\""
  [spec]
  (cond
    (string? spec) spec

    (keyword? spec)
    (case spec
      :i8     "int8_t"
      :i16    "int16_t"
      :i32    "int"
      :i64    "long"
      :u8     "uint8_t"
      :u16    "uint16_t"
      :u32    "unsigned int"
      :u64    "unsigned long"
      :f32    "float"
      :f64    "double"
      (:bool :boolean)   "bool"
      :void   "void"
      :char   "char"
      :size_t "size_t"
      :string "std::string"
      :cstr   "char const*"
      (name spec))

    (vector? spec)
    (let [op (first spec)]
      (case op
        :*      (str (->cpp-type (second spec)) "*")
        :&      (str (->cpp-type (second spec)) "&")
        :ref    (str (->cpp-type (second spec)) "&")
        :const  (str (->cpp-type (second spec)) " const")
        :vector (str "std::vector<" (->cpp-type (second spec)) ">")
        :array  (str "std::array<" (->cpp-type (second spec)) ", " (nth spec 2) ">")
        :map    (str "std::map<" (->cpp-type (second spec)) ", " (->cpp-type (nth spec 2)) ">")
        :pair   (str "std::pair<" (->cpp-type (second spec)) ", " (->cpp-type (nth spec 2)) ">")
        :optional (str "std::optional<" (->cpp-type (second spec)) ">")
        :unique_ptr (str "std::unique_ptr<" (->cpp-type (second spec)) ">")
        :shared_ptr (str "std::shared_ptr<" (->cpp-type (second spec)) ">")
        ;; Template instantiation: [:template "MyClass" :i32 :f64]
        :template (str (second spec) "<" (str/join ", " (map ->cpp-type (drop 2 spec))) ">")
        ;; Function pointer: [:fn [:i32 :i32] :i32] -> int(*)(int, int)
        :fn (let [args (second spec)
                  ret (nth spec 2)]
              (str (->cpp-type ret) "(*)(" (str/join ", " (map ->cpp-type args)) ")"))
        ;; Default: treat first element as template name
        (str (->cpp-type op) "<" (str/join ", " (map ->cpp-type (rest spec))) ">")))

    :else (str spec)))

(defn- infer-cpp-type
  "Infers C++ type string from a literal value at macro-expansion time."
  [v]
  (cond
    (boolean? v) "bool"
    (int? v)     "long"
    (float? v)   "double"
    :else        nil))

;; v->p: Create a pointer to a value.
;; Allocates a C++ value and returns a boxed pointer to it.
;; Type is inferred from the literal, or can be provided explicitly.
;; Example: (defonce is-paused (v->p false))  ; creates bool*
;; Example: (defonce counter (v->p 0 "int"))  ; explicit int*
(defmacro v->p
  [v & [type-str]]
  (let [cpp-type (or type-str (infer-cpp-type v))]
    (when-not cpp-type
      (throw (ex-info "v->p: Cannot infer type, please provide it explicitly" {:value v})))
    `(cpp/box (cpp/new (cpp/type ~cpp-type) ~v))))

;; p->v: Dereference a pointer to get the value.
;; Type is automatically inferred by the compiler from the var's init expression.
;; Example: (defonce is-paused (v->p false))
;;          (p->v is-paused)  ; returns the bool value
(defmacro p->v
  [p]
  `(cpp/* (cpp/unbox ~p)))

(defmacro ->*
  [head & tail]
  `(-> ~head
       ~@(map #(cond
                 (symbol? %)
                 (symbol "cpp" %)

                 (list? %)
                 (concat (list (symbol "cpp" (first %))) (rest %))

                 :else
                 %)
              tail)))

;; (cpp/= (cpp/.-image barrier) vk-image)
;; (cpp/= (cpp/.-aspectMask (cpp/.-subresourceRange barrier)) (cpp/VkImageAspectFlags. vk/VK_IMAGE_ASPECT_COLOR_BIT))

(defn- split-by-dot
  "Split a string by dots, returns vector of parts."
  [s]
  (loop [remaining s
         result []]
    (let [idx (str/index-of remaining ".")]
      (if idx
        (recur (subs remaining (inc idx))
               (conj result (subs remaining 0 idx)))
        (conj result remaining)))))

(defmacro merge*
  "Merges a map of field assignments into a C++ struct.
   Keys with dots expand to nested field access.

   Example:
     (merge* barrier {:image vk-image
                      :subresourceRange.aspectMask (cpp/VkImageAspectFlags. vk/VK_IMAGE_ASPECT_COLOR_BIT)})
   Expands to:
     (do
       (cpp/= (->* barrier .-image) vk-image)
       (cpp/= (->* barrier .-subresourceRange .-aspectMask) (cpp/VkImageAspectFlags. vk/VK_IMAGE_ASPECT_COLOR_BIT)))"
  [struct m]
  ;; NOTE: Using `map` instead of `for` to work around jank bug where
  ;; `for` with syntax-quote in body crashes inside macro definitions.
  (let [assignments (map (fn [[k v]]
                           (let [;; Split key by dots: :subresourceRange.aspectMask -> ["subresourceRange" "aspectMask"]
                                 parts (split-by-dot (name k))
                                 ;; Convert to .-field symbols
                                 field-syms (map #(symbol (str ".-" %)) parts)]
                             ;; Generate (cpp/= (->* struct .-field1 .-field2 ...) value)
                             `(cpp/= (->* ~struct ~@field-syms) ~v)))
                         m)]
    `(do ~@assignments)))

;; =============================================================================
;; Profiling / Metrics macros
;; =============================================================================

(defonce *metrics* (atom {}))
(defonce *metrics-enabled* (atom false))

(defn now-us
  "Get current time in microseconds (from nanoseconds)."
  []
  #_(quot (@#'clojure.core/current-time) 1000)
  ;; Use cpp/raw instead of @#'clojure.core/current-time to avoid JIT var ref issues
  #_(let* [ns-time (cpp/raw "jank::i64"
                            "std::chrono::duration_cast<std::chrono::nanoseconds>(std::chrono::high_resolution_clock::now().time_since_epoch()).count()")]
      (quot ns-time 1000))
  0)

(defn record-metric!
  "Record a timing measurement for the given key."
  [key elapsed-us]
  (swap! *metrics* update key
    (fn [m]
      (let [m (or m {:count 0 :total-us 0 :min-us 999999999 :max-us 0})]
        {:count (inc (:count m))
         :total-us (+ (:total-us m) elapsed-us)
         :min-us (min (:min-us m) elapsed-us)
         :max-us (max (:max-us m) elapsed-us)}))))

(defn reset-metrics!
  "Reset all collected metrics."
  []
  (reset! *metrics* {}))

(defn enable-metrics!
  "Enable metrics collection."
  []
  (reset! *metrics-enabled* true))

(defn disable-metrics!
  "Disable metrics collection."
  []
  (reset! *metrics-enabled* false))

(defn- pad-left
  "Pad string s to width with spaces on the left."
  [s width]
  (let [s (str s)
        len (count s)]
    (if (>= len width)
      s
      (str (apply str (repeat (- width len) " ")) s))))

(defn- pad-right
  "Pad string s to width with spaces on the right."
  [s width]
  (let [s (str s)
        len (count s)]
    (if (>= len width)
      s
      (str s (apply str (repeat (- width len) " "))))))

(defn- insert-sorted
  "Insert item into sorted-vec maintaining descending order by key-fn."
  [sorted-vec item key-fn]
  (let [k (key-fn item)]
    (loop [idx 0]
      (if (>= idx (count sorted-vec))
        (conj sorted-vec item)
        (if (> k (key-fn (nth sorted-vec idx)))
          (into (conj (subvec sorted-vec 0 idx) item) (subvec sorted-vec idx))
          (recur (inc idx)))))))

(defn- sort-by-desc
  "Sort collection by key-fn in descending order."
  [key-fn coll]
  (reduce #(insert-sorted %1 %2 key-fn) [] coll))

(defn- format-metric-row
  "Format a single metric row with vector key at the end."
  [k v ref-total]
  (let [{:keys [count total-us min-us max-us]} v
        avg-us (if (> count 0) (/ total-us count) 0)
        total-ms (/ total-us 1000.0)
        pct (if (> ref-total 0) (/ (* 100.0 total-us) ref-total) 0.0)]
    (str (pad-left count 10)
         (pad-left total-ms 14)
         (pad-left (str (int pct) "%") 6)
         (pad-left avg-us 10)
         (pad-left min-us 8)
         (pad-left max-us 8)
         "  " (pr-str k))))

(defn- build-hierarchy
  "Build a tree of metrics based on vector key prefix relationships.
   [:A B] is child of [:A], [:A B C] is child of [:A B], etc."
  [metrics]
  (let [all-keys (keys metrics)
        ;; Get total-us for a key, defaulting to 0 if not found
        get-total (fn [k] (or (:total-us (get metrics k)) 0))
        ;; Find parent for each key (parent is key without last element)
        find-parent (fn [k]
                      (when (and (vector? k) (> (clojure.core/count k) 1))
                        (let [parent (vec (butlast k))]
                          (when (contains? metrics parent)
                            parent))))
        ;; Group by parent
        grouped (group-by find-parent all-keys)
        roots (get grouped nil [])
        ;; Build tree recursively
        build-tree (fn build-tree [parent-key]
                     (let [children (get grouped parent-key [])
                           sorted-children (sort-by-desc get-total children)]
                       (mapcat (fn [child]
                                 (cons child (build-tree child)))
                               sorted-children)))]
    ;; Start with roots sorted by total, then their children
    (let [sorted-roots (sort-by-desc get-total roots)]
      (mapcat (fn [root]
                (cons root (build-tree root)))
              sorted-roots))))

(defn- is-timed-overhead?
  "Check if key is a :timed/* overhead key."
  [k]
  (and (keyword? k) (= "timed" (namespace k))))

(defn print-metrics
  "Print collected metrics sorted by total time (descending).
   Shows: count, total-ms, %, avg-us, min, max, key (vector with indentation)

   By default, excludes :timed/* overhead, showing real work percentages.
   Pass true to include all metrics (overhead) in full report."
  ([] (print-metrics false))
  ([show-overhead?]
   (let [metrics @*metrics*
         ;; Filter out :timed/* keys unless showing overhead
         non-overhead (into {} (filter (fn [[k _]] (not (is-timed-overhead? k))) metrics))
         ;; Find the main wrapper (shortest vector or largest total)
         main-entry (first (sort-by-desc (fn [[_ v]] (:total-us v)) non-overhead))
         main-key (if main-entry (first main-entry) nil)
         main-total (if main-entry (:total-us (second main-entry)) 0)
         ;; For display, include all non-overhead
         filtered (if show-overhead? metrics non-overhead)
         ;; Sum of non-root operations (real work)
         work-total (reduce + 0 (map (fn [[_ v]] (:total-us v))
                                     (filter (fn [[k _]] (and (not (is-timed-overhead? k))
                                                              (not (= k main-key)))) non-overhead)))
         ;; Sum of overhead
         overhead-total (reduce + 0 (map (fn [[_ v]] (:total-us v))
                                         (filter (fn [[k _]] (is-timed-overhead? k)) metrics)))
         ;; Reference for percentages
         ref-total (if show-overhead?
                     (reduce + 0 (map (fn [[_ v]] (:total-us v)) metrics))
                     work-total)
         ;; Build hierarchical order
         ordered-keys (build-hierarchy filtered)]
     (println (if show-overhead?
                "\n=== METRICS (FULL WITH OVERHEAD) ==="
                "\n=== METRICS (REAL WORK) ==="))
     (when-not show-overhead?
       (println (str "Main wrapper: " (/ main-total 1000.0) " ms"))
       (println (str "Real work: " (/ work-total 1000.0) " ms ("
                     (int (/ (* 100.0 work-total) main-total)) "%)"))
       (println (str "Overhead: " (/ overhead-total 1000.0) " ms ("
                     (int (/ (* 100.0 overhead-total) main-total)) "%)")))
     (println (str (pad-left "Count" 10)
                   (pad-left "Total(ms)" 14)
                   (pad-left "%" 6)
                   (pad-left "Avg(us)" 10)
                   (pad-left "Min" 8)
                   (pad-left "Max" 8)
                   "  Key"))
     (println (apply str (repeat 80 "-")))
     (doseq [k ordered-keys]
       (let [v (get filtered k)]
         (println (format-metric-row k v ref-total))))
     (println "=======\n"))))

(defmacro timed
  "Time a single form and record under the given key.
   Only records if *metrics-enabled* is true.
   Uses inline timing that works with native C++ types.
   Also records detailed overhead metrics.

   Usage: (timed :my-operation (expensive-computation))"
  [key form]
  ;; Don't use if around the form - it breaks native C++ reference types
  ;; Instead, always execute form and conditionally record timing
  `(let [t0# (now-us)
         enabled# @*metrics-enabled*
         t1# (now-us)
         start# (when enabled# (now-us))
         t2# (now-us)]
     (let [result# ~form]
       (when enabled#
         (let [t3# (now-us)
               end# (now-us)
               t4# (now-us)]
           (record-metric! ~key (- end# start#))
           (let [t5# (now-us)]
             (record-metric! :timed/now-us (+ (- t1# t0#) (- t2# t1#) (- t4# t3#)))
             (record-metric! :timed/deref (- t1# t0#))
             (let [t6# (now-us)]
               (record-metric! :timed/record (- t6# t5#))
               (let [t7# (now-us)]
                 ;; Measure let/when overhead: t2->t3 is form execution + let binding
                 ;; We subtract form time to get just the let/when overhead
                 (record-metric! :timed/let-when (- (- t3# t2#) (- end# start#)))
                 (record-metric! :timed/meta-record (- t7# t6#)))))))
       result#)))

(defn- replace-slash
  "Replace / with - in a string (workaround for missing clojure.string/replace)."
  [s]
  (apply str (map #(if (= % \/) \- %) s)))

(declare wrap-form)

(defn- make-form-name
  "Convert a form head to a keyword for the path (keywords don't get evaluated).
   Preserves namespace: imgui/Text -> :imgui/Text, cpp/float. -> :cpp/float."
  [f]
  (cond
    (symbol? f) (keyword (namespace f) (name f))
    (keyword? f) f
    :else :anon))

(defn- wrap-bindings
  "Wrap binding expressions in a let/let* vector.
   [x (foo) y (bar)] -> [x (timed [:path foo] (foo)) y (timed [:path bar] (bar))]"
  [path bindings]
  (loop [result []
         remaining (seq bindings)]
    (if (empty? remaining)
      result
      (let [sym (first remaining)
            expr (second remaining)
            wrapped-expr (wrap-form path expr)]
        (recur (conj result sym wrapped-expr)
               (drop 2 remaining))))))

(defn- wrap-form
  "Recursively wrap a form with timing. Returns the wrapped form.
   path is a vector like [:AA] that gets extended as we recurse into nested calls."
  [path form]
  (if-not (seq? form)
    form
    (let [head (first form)
          form-name (make-form-name head)
          new-path (conj path form-name)]
      (cond
        ;; do block - wrap each child
        (= head 'do)
        (let [wrapped-children (map #(wrap-form path %) (rest form))]
          `(do ~@wrapped-children))

        ;; let block - wrap binding expressions AND body forms
        (= head 'let)
        (let [bindings (second form)
              body (drop 2 form)
              wrapped-bindings (wrap-bindings path bindings)
              wrapped-body (map #(wrap-form path %) body)]
          `(let ~wrapped-bindings ~@wrapped-body))

        ;; let* block - wrap binding expressions AND body forms
        (= head 'let*)
        (let [bindings (second form)
              body (drop 2 form)
              wrapped-bindings (wrap-bindings path bindings)
              wrapped-body (map #(wrap-form path %) body)]
          `(let* ~wrapped-bindings ~@wrapped-body))

        ;; when block - wrap test AND body forms
        (= head 'when)
        (let [test (second form)
              body (drop 2 form)
              wrapped-test (wrap-form path test)
              wrapped-body (map #(wrap-form path %) body)]
          `(when ~wrapped-test ~@wrapped-body))

        ;; when-not block - wrap test AND body forms
        (= head 'when-not)
        (let [test (second form)
              body (drop 2 form)
              wrapped-test (wrap-form path test)
              wrapped-body (map #(wrap-form path %) body)]
          `(when-not ~wrapped-test ~@wrapped-body))

        ;; when-let - wrap binding expression and body
        (= head 'when-let)
        (let [bindings (second form)
              body (drop 2 form)
              wrapped-bindings (wrap-bindings path bindings)
              wrapped-body (map #(wrap-form path %) body)]
          `(when-let ~wrapped-bindings ~@wrapped-body))

        ;; if-let - wrap binding expression and branches
        (= head 'if-let)
        (let [bindings (second form)
              then-form (nth form 2)
              else-form (when (> (clojure.core/count form) 3) (nth form 3))
              wrapped-bindings (wrap-bindings path bindings)]
          (if else-form
            `(if-let ~wrapped-bindings
               ~(wrap-form path then-form)
               ~(wrap-form path else-form))
            `(if-let ~wrapped-bindings
               ~(wrap-form path then-form))))

        ;; if block - wrap test, then and else
        (= head 'if)
        (let [test (second form)
              then-form (nth form 2)
              else-form (when (> (clojure.core/count form) 3) (nth form 3))
              wrapped-test (wrap-form path test)]
          (if else-form
            `(if ~wrapped-test
               ~(wrap-form path then-form)
               ~(wrap-form path else-form))
            `(if ~wrapped-test
               ~(wrap-form path then-form))))

        ;; doseq - wrap binding expressions and body
        (= head 'doseq)
        (let [bindings (second form)
              body (drop 2 form)
              wrapped-bindings (wrap-bindings path bindings)
              wrapped-body (map #(wrap-form path %) body)]
          `(doseq ~wrapped-bindings ~@wrapped-body))

        ;; -> threading macro - wrap the initial value and each step
        (= head '->)
        (let [init (second form)
              steps (drop 2 form)
              wrapped-init (wrap-form path init)]
          ;; For threading, wrap the whole pipeline as a single operation
          `(timed ~new-path (-> ~wrapped-init ~@steps)))

        ;; ->> threading macro
        (= head '->>)
        (let [init (second form)
              steps (drop 2 form)
              wrapped-init (wrap-form path init)]
          `(timed ~new-path (->> ~wrapped-init ~@steps)))

        ;; cond - wrap both test AND result forms
        (= head 'cond)
        (let [pairs (partition 2 (rest form))
              wrapped-pairs (mapcat (fn [[test result]]
                                      [(wrap-form path test) (wrap-form path result)])
                                    pairs)]
          `(cond ~@wrapped-pairs))

        ;; Regular function call - wrap the call AND recursively wrap nested args with extended path
        ;; Only skip cpp/value forms (from #cpp "...") - they return C++ string types
        :else
        (let [cpp-value-form? (fn [f] (and (seq? f)
                                           (= (first f) 'cpp/value)))
              ;; Wrap nested args with the NEW path (including this form)
              wrapped-args (map #(if (and (seq? %) (not (cpp-value-form? %)))
                                   (wrap-form new-path %)
                                   %)
                                (rest form))]
          `(timed ~new-path (~head ~@wrapped-args)))))))

(defmacro with-metrics
  "Wrap a body of forms, timing each form recursively.
   Keys are vectors showing the call path.

   Usage:
     (with-metrics :draw-ui
       (imgui/Begin \"Window\")      ; timed as [:draw-ui imgui-Begin]
       (imgui/Text (format x))      ; timed as [:draw-ui imgui-Text] and [:draw-ui imgui-Text format]
       (imgui/End))                 ; timed as [:draw-ui imgui-End]"
  [name & body]
  (let [root-path [name]
        wrapped (map #(wrap-form root-path %) body)]
    `(timed ~root-path (do ~@wrapped))))

(defmacro profile
  "Profile a function body, timing each top-level form.
   Designed to wrap function bodies for detailed profiling.

   Usage:
     (defn my-fn []
       (profile :my-fn
         (step-1)
         (step-2)
         (step-3)))"
  [name & body]
  `(with-metrics ~name ~@body))

;; =============================================================================
;; defn* macro - for functions that return native C++ types
;; =============================================================================

(defmacro defn*
  "Define a macro that returns a native C++ type.
   When :tag metadata specifies a native type, generates a macro
   that inlines the body and wraps the result in cpp/unbox.

   This is needed because jank functions must return object_ref due to
   virtual dispatch, but we often need to return native types for C interop.

   Usage:
     (defn* ^{:tag \"ecs_world_t*\"} world-ptr [world]
       world)

   Expands to a macro that inlines: (cpp/unbox (cpp/type \"ecs_world_t*\") world)"
  [name & body]
  (let [m (meta name)
        tag (:tag m)
        ;; Parse optional docstring
        [docstring params forms] (if (string? (first body))
                                   [(first body) (second body) (drop 2 body)]
                                   [nil (first body) (rest body)])]
    (if tag
      ;; Generate a macro that wraps body result in cpp/unbox
      `(defmacro ~(with-meta name (dissoc m :tag))
         ~@(when docstring [docstring])
         ~params
         (list (quote cpp/unbox)
               (list (quote cpp/type) ~tag)
               ~@forms))
      ;; No tag, just use regular defn
      `(defn ~name ~@body))))
