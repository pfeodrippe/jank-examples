(ns vybe.app.drawing
  (:require
   ["vybe/app/drawing/native/drawing_canvas.hpp" :as canvas :scope "dc"]
   [vybe.app.drawing.core :as core]
   [vybe.app.drawing.state :as state]
   [vybe.app.drawing.math :as math]
   [vybe.app.drawing.input :as input]
   [jank.nrepl-server.server :as server]))

;; =============================================================================
;; Rendering - send triangles to GPU
;; =============================================================================

(defn render-triangles!
  "Send triangle vertices to the native rendering layer."
  [triangles]
  (doseq [{:keys [x1 y1 x2 y2 x3 y3 r g b a]} triangles]
    (canvas/add_triangle
     (float x1) (float y1)
     (float x2) (float y2)
     (float x3) (float y3)
     (float r) (float g) (float b) (float a))))

(defn render-stroke-triangles!
  "Render stroke triangles (from math/stroke->triangles output)."
  [triangle-verts]
  ;; triangle-verts is a flat vector of {:x :y :r :g :b :a} maps
  ;; We need to group into triangles (3 vertices each)
  (doseq [tri (partition 3 triangle-verts)]
    (let [[v1 v2 v3] tri]
      (canvas/add_triangle
       (float (:x v1)) (float (:y v1))
       (float (:x v2)) (float (:y v2))
       (float (:x v3)) (float (:y v3))
       (float (:r v1)) (float (:g v1)) (float (:b v1)) (float (:a v1))))))

;; =============================================================================
;; Canvas texture management (for performance)
;; =============================================================================

(defn rebuild-canvas-texture!
  "Rebuild canvas texture with all frame strokes (only when needed)."
  []
  (when (canvas/has_canvas_texture)
    ;; Clear the canvas texture
    (canvas/clear_canvas)

    ;; Render all frame strokes to canvas texture
    (let [strokes (state/get-frame-strokes)]
      (when (seq strokes)
        (canvas/begin_canvas_render)
        (canvas/clear_vertices)
        (let [triangles (math/strokes->triangles strokes)]
          (render-stroke-triangles! triangles)
          (canvas/render_vertices))
        (canvas/end_canvas_render)))

    ;; Mark as clean
    (state/clear-canvas-dirty!)))

(defn render-stroke-to-texture!
  "Render a single stroke to the canvas texture (incremental caching)."
  [stroke]
  (when (and (canvas/has_canvas_texture) (not (empty? stroke)))
    (canvas/begin_canvas_render)
    (canvas/clear_vertices)
    (let [triangles (math/strokes->triangles [stroke])]
      (render-stroke-triangles! triangles)
      (canvas/render_vertices))
    (canvas/end_canvas_render)))

(defn render-current-stroke!
  "Render only the current in-progress stroke."
  []
  (let [current (state/get-current-stroke)]
    (when-not (empty? current)
      ;; Full tessellation for current stroke (simpler, reliable)
      ;; Texture caching for finished strokes is where we save performance
      (canvas/clear_vertices)
      (let [triangles (math/stroke->triangles current)]
        (render-stroke-triangles! triangles)
        (canvas/render_vertices)))))

;; =============================================================================
;; Main render function
;; =============================================================================

(defn render-frame!
  "Render all strokes for the current frame."
  []
  ;; Set background color
  (let [[r g b a] (state/get-bg-color)]
    (canvas/set_bg_color (float r) (float g) (float b) (float a)))

  ;; Check if we need to rebuild the canvas texture (only for frame changes, undo, etc.)
  (when (state/canvas-needs-rebuild?)
    (rebuild-canvas-texture!))

  ;; Check if there's a just-completed stroke to add incrementally
  (when (state/has-just-completed-stroke?)
    (render-stroke-to-texture! (state/get-just-completed-stroke))
    (state/clear-just-completed-stroke!))

  ;; Draw cached canvas texture (all finished strokes)
  (when (canvas/has_canvas_texture)
    (canvas/draw_canvas))

  ;; Draw current stroke on top
  (render-current-stroke!))

;; =============================================================================
;; Screenshot
;; =============================================================================

(defn screenshot!
  "Take a screenshot and save to file. Returns true on success."
  ([]
   (screenshot! (str "/tmp/drawing_" (canvas/get_timestamp) ".bmp")))
  ([filename]
   (canvas/take_screenshot filename)))

;; =============================================================================
;; Main loop
;; =============================================================================

(defn run-frame!
  "Process one frame of the app."
  []
  ;; Start timing
  (canvas/start_frame_timing)

  ;; Poll and process input events
  (canvas/poll_events)
  (input/process-events!)

  ;; Render
  (canvas/begin_frame)
  (render-frame!)
  (canvas/end_frame)

  ;; End timing
  (canvas/end_frame_timing))

;; =============================================================================
;; Performance stats
;; =============================================================================

(defn get-frame-stats
  "Get current frame performance stats."
  []
  {:last-frame-ms (canvas/get_last_frame_ms)
   :avg-frame-ms (canvas/get_avg_frame_ms)
   :fps (canvas/get_fps)
   :vertex-count (canvas/get_vertex_count)})

(defn run-app!
  "Main app loop. Optional nrepl-port defaults to 5580."
  ([] (run-app! 5580))
  ([nrepl-port]
   (println "")
   (println "========================================")
   (println "   Drawing Canvas - Phase 1")
   (println "========================================")
   (println "")

   ;; Start nREPL server for interactive testing
   (server/start-server {:port nrepl-port :bind "0.0.0.0"})
   (println (str "nREPL server started on port " nrepl-port))

   ;; Initialize native canvas
   (when (canvas/init 1024 768 "Drawing Canvas")
     (println "Canvas initialized!")
     (println "Draw with mouse or touch...")
     (println "")

     ;; Main loop
     (loop []
       (when-not (canvas/should_close)
         (run-frame!)
         (recur)))

     ;; Cleanup
     (canvas/cleanup)
     (println "Canvas closed."))))

(defn -main
  "Entry point. Optional nrepl-port defaults to 5580 (desktop), use 5581 for iOS."
  ([] (run-app!))
  ([nrepl-port] (run-app! nrepl-port)))
