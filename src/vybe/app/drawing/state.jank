;; State management for drawing app
;; ALL IN JANK - using atoms for mutable state

(ns vybe.app.drawing.state
  (:require [vybe.app.drawing.core :as core]
            ["vybe/app/drawing/native/drawing_canvas.hpp" :as canvas :scope "dc"]))

;; =============================================================================
;; Global state atoms
;; =============================================================================

;; The current weave (project)
(defonce *weave (atom (core/make-weave "Untitled")))

;; Current stroke being drawn ({} empty map when not drawing)
(defonce *current-stroke (atom {}))

;; Cached triangles for current stroke (for incremental rendering)
(defonce *current-stroke-triangles (atom []))

;; Number of points already tessellated in current stroke
(defonce *current-stroke-tessellated-count (atom 0))

;; Are we currently drawing?
(defonce *drawing? (atom false))

;; Undo/redo history
(defonce *history (atom []))
(defonce *history-index (atom -1))

;; =============================================================================
;; Canvas texture state (for performance - caching finished strokes)
;; =============================================================================

;; When true, the canvas texture needs to be re-rendered from scratch
(defonce *canvas-needs-rebuild (atom true))

;; Stroke that was just completed (needs to be rendered to texture)
(defonce *just-completed-stroke (atom {}))

(defn mark-canvas-dirty! []
  "Mark that canvas texture needs full rebuild (e.g., after undo, frame change)."
  (reset! *canvas-needs-rebuild true))

(defn clear-canvas-dirty! []
  "Clear the rebuild flag after rebuilding."
  (reset! *canvas-needs-rebuild false))

(defn canvas-needs-rebuild? []
  @*canvas-needs-rebuild)

(defn get-just-completed-stroke []
  "Get the stroke that was just completed (for incremental rendering)."
  @*just-completed-stroke)

(defn clear-just-completed-stroke! []
  "Clear the just-completed stroke after rendering it."
  (reset! *just-completed-stroke {}))

(defn has-just-completed-stroke? []
  "Check if there's a stroke waiting to be rendered to texture."
  (not (empty? @*just-completed-stroke)))

;; =============================================================================
;; Weave accessors
;; =============================================================================

(defn get-weave []
  @*weave)

(defn get-active-thread []
  (core/get-active-thread @*weave))

(defn get-current-frame []
  (core/get-current-frame (get-active-thread)))

(defn get-bg-color []
  (:bg-color @*weave))

(defn get-thread-color []
  (:color (get-active-thread)))

(defn get-line-width []
  (:line-width (get-active-thread)))

;; =============================================================================
;; Drawing state
;; =============================================================================

(defn drawing? []
  @*drawing?)

(defn start-drawing! [x y pressure]
  (let [thread (get-active-thread)
        stroke (core/make-stroke (:color thread) (:line-width thread))
        point (core/make-point x y pressure (canvas/get_time_ms))
        [r g b a] (:color thread)
        line-width (:line-width thread)]
    (reset! *current-stroke (core/add-point-to-stroke stroke point))
    (reset! *current-stroke-triangles [])
    (reset! *current-stroke-tessellated-count 0)
    (reset! *drawing? true)
    ;; Start Metal stroke
    (canvas/metal_set_brush_size line-width)
    (canvas/metal_set_brush_color (float r) (float g) (float b) (float a))
    (canvas/metal_begin_stroke (float x) (float y) (float pressure))
    ;; Set brush and color for animation recording
    (canvas/set_anim_brush (float line-width) 0.0 1.0 0.15  ; size, hardness, opacity, spacing
                           (int 0) (int 0) 1.0 (int 0)      ; shape/grain tex, grainScale, inverted
                           1.0 0.0                           ; sizePressure, opacityPressure
                           0.0 0.0 0.0 0.0)                  ; jitters, scatter
    (canvas/set_anim_stroke_color (float r) (float g) (float b) (float a))
    ;; Also record to animation system
    (canvas/begin_anim_stroke (float x) (float y) (float pressure))))

;; Maximum distance between points before we interpolate
(def +max-point-distance+ 15.0)

(defn interpolate-point
  "Interpolate between two points at parameter t (0-1)."
  [p1 p2 t]
  {:x (core/lerp (:x p1) (:x p2) t)
   :y (core/lerp (:y p1) (:y p2) t)
   :pressure (core/lerp (:pressure p1) (:pressure p2) t)
   :timestamp (int (core/lerp (:timestamp p1) (:timestamp p2) t))})

(defn add-drawing-point! [x y pressure]
  (when @*drawing?
    (let [current @*current-stroke
          points (:points current)
          new-point (core/make-point x y pressure (canvas/get_time_ms))]
      (if (empty? points)
        ;; First point - just add it
        (swap! *current-stroke core/add-point-to-stroke new-point)
        ;; Check distance from last point
        (let [last-pt (last points)
              dist (core/point-distance last-pt new-point)]
          (if (> dist +max-point-distance+)
            ;; Too far - add interpolated points
            (let [n (int (/ dist +max-point-distance+))]
              (loop [i 1
                     stroke current]
                (if (> i n)
                  ;; Add final point
                  (reset! *current-stroke (core/add-point-to-stroke stroke new-point))
                  ;; Add interpolated point
                  (let [t (/ (float i) (float (inc n)))
                        interp-pt (interpolate-point last-pt new-point t)]
                    (recur (inc i)
                           (core/add-point-to-stroke stroke interp-pt))))))
            ;; Normal distance - just add
            (swap! *current-stroke core/add-point-to-stroke new-point)))))
    ;; Add point to Metal stroke (Metal does its own interpolation)
    (canvas/metal_add_stroke_point (float x) (float y) (float pressure))
    ;; Also record to animation system
    (canvas/add_anim_stroke_point (float x) (float y) (float pressure))))

(defn end-drawing! []
  (when @*drawing?
    (let [stroke @*current-stroke]
      ;; Only add stroke if it has enough points
      (when (> (core/stroke-point-count stroke) 1)
        (swap! *weave core/update-active-thread
               core/update-current-frame
               core/add-stroke-to-frame stroke)
        ;; Store for incremental rendering (NOT full rebuild!)
        (reset! *just-completed-stroke stroke))
      (reset! *current-stroke {})
      (reset! *drawing? false)
      ;; End Metal stroke - commits to canvas texture
      (canvas/metal_end_stroke)
      ;; Also end animation stroke - stores in current animation frame
      (canvas/end_anim_stroke))))

(defn get-current-stroke []
  @*current-stroke)

(defn get-current-stroke-triangles []
  @*current-stroke-triangles)

(defn get-current-stroke-tessellated-count []
  @*current-stroke-tessellated-count)

(defn update-current-stroke-triangles! [new-triangles new-count]
  "Update the cached triangles with new ones."
  (swap! *current-stroke-triangles into new-triangles)
  (reset! *current-stroke-tessellated-count new-count))

;; =============================================================================
;; All strokes for rendering (current frame + in-progress stroke)
;; =============================================================================

(defn get-all-strokes-to-render []
  "Get all strokes that need to be rendered this frame."
  (let [frame-strokes (:strokes (get-current-frame))
        current @*current-stroke]
    (if (empty? current)
      frame-strokes
      (conj frame-strokes current))))

;; =============================================================================
;; Thread/frame manipulation
;; =============================================================================

(defn set-thread-color! [color]
  (swap! *weave core/update-active-thread assoc :color color))

(defn set-line-width! [width]
  (swap! *weave core/update-active-thread assoc :line-width width))

(defn add-frame! []
  (swap! *weave core/update-active-thread
         (fn [thread]
           (let [new-frame (core/make-frame)
                 frames (:frames thread)
                 idx (inc (:current-frame thread))]
             (-> thread
                 (update :frames #(vec (concat (take idx %) [new-frame] (drop idx %))))
                 (assoc :current-frame idx))))))

(defn next-frame! []
  (swap! *weave core/update-active-thread
         (fn [thread]
           (let [max-idx (dec (count (:frames thread)))
                 new-idx (min max-idx (inc (:current-frame thread)))]
             (assoc thread :current-frame new-idx)))))

(defn prev-frame! []
  (swap! *weave core/update-active-thread
         (fn [thread]
           (let [new-idx (max 0 (dec (:current-frame thread)))]
             (assoc thread :current-frame new-idx)))))

;; Get only the frame strokes (for rebuilding canvas texture)
(defn get-frame-strokes []
  (:strokes (get-current-frame)))

;; =============================================================================
;; Clear/reset
;; =============================================================================

(defn clear-current-frame! []
  (swap! *weave core/update-active-thread
         core/update-current-frame
         assoc :strokes [])
  ;; Mark canvas dirty so it gets cleared
  (mark-canvas-dirty!))

(defn new-weave! [name]
  (reset! *weave (core/make-weave name))
  (reset! *current-stroke {})
  (reset! *drawing? false)
  (mark-canvas-dirty!))

;; =============================================================================
;; Animation frame navigation (syncs C++ animation system with jank state)
;; =============================================================================

(defn anim-next-frame!
  "Go to next animation frame. Creates new frame if at end."
  []
  (let [current-idx (canvas/get_current_frame_index)
        frame-count (canvas/get_anim_frame_count)]
    (if (>= (inc current-idx) frame-count)
      ;; At end - add new frame
      (canvas/add_anim_frame_after_current)
      ;; Go to next
      (canvas/next_anim_frame))
    ;; Clear Metal canvas and re-render the new frame's strokes
    (let [[r g b a] (get-bg-color)]
      (canvas/metal_clear_canvas (float r) (float g) (float b) (float a)))
    ;; Render onion skin (ghost frames) first
    (canvas/render_anim_onion_skin)
    ;; Then render current frame's strokes
    (canvas/render_anim_current_frame)
    ;; Also sync jank state
    (next-frame!)
    (mark-canvas-dirty!)
    {:frame (canvas/get_current_frame_index)
     :total (canvas/get_anim_frame_count)
     :strokes (canvas/get_current_anim_frame_stroke_count)}))

(defn anim-prev-frame!
  "Go to previous animation frame."
  []
  (canvas/prev_anim_frame)
  ;; Clear Metal canvas and re-render the new frame's strokes
  (let [[r g b a] (get-bg-color)]
    (canvas/metal_clear_canvas (float r) (float g) (float b) (float a)))
  ;; Render onion skin (ghost frames) first
  (canvas/render_anim_onion_skin)
  ;; Then render current frame's strokes
  (canvas/render_anim_current_frame)
  ;; Also sync jank state
  (prev-frame!)
  (mark-canvas-dirty!)
  {:frame (canvas/get_current_frame_index)
   :total (canvas/get_anim_frame_count)
   :strokes (canvas/get_current_anim_frame_stroke_count)})

(defn anim-goto-frame!
  "Jump to a specific animation frame."
  [index]
  (canvas/goto_anim_frame (int index))
  ;; Clear Metal canvas and re-render the new frame's strokes
  (let [[r g b a] (get-bg-color)]
    (canvas/metal_clear_canvas (float r) (float g) (float b) (float a)))
  ;; Render onion skin (ghost frames) first
  (canvas/render_anim_onion_skin)
  ;; Then render current frame's strokes
  (canvas/render_anim_current_frame)
  (mark-canvas-dirty!)
  {:frame (canvas/get_current_frame_index)
   :total (canvas/get_anim_frame_count)
   :strokes (canvas/get_current_anim_frame_stroke_count)})

(defn anim-status
  "Get current animation status."
  []
  {:frame (canvas/get_current_frame_index)
   :total (canvas/get_anim_frame_count)
   :strokes (canvas/get_current_anim_frame_stroke_count)
   :threads (canvas/get_thread_count)
   :fps (canvas/get_anim_thread_fps)
   :playing? (canvas/is_anim_playing)})

;; =============================================================================
;; Animation Playback
;; =============================================================================

(defn anim-play!
  "Start animation playback."
  []
  (canvas/play_anim)
  {:playing? true})

(defn anim-pause!
  "Pause animation playback."
  []
  (canvas/pause_anim)
  {:playing? false})

(defn anim-toggle-play!
  "Toggle animation playback."
  []
  (canvas/toggle_anim_playback)
  {:playing? (canvas/is_anim_playing)})

(defn anim-set-fps!
  "Set animation FPS."
  [fps]
  (canvas/set_anim_thread_fps (float fps))
  {:fps (canvas/get_anim_thread_fps)})

(defn anim-set-onion-skin!
  "Set onion skin mode (0=off, 1=before, 2=after, 3=both)."
  [mode]
  (canvas/set_anim_onion_skin_mode (int mode))
  {:onion-mode (canvas/get_anim_onion_skin_mode)})

;; Track previous frame for playback rendering
(defonce *prev-anim-frame (atom -1))

(defn anim-update-playback!
  "Update animation playback. Call each frame. Returns true if frame changed."
  [delta-time]
  (when (canvas/is_anim_playing)
    (let [prev-frame @*prev-anim-frame
          _ (canvas/update_anim (float delta-time))
          new-frame (canvas/get_current_frame_index)]
      (when (not= prev-frame new-frame)
        ;; Frame changed - re-render
        (let [[r g b a] (get-bg-color)]
          (canvas/metal_clear_canvas (float r) (float g) (float b) (float a)))
        (canvas/render_anim_current_frame)
        (reset! *prev-anim-frame new-frame)
        true))))
