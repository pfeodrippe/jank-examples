(ns my-example
  (:require
   [jank.compiler :as jc]
   [jank.nrepl-server.server :as server]
   [jank.export :as je]
   ["clojure/string_native.hpp" :as str-native :refer [starts_with]]))

;; PATH="/Users/pfeodrippe/dev/jank/compiler+runtime/build:$PATH" jank --module-path src run-main eita
;; PATH="/Users/pfeodrippe/dev/jank/compiler+runtime/build:$PATH" jank -Ivendor/flecs/distr -lvendor/flecs/distr/libflecs.dylib --module-path src run-main my-example start-server
;; PATH="/Users/pfeodrippe/dev/jank/compiler+runtime/build:$PATH" llbd jank -I./vendor/flecs/distr --module-path src run-main my-example start-server

#_(cpp/raw "#define FLECS_IMPLEMENTATION")
#_(cpp/raw "#include <flecs.c>")
#_(cpp/raw "#include <flecs.h>")

#_(def w (cpp/box (cpp/ecs_init)))

(comment

  (cpp/box (cpp/& (cpp/int 55)))
  (cpp/raw "make_box<obj::native_pointer_wrapper>(ecs_init())")
  (do (cpp/raw "ecs_world_t* v = ecs_init() ;")
      4)

  (def w (jc/native-source '(cpp/box (cpp/ecs_init))))


  (str-native/reverse "abcf ")
  ;; is equivalent to
  (cpp/clojure.string_native.reverse "abcf ")

  (starts_with "Sabor" "S")
  ;; is equivalent to
  (cpp/clojure.string_native.starts_with "Sabor" "S")

  (server/start-server {:port 5557})

  (ns-publics (symbol (namespace `server/start-server)))

  (jank.compiler/native-source '(fn [x] (+ 4 x)))
  (jank.compiler/native-cpp-source '(fn [x] (+ 4 x)))
  (jc/native-cpp-source '(cpp/my_add 4 5))

  (let [w (cpp/ecs_init)]
    nil)

  (-main)

  (cpp/raw "
#include <iostream>
#include <array> // For std::array

int ttt(int x) {
    std::array<int, 5> arr = {10, 20, 30, 40, 50};

    for (auto it = arr.begin(); it != arr.end(); ++it) {
        std::cout << *it << \" \"; // Dereference the iterator to get the element
    }
    std::cout << std::endl;
    return x;
}
")

  ())

(defn my-apply [f x]
  (f x))

(jank.export/register
 #'my-apply
 "my_apply"
 [:=> [:cat [:fn [:long] :long] :long] :long])

(cpp/raw "
static void eita5(float* arr, int num_of_samples) {
    for (int i = 0; i < num_of_samples; i++) {
       arr[i] = arr [i] * 0.1;
    }
}
")

(defn aaa
  [arr num-of-samples]
  (println :NN num-of-samples)
  #_(cpp/eita5 (cpp/unbox cpp/float* arr) num-of-samples))

(defn multiplier []
  (fn [_ arr num-of-samples]
    (aaa arr num-of-samples)
    nil))

(jank.export/register
 #'multiplier
 "my_multiplier"
 [:=> [:cat] [:fn [::void ::void :int] :void]])

#_(jc/native-aot-entrypoint-source
 ' (jank.export/register
    #'multiplier
    "my_multiplier"
    [:=> [:cat] [:fn [::void :vector :int] :void]]))

(comment

  (cpp/raw "
#include <dlfcn.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

typedef long (*my_apply_cb_fn)(long);
typedef long (*my_apply_fn)(my_apply_cb_fn, long);

static long host_square2(long x)
{
  return x * x;
}

int ddd (void) {
my_apply_fn my_apply = (my_apply_fn)dlsym(NULL, \"my_apply\");
if(my_apply == NULL)
  {
   return 1;
  }
return 0;
}
")

  (cpp/my_inc2)

  (cpp/raw "func_ptr3(host_square2, 5);")

  ())

(cpp/raw "
 inline int cpp_rawinline_hello() {
  return 20;
}
")

#_(cpp/raw "
 idfnlinde int cpp_rawinline_hello() {
  return 10;
}
")

(defn -main [& args]
  (println :ARGS args)
  #_(println (cpp/cpp_rawinline_hello))
  #_(printjln (cpp/cpp_rawinline_hello))
  (if (= (first args) "start-server")
    (let [srv (server/start-server {:port 5557})]
      (read-line)
      (server/stop-server srv))
    (println :INIT)))

#_(defn -main [& args]
    (println (str "shared-lib-invoked/" (count args))))

(defn sample-fn "demo doc"
  ([x] x)
  ([x y] (+ x y)))

(def my-fn
  "My function"
  (fn* [x] (+ x 10)))

(def ^{:arglists '([x] [y x])
       :doc "My function"}
  my-fn
  (fn* [x] (+ x 10)))

;; Structs.
(comment

  (cpp/raw "namespace eita::cpp::constructor::complex::pass_argument
          {
            struct foo
            {
              foo(int const v)
               : a{ v }, b{ v }
              { }

              int a{}, b{7};
            };
          }")

  (cpp/jank.runtime.get_global_cpp_functions)

  (cpp/jank.runtime.get_global_cpp_types)

  (let* [arg (cpp/int. 6)
         f (cpp/eita.cpp.constructor.complex.pass_argument.foo. arg)]
    [(cpp/.-a f)
     (cpp/.-b f)])

  (cpp/raw "namespace test
          {
            struct Point
            {
              Point() : x{0}, y{0} {}
              Point(int x_val) : x{x_val}, y{0} {}
              Point(int x_val, int y_val) : x{x_val}, y{y_val} {}

              int x;
              int y;
            };
          }")

  (let [a (cpp/test.Point.  (cpp/int. 4)
                            (cpp/int. 56))]
    [(cpp/.-x a)
     (cpp/.-y a)])

  (cpp/raw "
/** Enable/disable logging timestamp.
 * By default timestamps are disabled. Note that enabling timestamps introduces
 * overhead as the logging code will need to obtain the current time.
 *
 * @param enabled Whether to enable tracing with timestamps.
 * @return Previous timestamp setting.
 */
int my_add(int x, int y) {
    return (x + y);
}
")

  (cpp/my_add 4 5)

  (cpp/raw "
// Adds two integers together
int my_add2(int x, int y) {
    return (x + y);
}
")

  (cpp/my_add2 4 5)


  ())
