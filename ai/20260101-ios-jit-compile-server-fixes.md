# iOS JIT Compile Server Fixes

## What I Learned

### 1. Module Redefinition Error in Compile Server

**Problem**: When requiring a namespace like `vybe.sdf.ios`, the compile server was compiling it twice:
1. Once as a "transitive dependency" (because it was added to `loaded_modules_in_order` when the ns form was evaluated)
2. Once as the "main module" (the explicit namespace being required)

This caused:
```
error: redefinition of 'jank_load_vybe_sdf_ios$loading__'
input_line_12:65:5781: error: redefinition of 'jank_load_vybe_sdf_ios$loading__'
input_line_11:65:6571: note: previous definition is here
```

**Root Cause**: In `server.hpp`, the `require_ns` function:
1. Evaluates the ns form (line ~819), which registers the namespace and adds it to `loaded_modules_in_order`
2. Collects modules to compile from `loaded_modules_in_order` (lines ~882-895), which now includes the main module
3. Compiles each module as a transitive dependency (lines ~952-1017)
4. Compiles the main module separately (lines ~1019-1132)

**Solution**: Skip the main module when iterating transitive dependencies:
```cpp
for(auto const &dep_module : modules_to_compile)
{
  // Skip the main module - it will be compiled separately after dependencies
  std::string dep_module_str(dep_module.data(), dep_module.size());
  if(dep_module_str == ns_name)
  {
    continue;
  }
  // ... rest of loop
}
```

### 2. Var Initialization Bypass Bug (CRITICAL FIX)

**Problem**: After the redefinition fix, a SIGSEGV crash occurred at address 0x49 in `var::get_thread_binding()`. The crash happened because vars were not being initialized before being dereferenced.

**Root Cause**: The compile server was generating a custom entry function:
```cpp
extern "C" ::jank::runtime::object_ref entry_symbol() {
  return ::jank::runtime::make_box<qualified_struct>()->call();
}
```

This **bypassed** the `jank_load_XXX` function generated by the codegen processor, which contains the **critical var and constant initialization code**:
```cpp
void jank_load_XXX() {
  jank_ns_intern_c("...");
  jank_ns_set_symbol_counter("...", N);

  // CRITICAL: Vars are initialized here with placement new
  new (&ns::var1) jank::runtime::var_ref(jank::runtime::__rt_ctx->intern_var("...").expect_ok());
  new (&ns::var2) jank::runtime::var_ref(jank::runtime::__rt_ctx->intern_var("...").expect_ok());
  // ... more var initializations

  // Constants are also initialized here
  new (&ns::const1) ...;

  // Then the actual code runs
  ns::main_struct{}.call();
}
```

**Solution**: Use the `jank_load_XXX` function as the entry symbol instead of creating a custom entry:
```cpp
// Use the jank_load_XXX function as the entry symbol - this function is generated
// by the codegen processor and contains the critical var/constant initialization code.
auto const load_fn_name = runtime::module::module_to_load_function(module_name);
auto const entry_symbol = std::string(load_fn_name.data(), load_fn_name.size());

// The codegen processor already generates the jank_load_XXX entry function
// which properly initializes lifted vars/constants before calling the main code.
cpp_code += std::string(cpp_code_body);
// NO custom entry function needed!
```

This fix was applied to both `require_ns` and `compile_namespace_source` functions.

### 3. C++ Absolute Namespace Resolution with `::`

When a header is included inside deeply nested namespaces (like `jank::runtime::module::...`), relative namespace lookups can fail. Using `::jank::runtime::object_ref` instead of `jank::runtime::object_ref` ensures absolute namespace resolution from the global namespace.

### 4. Module Name Derivation from Path vs Module Name

The `load_jank` and `load_cljc` functions in `loader.cpp` were deriving the namespace from `entry.path` using `path_to_module()`. On iOS, `entry.path` is an absolute path like `/Users/.../SdfViewerMobile-JIT-Sim.app/...`, which `path_to_module()` incorrectly converts to `Users.pfeodrippe.Library...`.

**Fix**: Pass the module name directly to `load_jank`/`load_cljc` instead of deriving it from the path.

## Commands I Ran

```bash
# Build jank with fixes
cd /Users/pfeodrippe/dev/jank/compiler+runtime
SDKROOT=/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk \
CC=$PWD/build/llvm-install/usr/local/bin/clang \
CXX=$PWD/build/llvm-install/usr/local/bin/clang++ \
./bin/compile

# Kill old processes and run fresh test
pkill -f "compile-server.*5570"
pkill -f "SdfViewerMobile-JIT-Sim"
make ios-jit-sim-run

# Check compile server process
ps aux | grep -E "compile.server|SdfViewerMobile"

# Check logs
tail -100 /tmp/ios-jit-test.log
```

## Files Modified

### jank Compiler

1. **`/Users/pfeodrippe/dev/jank/compiler+runtime/include/cpp/jank/compile_server/server.hpp`**
   - Added skip for main module in transitive dependency compilation loop (lines 954-959)
   - **CRITICAL FIX**: Changed entry symbol to use `jank_load_XXX` function instead of custom entry
   - Removed custom entry function generation that bypassed var initialization
   - Applied same fix to `compile_namespace_source` function

2. **`/Users/pfeodrippe/dev/jank/compiler+runtime/src/cpp/jank/runtime/module/loader.cpp`**
   - Changed `load_jank` and `load_cljc` to accept module name parameter
   - Use module name directly instead of deriving from absolute path

3. **`/Users/pfeodrippe/dev/jank/compiler+runtime/include/cpp/jank/runtime/module/loader.hpp`**
   - Updated function declarations to include module parameter

### Project Files

4. **`/Users/pfeodrippe/dev/something/SdfViewerMobile/jank-resources/include/vybe/vybe_flecs_jank.h`**
   - Changed `jank::runtime::object_ref` to `::jank::runtime::object_ref`
   - Uses absolute namespace resolution to avoid issues when included in nested namespaces

5. **`/Users/pfeodrippe/dev/something/Makefile`** (from previous session)
   - Added LLVM version tracking for `libllvm_merged.a` staleness check

### 5. Core Modules and Native Modules Not Being Skipped

**Problem**: After the var initialization fix, a SIGABRT crash occurred in `validate_meta()` during `var::with_meta()`. The crash happened after loading `vybe.sdf.math` and `vybe.sdf.state`, while loading the third module.

**Root Cause**: The `core_modules()` function in `loader.cpp` only included:
- `clojure.core`
- `jank.nrepl-server.asio`

But the iOS app AOT-compiles and loads more modules:
- `clojure.string`
- `clojure.set`
- `clojure.walk`
- `clojure.template`
- `clojure.test`
- `jank.nrepl-server.server`

When the compile server tried to recompile `clojure.string` (which was already loaded from AOT), it caused conflicts that corrupted the runtime state.

**Solution**: Expand `core_modules()` to include all AOT and native modules:
```cpp
static native_set<jtl::immutable_string> const modules{
  "clojure.core",
  "clojure.string",
  "clojure.set",
  "clojure.walk",
  "clojure.template",
  "clojure.test",
  "jank.nrepl-server.asio",
  "jank.nrepl-server.server",
  // Native modules (C++ implementations, no jank source to compile)
  "clojure.core-native",
  "jank.perf-native",
  "jank.compiler-native",
  // Special pseudo-modules
  "native",
  "cpp",
};
```

## Current Status - WORKING! âœ“

All modules now load successfully:
```
[loader] Loaded remote module: vybe.sdf.math
[loader] Loaded remote module: vybe.sdf.state
[loader] Loaded remote module: vybe.util
[loader] Loaded remote module: vybe.sdf.shader
[loader] Loaded remote module: vybe.sdf.greeting
[loader] Loaded remote module: vybe.sdf.ui
[loader] Loaded remote module: vybe.type
[loader] Loaded remote module: vybe.flecs
[loader] Loaded remote module: vybe.sdf.ios
[jank] Module loaded successfully!
```

The iOS JIT Compile Server is now fully functional. The remaining error `invalid object type (expected real found nil)` is an application-level bug, not a JIT/compiler issue.

## Summary of All Fixes

1. **Redefinition Error**: Skip main module in transitive dependency loop
2. **Var Initialization Bypass**: Use `jank_load_XXX` entry function instead of custom entry
3. **Core Modules Skipping**: Expanded `core_modules()` to include all AOT-compiled modules
4. **Native Modules Skipping**: Added native/pseudo modules to skip list

## Files Modified (Updated)

### jank Compiler

1. **`/Users/pfeodrippe/dev/jank/compiler+runtime/include/cpp/jank/compile_server/server.hpp`**
   - Added skip for main module in transitive dependency compilation loop
   - Changed entry symbol to use `jank_load_XXX` function
   - Applied fix to both `require_ns` and `compile_namespace_source` functions
   - Added debug code dump to `/tmp/jank-debug-*.cpp` for inspection

2. **`/Users/pfeodrippe/dev/jank/compiler+runtime/src/cpp/jank/runtime/module/loader.cpp`**
   - Expanded `core_modules()` to include all AOT-compiled modules
   - Added native modules (clojure.core-native, jank.perf-native, etc.)
   - Added pseudo-modules (native, cpp)

3. **`/Users/pfeodrippe/dev/jank/compiler+runtime/include/cpp/jank/runtime/module/loader.hpp`**
   - Updated function declarations

### Project Files

4. **`/Users/pfeodrippe/dev/something/SdfViewerMobile/jank-resources/include/vybe/vybe_flecs_jank.h`**
   - Changed to absolute namespace resolution with `::`

5. **`/Users/pfeodrippe/dev/something/Makefile`**
   - Added LLVM version tracking

## What's Next

1. **Fix application bug**: The `invalid object type (expected real found nil)` error is in the app code, likely a nil value where a number was expected
2. **Clean up debug output**: Remove the debug code dump once everything is stable
3. **Consider caching**: The compile server could cache compiled modules to avoid re-compiling on each iOS app restart
