#version 450
//
// COLOR SAMPLER - Samples surface colors at mesh vertex positions
// Used for exporting meshes with accurate SDF shader colors
//
// All scene code, lighting, and painterly effects are EXTRACTED from the main shader
// so exports automatically match the visual style.
//

layout(local_size_x = 64) in;

// Input: vertex positions (xyz = position, w = unused)
layout(std430, binding = 0) readonly buffer InputPositions {
    vec4 positions[];
};

// Input: vertex normals (xyz = normal, w = unused)
layout(std430, binding = 1) readonly buffer InputNormals {
    vec4 normals[];
};

// Output: vertex colors (rgb = color, a = 1.0)
layout(std430, binding = 2) writeonly buffer OutputColors {
    vec4 colors[];
};

// Sampler parameters
layout(std140, binding = 3) uniform SamplerParams {
    uint numPoints;     // Total number of vertices to sample
    float time;         // Time value for animated effects
    vec4 cameraPos;     // xyz = position, w = fov
    vec4 lightDir;      // xyz = light direction (normalized)
};

// Provide ubo-like struct for compatibility with extracted scene code
// Matches the main shader's UBO structure so extracted code works
struct UboCompat {
    vec4 cameraPos;      // xyz = position, w = fov
    vec4 cameraTarget;   // xyz = target
    vec4 lightDir;       // xyz = direction (normalized)
    vec4 resolution;     // xy = width/height, z = time
};
UboCompat ubo;

// ============================================================================
// SCENE CODE - Extracted from main shader (SDF, materials, lighting, painterly)
// ============================================================================

// MARKER_SCENE_SDF_START
// Default scene - will be replaced by extracted code from main shader

float sdSphere(vec3 p, float r) {
    return length(p) - r;
}

float sceneSDF(vec3 p) {
    return sdSphere(p, 1.0);
}

vec2 sceneSDF_mat(vec3 p) {
    return vec2(sceneSDF(p), 1.0);
}

vec3 getMaterialColor(int matID, vec3 p) {
    return vec3(0.8, 0.8, 0.8);
}

float calcSoftShadow(vec3 ro, vec3 rd, float mint, float maxt, float k) {
    float res = 1.0;
    float t = mint;
    for (int i = 0; i < 64 && t < maxt; i++) {
        float h = sceneSDF(ro + rd * t);
        if (h < 0.001) return 0.0;
        res = min(res, k * h / t);
        t += clamp(h, 0.02, 0.1);
    }
    return res;
}

float calcAO(vec3 pos, vec3 nor) {
    float occ = 0.0;
    float sca = 1.0;
    for (int i = 0; i < 5; i++) {
        float h = 0.01 + 0.12 * float(i);
        float d = sceneSDF(pos + h * nor);
        occ += (h - d) * sca;
        sca *= 0.95;
    }
    return clamp(1.0 - 3.0 * occ, 0.0, 1.0);
}

float hash2D(vec2 p) {
    return fract(sin(dot(p, vec2(127.1, 311.7))) * 43758.5453);
}

float noise2D(vec2 p) {
    vec2 i = floor(p);
    vec2 f = fract(p);
    f = f * f * (3.0 - 2.0 * f);
    float a = hash2D(i);
    float b = hash2D(i + vec2(1.0, 0.0));
    float c = hash2D(i + vec2(0.0, 1.0));
    float d = hash2D(i + vec2(1.0, 1.0));
    return mix(mix(a, b, f.x), mix(c, d, f.x), f.y);
}

float fbm(vec2 p) {
    float f = 0.0;
    f += 0.5 * noise2D(p); p *= 2.0;
    f += 0.25 * noise2D(p); p *= 2.0;
    f += 0.125 * noise2D(p);
    return f;
}

vec3 posterize(vec3 col, float levels) {
    return floor(col * levels + 0.5) / levels;
}

float brushStroke(vec2 uv, vec3 normal, float scale) {
    vec2 dir = normalize(normal.xy + 0.001);
    float angle = atan(dir.y, dir.x);
    vec2 rotUV = vec2(
        uv.x * cos(angle) - uv.y * sin(angle),
        uv.x * sin(angle) + uv.y * cos(angle)
    );
    rotUV.x *= 3.0;
    return fbm(rotUV * scale);
}

// Compute smooth normal from SDF gradient (matches raymarched view)
// This gives much better results than using mesh normals from marching cubes
vec3 calcNormal(vec3 p) {
    const float eps = 0.0001;
    vec2 e = vec2(eps, 0);
    return normalize(vec3(
        sceneSDF(p + e.xyy) - sceneSDF(p - e.xyy),
        sceneSDF(p + e.yxy) - sceneSDF(p - e.yxy),
        sceneSDF(p + e.yyx) - sceneSDF(p - e.yyx)
    ));
}
// MARKER_SCENE_SDF_END

// ============================================================================
// MAIN - Sample color at each vertex using extracted shader code
// ============================================================================

void main() {
    uint idx = gl_GlobalInvocationID.x;

    if (idx >= numPoints) return;

    // Set up ubo compatibility struct from SamplerParams
    ubo.cameraPos = cameraPos;
    ubo.cameraTarget = vec4(0.0, 0.0, 0.0, 1.0);  // Default target
    ubo.lightDir = lightDir;
    ubo.resolution = vec4(1.0, 1.0, time, 1.0);

    vec3 p = positions[idx].xyz;

    // Use SDF gradient normal instead of mesh normal for smooth shading
    // Mesh normals from marching cubes are faceted and cause harsh shadows
    vec3 n = calcNormal(p);

    // Get material at this point
    vec2 mat = sceneSDF_mat(p);
    int matID = int(mat.y);
    vec3 albedo = getMaterialColor(matID, p);

    // Compute lighting (same as main shader)
    vec3 ldir = normalize(lightDir.xyz);

    // Diffuse
    float diff = max(dot(n, ldir), 0.0);

    // View direction (from point to camera)
    vec3 viewDir = normalize(cameraPos.xyz - p);

    // Specular (Blinn-Phong)
    vec3 h = normalize(ldir + viewDir);
    float spec = pow(max(dot(n, h), 0.0), 12.0);

    // Shadows
    float shadow = calcSoftShadow(p + n * 0.002, ldir, 0.02, 10.0, 6.0);

    // Ambient occlusion
    float ao = calcAO(p, n);

    // Ambient (warm/cool)
    vec3 warmAmbient = vec3(0.25, 0.18, 0.12) * ao;
    vec3 coolAmbient = vec3(0.08, 0.12, 0.16) * ao;
    vec3 ambient = mix(warmAmbient, coolAmbient, max(0.0, -n.y) * 0.5);

    // Combine lighting
    float diffIntensity = diff * 0.85 + 0.15;
    diffIntensity *= mix(0.4, 1.0, shadow);
    vec3 diffuse = albedo * diffIntensity;

    // Rim light
    float rim = pow(1.0 - max(dot(n, viewDir), 0.0), 3.5);
    vec3 rimLight = vec3(0.5, 0.3, 0.15) * rim * 0.6;

    // Specular
    vec3 specular = vec3(0.1) * spec * shadow;

    // Final color
    vec3 col = ambient + diffuse + specular + rimLight;

    // Painterly effects (using extracted functions from main shader)
    // For vertex coloring, use MUCH lower frequency noise than per-pixel rendering
    // Mesh has ~3000-7000 vertices vs millions of pixels, so need smooth gradients
    vec2 uv = (p.xy + 2.0) / 4.0 + (p.zx + 1.0) / 4.0 * 0.5;

    // Lower frequency brush strokes for smooth appearance at vertex resolution
    float brush = brushStroke(p.xy * 8.0 + p.zx * 4.0, n, 8.0);
    col *= (0.92 + brush * 0.16);
    col = posterize(col, 8.0);

    // Much lower frequency noise for smooth color gradients (not per-pixel noise)
    float colorVar = noise2D(uv * 12.0 + p.xy * 3.0);
    col.r += (colorVar - 0.5) * 0.06;
    col.g += (noise2D(uv * 14.0) - 0.5) * 0.04;
    col.b -= (colorVar - 0.5) * 0.05;

    // Edge darkening
    float edgeFactor = pow(1.0 - abs(dot(n, viewDir)), 0.7);
    col *= (1.0 - edgeFactor * 0.25);

    // Gamma correction
    col = pow(col, vec3(1.0 / 2.2));

    // Clamp to valid range
    col = clamp(col, 0.0, 1.0);

    colors[idx] = vec4(col, 1.0);
}
