#version 450
//
// COLOR SAMPLER - Samples surface colors at mesh vertex positions
// Used for exporting meshes with accurate SDF shader colors
//
// This shader takes vertex positions and normals from the mesh
// and computes the final rendered color at each point using
// the same lighting/materials as the main shader.
//

layout(local_size_x = 64) in;

// Input: vertex positions (xyz = position, w = unused)
layout(std430, binding = 0) readonly buffer InputPositions {
    vec4 positions[];
};

// Input: vertex normals (xyz = normal, w = unused)
layout(std430, binding = 1) readonly buffer InputNormals {
    vec4 normals[];
};

// Output: vertex colors (rgb = color, a = 1.0)
layout(std430, binding = 2) writeonly buffer OutputColors {
    vec4 colors[];
};

// Sampler parameters
layout(std140, binding = 3) uniform SamplerParams {
    uint numPoints;     // Total number of vertices to sample
    float time;         // Time value for animated effects
    vec4 cameraPos;     // xyz = position, w = fov
    vec4 lightDir;      // xyz = light direction (normalized)
};

// ============================================================================
// SCENE CODE - Extracted from main shader
// ============================================================================

// MARKER_SCENE_SDF_START
// Default scene - will be replaced by extracted code

float sdSphere(vec3 p, float r) {
    return length(p) - r;
}

float sceneSDF(vec3 p) {
    return sdSphere(p, 1.0);
}

vec2 sceneSDF_mat(vec3 p) {
    return vec2(sceneSDF(p), 1.0);
}

vec3 getMaterialColor(int matID, vec3 p) {
    return vec3(0.8, 0.8, 0.8);  // Default gray
}
// MARKER_SCENE_SDF_END

// ============================================================================
// LIGHTING (matches main shader)
// ============================================================================

float calcSoftShadow(vec3 ro, vec3 rd, float mint, float maxt, float k) {
    float res = 1.0;
    float t = mint;
    for (int i = 0; i < 64 && t < maxt; i++) {
        float h = sceneSDF(ro + rd * t);
        if (h < 0.001) return 0.0;
        res = min(res, k * h / t);
        t += clamp(h, 0.02, 0.1);
    }
    return res;
}

float calcAO(vec3 pos, vec3 nor) {
    float occ = 0.0;
    float sca = 1.0;
    for (int i = 0; i < 5; i++) {
        float h = 0.01 + 0.12 * float(i);
        float d = sceneSDF(pos + h * nor);
        occ += (h - d) * sca;
        sca *= 0.95;
    }
    return clamp(1.0 - 3.0 * occ, 0.0, 1.0);
}

// ============================================================================
// MAIN - Sample color at each vertex
// ============================================================================

void main() {
    uint idx = gl_GlobalInvocationID.x;

    if (idx >= numPoints) return;

    vec3 p = positions[idx].xyz;
    vec3 n = normalize(normals[idx].xyz);

    // Get material at this point
    vec2 mat = sceneSDF_mat(p);
    int matID = int(mat.y);
    vec3 albedo = getMaterialColor(matID, p);

    // Compute lighting (same as main shader)
    vec3 ldir = normalize(lightDir.xyz);

    // Diffuse
    float diff = max(dot(n, ldir), 0.0);

    // View direction (from camera to point)
    vec3 viewDir = normalize(cameraPos.xyz - p);

    // Specular (Blinn-Phong)
    vec3 h = normalize(ldir + viewDir);
    float spec = pow(max(dot(n, h), 0.0), 12.0);

    // Shadows
    float shadow = calcSoftShadow(p + n * 0.002, ldir, 0.02, 10.0, 6.0);

    // Ambient occlusion
    float ao = calcAO(p, n);

    // Ambient (warm/cool)
    vec3 warmAmbient = vec3(0.25, 0.18, 0.12) * ao;
    vec3 coolAmbient = vec3(0.08, 0.12, 0.16) * ao;
    vec3 ambient = mix(warmAmbient, coolAmbient, max(0.0, -n.y) * 0.5);

    // Combine lighting
    float diffIntensity = diff * 0.85 + 0.15;
    diffIntensity *= mix(0.4, 1.0, shadow);
    vec3 diffuse = albedo * diffIntensity;

    // Rim light
    float rim = pow(1.0 - max(dot(n, viewDir), 0.0), 3.5);
    vec3 rimLight = vec3(0.5, 0.3, 0.15) * rim * 0.6;

    // Specular
    vec3 specular = vec3(0.1) * spec * shadow;

    // Final color
    vec3 col = ambient + diffuse + specular + rimLight;

    // Gamma correction
    col = pow(col, vec3(1.0 / 2.2));

    // Clamp to valid range
    col = clamp(col, 0.0, 1.0);

    colors[idx] = vec4(col, 1.0);
}
