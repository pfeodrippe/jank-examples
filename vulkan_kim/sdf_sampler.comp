#version 450
//
// SDF SAMPLER - Generic SDF sampling compute shader
// Used for mesh export via marching cubes
//
// MEMORY OPTIMIZED: Positions computed on-the-fly from grid parameters
// instead of passing a huge positions buffer (saves 2GB+ for 512^3 grids)
//

layout(local_size_x = 64) in;

// Output: SDF distances at each point
layout(std430, binding = 0) writeonly buffer OutputDistances {
    float distances[];
};

// Grid parameters - compute positions from these instead of passing positions buffer
layout(std140, binding = 1) uniform SamplerParams {
    uint resolution;    // Grid resolution (e.g., 512)
    float time;         // Time value for animated SDFs
    float minX, minY, minZ;  // Bounds min
    float maxX, maxY, maxZ;  // Bounds max
};

// Provide ubo-like struct for compatibility with extracted scene code
struct UboCompat {
    vec4 resolution;  // .z is time
    vec4 lightDir;
};
UboCompat ubo;

// ============================================================================
// SCENE SDF - Extracted from main shader (primitives + boolean ops + scene)
// ============================================================================

// MARKER_SCENE_SDF_START
// Default scene - a simple sphere (will be replaced by extracted code)
float sdSphere(vec3 p, float r) {
    return length(p) - r;
}

float sceneSDF(vec3 p) {
    return sdSphere(p, 1.0);
}
// MARKER_SCENE_SDF_END

// ============================================================================
// MAIN
// ============================================================================

void main() {
    uint idx = gl_GlobalInvocationID.x;
    uint totalPoints = resolution * resolution * resolution;

    if (idx >= totalPoints) return;

    // Set up ubo compatibility (time in resolution.z)
    ubo.resolution = vec4(1.0, 1.0, time, 1.0);
    ubo.lightDir = vec4(0.5, 0.8, 0.6, 0.0);

    // Compute 3D grid position from linear index (no positions buffer needed!)
    uint res = resolution;
    uint ix = idx % res;
    uint iy = (idx / res) % res;
    uint iz = idx / (res * res);

    // Compute world position from grid coordinates
    float stepX = (maxX - minX) / float(res - 1u);
    float stepY = (maxY - minY) / float(res - 1u);
    float stepZ = (maxZ - minZ) / float(res - 1u);

    vec3 p = vec3(
        minX + float(ix) * stepX,
        minY + float(iy) * stepY,
        minZ + float(iz) * stepZ
    );

    distances[idx] = sceneSDF(p);
}
